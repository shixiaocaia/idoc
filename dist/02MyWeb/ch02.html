<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>线程池 iDoc</title>
    <meta name="description" content="基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用多进程模型，也就是为每个客户端分配一个进程来处理请求。">
    <meta name="keywords" content="notebook">
    <link rel="stylesheet" type="text/css" href="../css/main.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/tocbot.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/media.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/sidebar.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/copy.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/fancybox.css?v=1.21.13">
    <link rel="icon" href="../logo.png" type="image/x-icon">
    <script src="../js/copy.js?v=1.21.13"></script>
    <script src="../js/dark-mode.js?v=1.21.13"></script>
    <script src="../js/markdown-style.js?v=1.21.13"></script>
    <script src="../js/jquery.min.js?v=1.21.13"></script>
    <script src="../js/fancybox.umd.js?v=1.21.13"></script>
  </head>
  <body><button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
    <script>
// Get the button:
let mybutton = document.getElementById("myBtn");
// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};
// 顶部隐藏，底部隐藏
function scrollFunction() {
if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
mybutton.style.display = "block";
} else {
mybutton.style.display = "none";
}
}
// When the user clicks on the button, scroll to the top of the document
function topFunction() {
document.body.scrollTop = 0; // For Safari
document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
}
</script>
    <header class="header">
      <article class="inner warpper"><a class="logo" href="../index.html"><img alt="iDoc logo" src="../logo.png">
<span class="title">iDoc</span></a>
        <div class="content">
          <ul class="menu">
            <li><a href="../index.html" target="" class="">Home</a></li>
            <li><a href="../00CPP/index.html" target="" class="">Cpp</a></li>
            <li><a href="../01DataStructure/index.html" target="" class="">DataStructure</a></li>
            <li><a href="../01OperatingSystem/index.html" target="" class="">OperatingSystem</a></li>
            <li><a href="../01ComputerNetwork/index.html" target="" class="">ComputerNetwrok</a></li>
            <li><a href="../01DataBase/index.html" target="" class="">DataBase</a></li>
            <li><a href="index.html" target="" class="active">Webserver</a></li>
            <li><a href="../00Other/index.html" target="" class="">Other</a></li>
          </ul><a href="https://github.com/shixiaocaia" target="_blank" rel="noopener noreferrer" title="Github" name="Github" class="github"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg></a>
          <dark-mode permanent=""></dark-mode>
        </div>
      </article>
    </header>
    <div class="warpper-content warpper sidebar">
      <div class="sidebar-border">
        <aside class="sidebar" role="navigation">
          <div>
            <a href="index.html" class="">↩️README</a>
            <a href="ch00.html" class="">问题收集</a>
            <a href="ch01.html" class="">线程同步机制封装类</a>
            <a href="ch02.html" class="">半同步/半反应堆线程池</a>
            <a href="ch03.html" class="">I/O多路复用</a>
            <a href="ch04.html" class="">HTTP连接请求处理类</a>
            <a href="ch05.html" class="">定时器处理非活动链接 - 1</a>
            <a href="ch06.html" class="">定时器处理非活动链接 - 2</a>
            <a href="ch07.html" class="">日志系统 - 1</a>
            <a href="ch08.html" class="">日志系统 - 2</a>
            <a href="ch09.html" class="">数据库连接池</a>
            <a href="ch010.html" class="">注册登录</a>
            <a href="ch011.html" class="">压力测试</a>
          </div>
        </aside>
      </div>
      <markdown-style>
        <h1 id="线程池"><a aria-hidden="true" tabindex="-1" href="#线程池" class="anchor"><span class="icon icon-link"></span></a>线程池</h1>
        <h2 id="前置知识"><a aria-hidden="true" tabindex="-1" href="#前置知识" class="anchor"><span class="icon icon-link"></span></a>前置知识</h2>
        <h3 id="多进程模型"><a aria-hidden="true" tabindex="-1" href="#多进程模型" class="anchor"><span class="icon icon-link"></span></a>多进程模型</h3>
        <p>基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用<strong>多进程模型</strong>，也就是为每个客户端分配一个进程来处理请求。</p>
        <p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，<code>accept() 函数</code>就会返回一个「已连接 Socket」，这时就通过 <code>fork()</code> 函数创建一个子进程，实际上就把父进程所有相关的东西都<strong>复制</strong>一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p>
        <p>这两个进程刚复制完的时候，几乎一模一样。不过，会根据<strong>返回值</strong>来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。</p>
        <p>正因为子进程会<strong>复制父进程的文件描述符</strong>，于是就可以直接使用「已连接 Socket 」和客户端通信了，</p>
        <p>可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。</p>
        <p>下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。</p>
        <p>
          <img src="http://pic.shixiaocaia.fun/202301241830108.png" alt="img">
        </p>
        <p>另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成<strong>僵尸进程</strong>，随着僵尸进程越多，会慢慢耗尽我们的系统资源。</p>
        <p>因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 <code>wait()</code> 和 <code>waitpid()</code> 函数。</p>
        <p>这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。</p>
        <blockquote>
          <p>进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</p>
        </blockquote>
        <h3 id="多线程模型"><a aria-hidden="true" tabindex="-1" href="#多线程模型" class="anchor"><span class="icon icon-link"></span></a>多线程模型</h3>
        <p>线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。</p>
        <p>当服务器与客户端 TCP 完成连接后，通过 <code>pthread_create()</code> 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。</p>
        <p>
          <img src="http://pic.shixiaocaia.fun/202301241830456.png" alt="img">
        </p>
        <h3 id="线程池-1"><a aria-hidden="true" tabindex="-1" href="#线程池-1" class="anchor"><span class="icon icon-link"></span></a>线程池</h3>
        <p>我们每次接受一个HTTP连接，就创建一个线程来执行任务，这十分浪费效率。我们创建线程会涉及系统调用，开销比较大，不如一次性生成多个线程供我们所用。有新连接到达时，就从线程池中抽取一个线程来执行任务，其他线程没有任务时阻塞。</p>
        <p>当新连接到来，我们调用线程池的函数插入任务到队列中，然后通过算法选出一个线程，该线程从任务队列中取出任务，然后执行处理函数。</p>
        <p>那我们既然使用了多线程，就一定会涉及到线程的互斥，同步问题。</p>
        <ul>
          <li>任务队列是公共资源，访问它必须保证互斥。</li>
          <li>任务队列不为空时，线程才能从中取出任务，必须保证线程同步（生产者消费者模型）</li>
        </ul>
        <p>所以，我们会需要用到互斥锁，条件变量，信号量。我们将这些操作封装成<code>Locker</code>类，在单独的文件中实现。</p>
        <blockquote>
          <p>线程和进程的区别？</p>
        </blockquote>
        <h2 id="线程池类的定义"><a aria-hidden="true" tabindex="-1" href="#线程池类的定义" class="anchor"><span class="icon icon-link"></span></a>线程池类的定义</h2>
        <p><strong>考虑到实现，我们需要设置以下属性</strong></p>
        <ul>
          <li>需要指定线程数量</li>
          <li>需要指定任务队列的最大任务数</li>
          <li>描述线程池的数组</li>
          <li>请求队列</li>
          <li>保护请求队列的互斥锁</li>
          <li>对于读写事件的标志</li>
        </ul>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1"><span class="token comment">// 线程池类，将它定义为模板类是为了代码复用，模板参数T是任务类</span>
</span><span class="code-line line-number" line="2"><span class="token keyword">template</span><span class="token operator">&#x3C;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">></span>
</span><span class="code-line line-number" line="3"><span class="token keyword">class</span> <span class="token class-name">ThreadPool</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="4"><span class="token keyword">public</span><span class="token operator">:</span>
</span><span class="code-line line-number" line="5">    <span class="token comment">/*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span>
</span><span class="code-line line-number" line="6">    <span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> thread_number<span class="token punctuation">,</span> <span class="token keyword">int</span> max_requests<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="7">    <span class="token operator">~</span><span class="token function">ThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="8">    <span class="token comment">//插入任务函数</span>
</span><span class="code-line line-number" line="9">    <span class="token keyword">bool</span> <span class="token function">Append</span><span class="token punctuation">(</span>T<span class="token operator">*</span> request<span class="token punctuation">,</span> <span class="token keyword">int</span> event_flag<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="10">
</span><span class="code-line line-number" line="11"><span class="token keyword">private</span><span class="token operator">:</span>
</span><span class="code-line line-number" line="12">    <span class="token comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span>
</span><span class="code-line line-number" line="13">    <span class="token comment">//线程被创建的时候被指明执行该函数,我们会将this指针传递进去,因为静态函数无法访问成员变量</span>
</span><span class="code-line line-number" line="14">    <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">ThreadWorkFunc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="15">    <span class="token keyword">void</span> <span class="token function">ThreadRun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="16">
</span><span class="code-line line-number" line="17"><span class="token keyword">private</span><span class="token operator">:</span>    
</span><span class="code-line line-number" line="18">    <span class="token keyword">int</span> thread_number_<span class="token punctuation">;</span>            <span class="token comment">// 线程的数量    </span>
</span><span class="code-line line-number" line="19">    <span class="token keyword">int</span> max_requests_<span class="token punctuation">;</span>             <span class="token comment">// 请求队列中最多允许的、等待处理的请求的数量 </span>
</span><span class="code-line line-number" line="20">    pthread_t <span class="token operator">*</span> threads_<span class="token punctuation">;</span>          <span class="token comment">// 描述线程池的数组，大小为thread_number_    </span>
</span><span class="code-line line-number" line="21">    std<span class="token double-colon punctuation">::</span>list<span class="token operator">&#x3C;</span> T<span class="token operator">*</span> <span class="token operator">></span> workqueue_<span class="token punctuation">;</span>    <span class="token comment">// 请求队列</span>
</span><span class="code-line line-number" line="22">    Locker queuelocker_<span class="token punctuation">;</span>           <span class="token comment">// 保护请求队列的互斥锁</span>
</span><span class="code-line line-number" line="23">    Sem queuestat_<span class="token punctuation">;</span>                <span class="token comment">// 是否有任务需要处理</span>
</span><span class="code-line line-number" line="24">    <span class="token keyword">bool</span> stop_<span class="token punctuation">;</span>                    <span class="token comment">// 是否结束线程   </span>
</span><span class="code-line line-number" line="25">    <span class="token keyword">int</span> event_flag_<span class="token punctuation">;</span>               <span class="token comment">// 0:读事件  1:写事件               </span>
</span><span class="code-line line-number" line="26"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><input type="hidden" value="// 线程池类，将它定义为模板类是为了代码复用，模板参数T是任务类
template<typename T>
class ThreadPool {
public:
    /*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/
    ThreadPool(int thread_number, int max_requests);
    ~ThreadPool();
    //插入任务函数
    bool Append(T* request, int event_flag);

private:
    /*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/
    //线程被创建的时候被指明执行该函数,我们会将this指针传递进去,因为静态函数无法访问成员变量
    static void* ThreadWorkFunc(void* arg);
    void ThreadRun();

private:    
    int thread_number_;            // 线程的数量    
    int max_requests_;             // 请求队列中最多允许的、等待处理的请求的数量 
    pthread_t * threads_;          // 描述线程池的数组，大小为thread_number_    
    std::list< T* > workqueue_;    // 请求队列
    Locker queuelocker_;           // 保护请求队列的互斥锁
    Sem queuestat_;                // 是否有任务需要处理
    bool stop_;                    // 是否结束线程   
    int event_flag_;               // 0:读事件  1:写事件               
};
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <blockquote>
          <p><code>ThreadWorkFunc</code>如果是一个普通的类成员函数，那么自带的默认参数this指针，和函数原型的<code>void *</code>冲突了。</p>
        </blockquote>
        <h2 id="函数分析"><a aria-hidden="true" tabindex="-1" href="#函数分析" class="anchor"><span class="icon icon-link"></span></a>函数分析</h2>
        <p>设置线程分离，从而让操作系统在该线程结束时来回收它所占的资源，不需要手动回收。</p>
      </markdown-style>
      <nav class="tocs">
        <aside class="inner toc">
          <ol class="tocs-list">
            <li><a href="#前置知识" class="tocs-link">前置知识</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#多进程模型" class="tocs-link">多进程模型</a></li>
                <li><a href="#多线程模型" class="tocs-link">多线程模型</a></li>
                <li><a href="#线程池-1" class="tocs-link">线程池</a></li>
              </ol>
            </li>
            <li><a href="#线程池类的定义" class="tocs-link">线程池类的定义</a></li>
            <li><a href="#函数分析" class="tocs-link">函数分析</a></li>
          </ol>
        </aside>
      </nav>
    </div>
    <script src="../js/demo-preview.js?v=1.21.13"></script>
    <div class="footer warpper">Created by <a href="https://github.com/shixiaocaia" target="_blank">shixiaocaia</a> | Powered by <a href="https://github.com/jaywcjlove/idoc" target="_blank">idoc</a><br>Think less and do more.</div>
    <script src="../js/tocbot.js?v=1.21.13"></script>
  </body>
</html>
