<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>排序 iDoc</title>
    <meta name="description" content="使得相邻两个元素比较大小，大的元素慢慢下沉，下次循环到len - 1 - i，因为底部有一部分已经排序完成了">
    <meta name="keywords" content="notebook">
    <link rel="stylesheet" type="text/css" href="../css/main.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/tocbot.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/media.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/sidebar.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/copy.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/fancybox.css?v=1.21.13">
    <link rel="icon" href="../logo.png" type="image/x-icon">
    <script src="../js/copy.js?v=1.21.13"></script>
    <script src="../js/dark-mode.js?v=1.21.13"></script>
    <script src="../js/markdown-style.js?v=1.21.13"></script>
    <script src="../js/jquery.min.js?v=1.21.13"></script>
    <script src="../js/fancybox.umd.js?v=1.21.13"></script>
  </head>
  <body><button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
    <script>
// Get the button:
let mybutton = document.getElementById("myBtn");
// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};
// 顶部隐藏，底部隐藏
function scrollFunction() {
if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
mybutton.style.display = "block";
} else {
mybutton.style.display = "none";
}
}
// When the user clicks on the button, scroll to the top of the document
function topFunction() {
document.body.scrollTop = 0; // For Safari
document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
}
</script>
    <header class="header">
      <article class="inner warpper"><a class="logo" href="../index.html"><img alt="iDoc logo" src="../logo.png">
<span class="title">iDoc</span></a>
        <div class="content">
          <ul class="menu">
            <li><a href="../index.html" target="" class="">Home</a></li>
            <li><a href="../00CPP/index.html" target="" class="">Cpp</a></li>
            <li><a href="index.html" target="" class="active">DataStructure</a></li>
            <li><a href="../01OperatingSystem/index.html" target="" class="">OperatingSystem</a></li>
            <li><a href="../01ComputerNetwork/index.html" target="" class="">ComputerNetwrok</a></li>
            <li><a href="../01DataBase/index.html" target="" class="">DataBase</a></li>
            <li><a href="../02MyWeb/index.html" target="" class="">Webserver</a></li>
            <li><a href="../00Other/index.html" target="" class="">Other</a></li>
          </ul><a href="https://github.com/shixiaocaia" target="_blank" rel="noopener noreferrer" title="Github" name="Github" class="github"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg></a>
          <dark-mode permanent=""></dark-mode>
        </div>
      </article>
    </header>
    <div class="warpper-content warpper sidebar">
      <div class="sidebar-border">
        <aside class="sidebar" role="navigation">
          <div>
            <a href="index.html" class="">↩️README</a>
            <label>Leetcode</label>
            <a href="ch1.html" class="">数组</a>
            <a href="ch2.html" class="">链表</a>
            <a href="ch3.html" class="">哈希表</a>
            <a href="ch4.html" class="">字符串</a>
            <a href="ch5.html" class="">栈与队列</a>
            <a href="ch6.html" class="">二叉树</a>
            <a href="ch7.html" class="">回溯</a>
            <a href="ch8.html" class="">贪心</a>
            <a href="ch9.html" class="">动态规划</a>
            <a href="ch11.html" class="">排序</a>
            <a href="ch12.html" class="">图论</a>
            <a href="ch13.html" class="">其他</a>
          </div>
        </aside>
      </div>
      <markdown-style>
        <h1 id="排序"><a aria-hidden="true" tabindex="-1" href="#排序" class="anchor"><span class="icon icon-link"></span></a>排序</h1>
        <h2 id="冒泡排序"><a aria-hidden="true" tabindex="-1" href="#冒泡排序" class="anchor"><span class="icon icon-link"></span></a>冒泡排序</h2>
        <p>使得相邻两个元素比较大小，大的元素慢慢下沉，下次循环到len - 1 - i，因为底部有一部分已经排序完成了</p>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&#x3C;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&#x26;</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
</span><span class="code-line line-number" line="3">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&#x3C;</span> a<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
</span><span class="code-line line-number" line="4">            <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</span><span class="code-line line-number" line="5">                <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="6">        <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="7">        <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="8">    <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="9"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="void bubbleSort(vector<int>&#x26; a){
    for (int i = 0; i < a.size(); i++){
        for (int j = 0; j < a.size() - i - 1; j++){
            if(a[j] > a[j + 1])
                swap(a[j], a[j + 1]);
        }
        print(a, i);
    }
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <p>优化方式时，当某一次循环，没有发生交换，说明当前的部分已经有序，可以跳出循环。</p>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>vector<span class="token operator">&#x3C;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&#x26;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="3">    <span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="4">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//i = 0 起，循环了n - 1趟，更符合规范理解</span>
</span><span class="code-line line-number" line="5">        flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="6">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&#x3C;</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="7">            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="8">                <span class="token comment">//某一趟排序中，只要发生一次元素交换，flag就从false变为了true</span>
</span><span class="code-line line-number" line="9">                <span class="token comment">//也即表示这一趟排序还不能确定所剩待排序列是否已经有序，应继续下一趟循环</span>
</span><span class="code-line line-number" line="10">                <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="11">                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="12">            <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="13">        <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="14">        <span class="token comment">//但若某一趟中一次元素交换都没有，即依然为flag = false</span>
</span><span class="code-line line-number" line="15">        <span class="token comment">//那么表明所剩待排序列已经有序</span>
</span><span class="code-line line-number" line="16">        <span class="token comment">//不必再进行趟数比较，外层循环应该结束，即此时if (!flag) break; 跳出循环</span>
</span><span class="code-line line-number" line="17">        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="18">    <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="19"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="void bubbleSort(vector<int>&#x26; nums) {
    int n = nums.size();
    bool flag = false;
    for (int i = 0; i < n - 1; ++i) {//i = 0 起，循环了n - 1趟，更符合规范理解
        flag = false;
        for (int j = 0; j < n - 1 - i; ++j) {
            if (nums[j] > nums[j + 1]) {
                //某一趟排序中，只要发生一次元素交换，flag就从false变为了true
                //也即表示这一趟排序还不能确定所剩待排序列是否已经有序，应继续下一趟循环
                swap(nums[j], nums[j + 1]);
                flag = true;
            }
        }
        //但若某一趟中一次元素交换都没有，即依然为flag = false
        //那么表明所剩待排序列已经有序
        //不必再进行趟数比较，外层循环应该结束，即此时if (!flag) break; 跳出循环
        if (!flag) { break; }
    }
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <p>时间复杂度：O(n^2)，各论冒泡的遍历数组长度为n - 1, n - 2, ... , 2, 1，求和可得。</p>
        <p>空间复杂度：O(1)。</p>
        <p>稳定排序：不交换相等元素。</p>
        <h2 id="选择排序"><a aria-hidden="true" tabindex="-1" href="#选择排序" class="anchor"><span class="icon icon-link"></span></a>选择排序</h2>
        <p><strong>选择排序就是将找打数组中最小的元素，将它和数组的第一个元素交换位置，然后再剩下的元素中找最小的元素，和第二元素的位置交换，如此反复。</strong></p>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">void</span> <span class="token function">selectSort</span><span class="token punctuation">(</span>vector<span class="token operator">&#x3C;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&#x26;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">	<span class="token keyword">int</span> len <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="3">	<span class="token keyword">int</span> minIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="4">	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="5">		minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="6">		<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&#x3C;</span> len<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="7">			<span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&#x3C;</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="8">		<span class="token punctuation">}</span>
</span><span class="code-line line-number" line="9">		<span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> nums<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="10">	<span class="token punctuation">}</span>
</span><span class="code-line line-number" line="11"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="void selectSort(vector<int>&#x26; nums) {
	int len = nums.size();
	int minIndex = 0;
	for (int i = 0; i < len; ++i) {
		minIndex = i;
		for (int j = i + 1; j < len; ++j) {
			if (nums[j] < nums[minIndex]) minIndex = j;
		}
		swap(nums[i], nums[minIndex]);
	}
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <h2 id="插入排序"><a aria-hidden="true" tabindex="-1" href="#插入排序" class="anchor"><span class="icon icon-link"></span></a>插入排序</h2>
        <p>在保证左边有序的情况下，当第i个元素数值小于<code>i-1</code>时，将之插入到左边有序序列当中。</p>
        <p>找到左边有序序列中小于a[i]的位置<code>j</code>，将之插入到<code>j + 1</code>这个位置，如果<code>j</code>这个位置元素数值大于<code>a[i]</code>，向后移动<code>a[j]</code>这个位置元素。</p>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>vector<span class="token operator">&#x3C;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&#x26;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">	cout <span class="token operator">&#x3C;&#x3C;</span> <span class="token string">"step"</span><span class="token operator">&#x3C;&#x3C;</span> i <span class="token operator">&#x3C;&#x3C;</span> <span class="token string">": "</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="3">	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&#x3C;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="4">		cout <span class="token operator">&#x3C;&#x3C;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&#x3C;&#x3C;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="5">	<span class="token punctuation">}</span>
</span><span class="code-line line-number" line="6">	cout <span class="token operator">&#x3C;&#x3C;</span> endl<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="7"><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="8"><span class="token keyword">void</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>vector<span class="token operator">&#x3C;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&#x26;</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//{ 9,1,5,6,2,3 }</span>
</span><span class="code-line line-number" line="9">	<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="10">		<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&#x3C;</span> a<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入</span>
</span><span class="code-line line-number" line="11">			<span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="12">			<span class="token keyword">int</span> x <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token comment">//因为后续将i - 1的值后移，找到合适的位置插入，所以需要存储数 = x;值</span>
</span><span class="code-line line-number" line="13">			<span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&#x26;&#x26;</span> x <span class="token operator">&#x3C;</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//查找在有序表的插入位置,还必须要保证j是>=0的 因为a[j]要合法</span>
</span><span class="code-line line-number" line="14">				a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="15">				j<span class="token operator">--</span><span class="token punctuation">;</span>     <span class="token comment">//元素后移</span>
</span><span class="code-line line-number" line="16">			<span class="token punctuation">}</span>
</span><span class="code-line line-number" line="17">			a<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>     <span class="token comment">//插入到正确位置</span>
</span><span class="code-line line-number" line="18">		<span class="token punctuation">}</span>
</span><span class="code-line line-number" line="19">		<span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> n<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//打印每趟排序的结果</span>
</span><span class="code-line line-number" line="20">	<span class="token punctuation">}</span>
</span><span class="code-line line-number" line="21"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="void print(vector<int>&#x26; a, int n, int i) {
	cout << &#x22;step&#x22;<< i << &#x22;: &#x22;;
	for (int j = 0; j < n; j++) {
		cout << a[j] << &#x22; &#x22;;
	}
	cout << endl;
}
void insertionSort(vector<int>&#x26; a, int n) {//{ 9,1,5,6,2,3 }
	for (int i = 1; i < n; ++i) {
		if (a[i] < a[i - 1]) {   //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入
			int j = i - 1;
			int x = a[i];     //因为后续将i - 1的值后移，找到合适的位置插入，所以需要存储数 = x;值
			while (j >= 0 &#x26;&#x26; x < a[j]) {   //查找在有序表的插入位置,还必须要保证j是>=0的 因为a[j]要合法
				a[j + 1] = a[j];
				j--;     //元素后移
			}
			a[j + 1] = x;     //插入到正确位置
		}
		print(a, n, i);      //打印每趟排序的结果
	}
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <p>时间复杂度：O(n^2)。</p>
        <p>空间复杂度：O(1)。</p>
        <p>稳定排序：不交换相等元素。</p>
        <h2 id="快速排序"><a aria-hidden="true" tabindex="-1" href="#快速排序" class="anchor"><span class="icon icon-link"></span></a>快速排序</h2>
        <h3 id="基础版"><a aria-hidden="true" tabindex="-1" href="#基础版" class="anchor"><span class="icon icon-link"></span></a>基础版</h3>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1"><span class="token comment">/* 元素交换 */</span>
</span><span class="code-line line-number" line="2"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>vector<span class="token operator">&#x3C;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&#x26;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="3">    <span class="token keyword">int</span> tmp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="4">    nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="5">    nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="6"><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="7">
</span><span class="code-line line-number" line="8"><span class="token comment">/* 哨兵划分 */</span>
</span><span class="code-line line-number" line="9"><span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span>vector<span class="token operator">&#x3C;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&#x26;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="10">    <span class="token comment">// 以 nums[left] 作为基准数</span>
</span><span class="code-line line-number" line="11">    <span class="token keyword">int</span> i <span class="token operator">=</span> left<span class="token punctuation">,</span> j <span class="token operator">=</span> right<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="12">    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&#x3C;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="13">        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&#x3C;</span> j <span class="token operator">&#x26;&#x26;</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span>
</span><span class="code-line line-number" line="14">            j<span class="token operator">--</span><span class="token punctuation">;</span>          <span class="token comment">// 从右向左找首个小于基准数的元素</span>
</span><span class="code-line line-number" line="15">        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&#x3C;</span> j <span class="token operator">&#x26;&#x26;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&#x3C;=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">)</span>
</span><span class="code-line line-number" line="16">            i<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token comment">// 从左向右找首个大于基准数的元素</span>
</span><span class="code-line line-number" line="17">        <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 交换这两个元素，保证左边小于哨兵，右边大于哨兵,,</span>
</span><span class="code-line line-number" line="18">    <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="19">    <span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> i<span class="token punctuation">,</span> left<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将哨兵交换到重合位置</span>
</span><span class="code-line line-number" line="20">    <span class="token keyword">return</span> i<span class="token punctuation">;</span>             <span class="token comment">// 返回哨兵位置</span>
</span><span class="code-line line-number" line="21"><span class="token punctuation">}</span>
</span><span class="code-line line-number" line="22">
</span><span class="code-line line-number" line="23"><span class="token comment">/* 快速排序 */</span>
</span><span class="code-line line-number" line="24"><span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>vector<span class="token operator">&#x3C;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&#x26;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="25">    <span class="token comment">// 子数组长度为 1 时终止递归</span>
</span><span class="code-line line-number" line="26">    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">>=</span> right<span class="token punctuation">)</span>
</span><span class="code-line line-number" line="27">        <span class="token keyword">return</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="28">    <span class="token comment">// 哨兵划分</span>
</span><span class="code-line line-number" line="29">    <span class="token keyword">int</span> pivot <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="30">    <span class="token comment">// 递归左子数组、右子数组</span>
</span><span class="code-line line-number" line="31">    <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="32">    <span class="token function">quickSort</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="33"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="/* 元素交换 */
void swap(vector<int>&#x26; nums, int i, int j) {
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

/* 哨兵划分 */
int partition(vector<int>&#x26; nums, int left, int right) {
    // 以 nums[left] 作为基准数
    int i = left, j = right;
    while (i < j) {
        while (i < j &#x26;&#x26; nums[j] >= nums[left])
            j--;          // 从右向左找首个小于基准数的元素
        while (i < j &#x26;&#x26; nums[i] <= nums[left])
            i++;          // 从左向右找首个大于基准数的元素
        swap(nums, i, j); // 交换这两个元素，保证左边小于哨兵，右边大于哨兵,,
    }
    swap(nums, i, left);  // 将哨兵交换到重合位置
    return i;             // 返回哨兵位置
}

/* 快速排序 */
void quickSort(vector<int>&#x26; nums, int left, int right) {
    // 子数组长度为 1 时终止递归
    if (left >= right)
        return;
    // 哨兵划分
    int pivot = partition(nums, left, right);
    // 递归左子数组、右子数组
    quickSort(nums, left, pivot - 1);
    quickSort(nums, pivot + 1, right);
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <p>平均时间复杂度：O(nlogn)，平均情况下，哨兵划分的递归层数为logn（基于二分的情况下考虑），每层中的总循环数为n，总体使用O(nlog)。</p>
        <p>最差时间复杂度：O(n^2)，最拆的情况下，哨兵划分操作将长度为n的数组划分为长度为0和n - 1的两个子数组，此时递归的层数达到n层，每层的循环数为n，总体使用O(n^2)。</p>
        <p>空间复杂度：O(n^2)。</p>
        <p>非稳定排序：哨兵划分操作可能改变相等元素的相对位置。</p>
        <h3 id="基准数优化"><a aria-hidden="true" tabindex="-1" href="#基准数优化" class="anchor"><span class="icon icon-link"></span></a>基准数优化</h3>
        <pre><code class="language-c++ code-highlight"><span class="code-line line-number" line="1">/* 选取三个元素的中位数 */
</span><span class="code-line line-number" line="2">int medianThree(vector&#x3C;int>&#x26; nums, int left, int mid, int right) {
</span><span class="code-line line-number" line="3">    // 使用了异或操作来简化代码
</span><span class="code-line line-number" line="4">    // 异或规则为 0 ^ 0 = 1 ^ 1 = 0, 0 ^ 1 = 1 ^ 0 = 1
</span><span class="code-line line-number" line="5">    
</span><span class="code-line line-number" line="6">    // 1 ^ 0 则nums[left]为中位数
</span><span class="code-line line-number" line="7">    if ((nums[left] &#x3C; nums[mid]) ^ (nums[left] &#x3C; nums[right]))
</span><span class="code-line line-number" line="8">        return left;
</span><span class="code-line line-number" line="9">    else if ((nums[mid] &#x3C; nums[left]) ^ (nums[mid] &#x3C; nums[right]))
</span><span class="code-line line-number" line="10">        return mid;
</span><span class="code-line line-number" line="11">    else
</span><span class="code-line line-number" line="12">        return right;
</span><span class="code-line line-number" line="13">}
</span><span class="code-line line-number" line="14">
</span><span class="code-line line-number" line="15">//随机选取基准
</span><span class="code-line line-number" line="16">int SelectPivotRandom(vector&#x3C;int>&#x26; nums, int left, int right){
</span><span class="code-line line-number" line="17">    srand((unsigned)time(NULL)); //保证随机数的不同
</span><span class="code-line line-number" line="18">    int pivotPos = rand() % (right - left) + left;
</span><span class="code-line line-number" line="19">    swap(nums[pivotPos], nums[left]);
</span><span class="code-line line-number" line="20">    return left;
</span><span class="code-line line-number" line="21">}
</span><span class="code-line line-number" line="22">
</span><span class="code-line line-number" line="23">/* 哨兵划分（三数取中值） */
</span><span class="code-line line-number" line="24">int partition(vector&#x3C;int>&#x26; nums, int left, int right) {
</span><span class="code-line line-number" line="25">    // 选取三个候选元素的中位数
</span><span class="code-line line-number" line="26">    int med = medianThree(nums, left, (left + right) / 2, right);
</span><span class="code-line line-number" line="27">    // 将中位数交换至数组最左端
</span><span class="code-line line-number" line="28">    swap(nums, left, med);
</span><span class="code-line line-number" line="29">    // 以 nums[left] 作为基准数
</span><span class="code-line line-number" line="30">    int i = left, j = right;
</span><span class="code-line line-number" line="31">    while (i &#x3C; j) {
</span><span class="code-line line-number" line="32">        while (i &#x3C; j &#x26;&#x26; nums[j] >= nums[left])
</span><span class="code-line line-number" line="33">            j--;          // 从右向左找首个小于基准数的元素
</span><span class="code-line line-number" line="34">        while (i &#x3C; j &#x26;&#x26; nums[i] &#x3C;= nums[left])
</span><span class="code-line line-number" line="35">            i++;          // 从左向右找首个大于基准数的元素
</span><span class="code-line line-number" line="36">        swap(nums, i, j); // 交换这两个元素
</span><span class="code-line line-number" line="37">    }
</span><span class="code-line line-number" line="38">    swap(nums, i, left);  // 将基准数交换至两子数组的分界线
</span><span class="code-line line-number" line="39">    return i;             // 返回基准数的索引
</span><span class="code-line line-number" line="40">}
</span><span class="code-line line-number" line="41">
</span></code><input type="hidden" value="/* 选取三个元素的中位数 */
int medianThree(vector<int>&#x26; nums, int left, int mid, int right) {
    // 使用了异或操作来简化代码
    // 异或规则为 0 ^ 0 = 1 ^ 1 = 0, 0 ^ 1 = 1 ^ 0 = 1
    
    // 1 ^ 0 则nums[left]为中位数
    if ((nums[left] < nums[mid]) ^ (nums[left] < nums[right]))
        return left;
    else if ((nums[mid] < nums[left]) ^ (nums[mid] < nums[right]))
        return mid;
    else
        return right;
}

//随机选取基准
int SelectPivotRandom(vector<int>&#x26; nums, int left, int right){
    srand((unsigned)time(NULL)); //保证随机数的不同
    int pivotPos = rand() % (right - left) + left;
    swap(nums[pivotPos], nums[left]);
    return left;
}

/* 哨兵划分（三数取中值） */
int partition(vector<int>&#x26; nums, int left, int right) {
    // 选取三个候选元素的中位数
    int med = medianThree(nums, left, (left + right) / 2, right);
    // 将中位数交换至数组最左端
    swap(nums, left, med);
    // 以 nums[left] 作为基准数
    int i = left, j = right;
    while (i < j) {
        while (i < j &#x26;&#x26; nums[j] >= nums[left])
            j--;          // 从右向左找首个小于基准数的元素
        while (i < j &#x26;&#x26; nums[i] <= nums[left])
            i++;          // 从左向右找首个大于基准数的元素
        swap(nums, i, j); // 交换这两个元素
    }
    swap(nums, i, left);  // 将基准数交换至两子数组的分界线
    return i;             // 返回基准数的索引
}

"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <p><strong>普通快速排序在某些输入下的时间效率变差</strong>。举个极端例子，假设输入数组是完全倒序的，由于我们选取最左端元素为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，从而 <strong>左子数组长度为 n−1、右子数组长度为 0</strong> 。这样进一步递归下去，<strong>每轮哨兵划分后的右子数组长度都为 0</strong> ，分治策略失效，快速排序退化为「冒泡排序」了。</p>
        <p>为了尽量避免这种情况发生，我们可以优化一下基准数的选取策略。首先，在哨兵划分中，我们可以 <strong>随机选取一个元素作为基准数</strong>。但如果运气很差，每次都选择到比较差的基准数，那么效率依然不好。</p>
        <p>进一步地，我们可以在数组中选取 3 个候选元素（一般为数组的首、尾、中点元素），<strong>并将三个候选元素的中位数作为基准数</strong>，这样基准数“既不大也不小”的概率就大大提升了。当然，如果数组很长的话，我们也可以选取更多候选元素，来进一步提升算法的稳健性。采取该方法后，时间复杂度劣化至 O(n*n) 的概率极低</p>
        <h3 id="为什么要从右开始查找"><a aria-hidden="true" tabindex="-1" href="#为什么要从右开始查找" class="anchor"><span class="icon icon-link"></span></a>为什么要从右开始查找</h3>
        <blockquote>
          <p>快排没有一定要重右边开始，只是看你基数的位置，如果你基数选的是最左边的。你一定要确保，你交换基数的时候，保证那个数要小于基数。</p>
          <p>基数选择了左边，但是还从左边开始，在<code>l &#x3C; r</code>的条件，不能保证交换时<code>num[l] &#x3C; num[povit]</code>。</p>
        </blockquote>
        <h3 id="例题"><a aria-hidden="true" tabindex="-1" href="#例题" class="anchor"><span class="icon icon-link"></span></a>例题</h3>
        <p><a href="https://leetcode.cn/problems/sort-an-array">补充题4. 手撕快速排序</a></p>
        <blockquote>
          <p>除了需要随机选择中间点，还移动了povit相同的值，进一步缩小区别，避免几万个2的情况出现。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/">215. 数组中的第K个最大元素</a></p>
        <p><a href="https://leetcode.cn/problems/sort-colors">75. 颜色分类</a></p>
        <p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/?envType=study-plan&#x26;id=lcof&#x26;plan=lcof&#x26;plan_progress=fi7d972">剑指 Offer 40. 最小的k个数</a></p>
        <blockquote>
          <p>剪枝，哨兵位置在 k 时，可以返回，即前k个小的数都在左边。</p>
          <p>l > k，说明第 k + 1个数在左边序列，前k个数还可能乱，要再排一下；</p>
          <p>l &#x3C; k，说明第 k + 1个数在右边序列，还没有选够k个数，要重新排一下。</p>
        </blockquote>
        <h2 id="归并排序"><a aria-hidden="true" tabindex="-1" href="#归并排序" class="anchor"><span class="icon icon-link"></span></a>归并排序</h2>
        <pre><code class="language-c++ code-highlight"><span class="code-line line-number" line="1">void merge(vector&#x3C;int>&#x26; nums, int left, int mid, int right){
</span><span class="code-line line-number" line="2">    //开辟一段空间保存有序的两段空间，[left, mid],[mid + 1, right]，后续覆盖nums原数组的内容
</span><span class="code-line line-number" line="3">    vector&#x3C;int> tmp = vector&#x3C;int>(nums.begin() + left, nums.begin() + right + 1);
</span><span class="code-line line-number" line="4">    int leftstart = left - left, leftend = mid - left;
</span><span class="code-line line-number" line="5">    int rightstart = mid - left + 1, rightend = right - left;
</span><span class="code-line line-number" line="6">    //应该看已经排序好数的个数，而不是具体下标
</span><span class="code-line line-number" line="7">    int i = leftstart, j = rightstart;
</span><span class="code-line line-number" line="8">    //用两个指针，分别遍历左右子树的内容
</span><span class="code-line line-number" line="9">    for (int k = left; k &#x3C;= right; k++){
</span><span class="code-line line-number" line="10">        //左子树遍历完，选择右子树
</span><span class="code-line line-number" line="11">        if(i > leftend){
</span><span class="code-line line-number" line="12">            nums[k] = tmp[j++];
</span><span class="code-line line-number" line="13">        }
</span><span class="code-line line-number" line="14">        //右子树遍历完，或者tmp[i] &#x3C; tmp[j]，选择左子树
</span><span class="code-line line-number" line="15">        else if(j > rightend || tmp[i] &#x3C;= tmp[j]){
</span><span class="code-line line-number" line="16">            nums[k] = tmp[i++];
</span><span class="code-line line-number" line="17">        }
</span><span class="code-line line-number" line="18">        //tmp[i] > tmp[j]，选择右子树
</span><span class="code-line line-number" line="19">        else{
</span><span class="code-line line-number" line="20">            nums[k] = tmp[j++];
</span><span class="code-line line-number" line="21">        }
</span><span class="code-line line-number" line="22">    }
</span><span class="code-line line-number" line="23">}
</span><span class="code-line line-number" line="24">void mergesort(vector&#x3C;int>&#x26; nums, int left, int right){
</span><span class="code-line line-number" line="25">    if(left >= right){
</span><span class="code-line line-number" line="26">        return;
</span><span class="code-line line-number" line="27">    }
</span><span class="code-line line-number" line="28">
</span><span class="code-line line-number" line="29">    int mid = (left + right) / 2;
</span><span class="code-line line-number" line="30">
</span><span class="code-line line-number" line="31">    mergesort(nums, left, mid);
</span><span class="code-line line-number" line="32">    mergesort(nums, mid + 1, right);
</span><span class="code-line line-number" line="33">
</span><span class="code-line line-number" line="34">    merge(nums, left, mid, right);
</span><span class="code-line line-number" line="35">}
</span></code><input type="hidden" value="void merge(vector<int>&#x26; nums, int left, int mid, int right){
    //开辟一段空间保存有序的两段空间，[left, mid],[mid + 1, right]，后续覆盖nums原数组的内容
    vector<int> tmp = vector<int>(nums.begin() + left, nums.begin() + right + 1);
    int leftstart = left - left, leftend = mid - left;
    int rightstart = mid - left + 1, rightend = right - left;
    //应该看已经排序好数的个数，而不是具体下标
    int i = leftstart, j = rightstart;
    //用两个指针，分别遍历左右子树的内容
    for (int k = left; k <= right; k++){
        //左子树遍历完，选择右子树
        if(i > leftend){
            nums[k] = tmp[j++];
        }
        //右子树遍历完，或者tmp[i] < tmp[j]，选择左子树
        else if(j > rightend || tmp[i] <= tmp[j]){
            nums[k] = tmp[i++];
        }
        //tmp[i] > tmp[j]，选择右子树
        else{
            nums[k] = tmp[j++];
        }
    }
}
void mergesort(vector<int>&#x26; nums, int left, int right){
    if(left >= right){
        return;
    }

    int mid = (left + right) / 2;

    mergesort(nums, left, mid);
    mergesort(nums, mid + 1, right);

    merge(nums, left, mid, right);
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <p>时间复杂度：O(nlogn)，遍历划分高度为logn的递归树，每层合并的总操作数量为 n，总体时间为O(nlogn)。</p>
        <p>空间复杂度：需借助辅助数组实现合并，使用O(n) 大小的额外空间；递归深度为 log⁡n ，使用 O(logn)大小的栈帧空间。</p>
        <p>稳定排序：在合并时可保证相等元素的相对位置不变。</p>
        <p>归并排序有一个很特别的优势，用于排序链表时有很好的性能表现，<strong>空间复杂度可被优化至O(1)</strong> ，这是因为：</p>
        <ul>
          <li>由于链表可仅通过改变指针来实现结点增删，因此“将两个短有序链表合并为一个长有序链表”无需使用额外空间，即回溯合并阶段不用像排序数组一样建立辅助数组 <code>tmp</code> ；</li>
          <li>通过使用「迭代」代替「递归划分」，可省去递归使用的栈帧空间；</li>
        </ul>
        <blockquote>
          <p>某个菜鸡，花费一小时在折腾数组下标问题上，没想到<strong>num[3,4]复制到tmp中对应了tmp[0,1]</strong>。如果直接复制整个nums，数组下标问题确实很好解决了。</p>
          <p>实际左子树就是[0, mid - left]，右子树[mid - left + 1, right - left]，通过长度划分左右子树，联系到前序和后序二叉树建立二叉树的题目上，划分子树。</p>
        </blockquote>
        <h3 id="例题-1"><a aria-hidden="true" tabindex="-1" href="#例题-1" class="anchor"><span class="icon icon-link"></span></a>例题</h3>
        <p><a href="https://leetcode.cn/problems/next-permutation">31. 下一个排列</a></p>
        <p><a href="https://leetcode-cn.com/problems/sort-list/solution/sort-list-gui-bing-pai-xu-lian-biao-by-jyd/">148. 排序链表</a></p>
        <h2 id="希尔排序"><a aria-hidden="true" tabindex="-1" href="#希尔排序" class="anchor"><span class="icon icon-link"></span></a>希尔排序</h2>
        <p>略略略。</p>
        <h2 id="拓扑排序"><a aria-hidden="true" tabindex="-1" href="#拓扑排序" class="anchor"><span class="icon icon-link"></span></a>拓扑排序</h2>
        <p><a href="https://leetcode.cn/problems/course-schedule">207. 课程表</a></p>
        <blockquote>
          <p>首先将入度为0（也就是没有先修课程的，肯定可以学）入队，然后不断弹出这些课（学了），找需要先修这门课的，如果这门课入度为0了（先修课修完了），入队。</p>
          <p>最后判断学完的所有数量和当前的numCourses是否相等即可。</p>
          <p>时间复杂度：<code>O(E+V)</code>。这里 E 表示邻边的条数，V 表示结点的个数。</p>
        </blockquote>
        <h2 id="堆排序"><a aria-hidden="true" tabindex="-1" href="#堆排序" class="anchor"><span class="icon icon-link"></span></a>堆排序</h2>
        <h2 id="其他"><a aria-hidden="true" tabindex="-1" href="#其他" class="anchor"><span class="icon icon-link"></span></a>其他</h2>
        <p><a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/?envType=study-plan&#x26;id=lcof&#x26;plan=lcof&#x26;plan_progress=fi7d972">面试题61. 扑克牌中的顺子</a></p>
        <blockquote>
          <p>倒不如说是数学思路题了，满足顺子的条件，列出大小王的情况去做。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/?envType=study-plan&#x26;id=lcof&#x26;plan=lcof&#x26;plan_progress=fi7d972">面试题45. 把数组排成最小的数</a></p>
        <blockquote>
          <p>想不到，通过a + b > b + a，来判断摆放的顺序。</p>
        </blockquote>
      </markdown-style>
      <nav class="tocs">
        <aside class="inner toc">
          <ol class="tocs-list">
            <li><a href="#冒泡排序" class="tocs-link">冒泡排序</a></li>
            <li><a href="#选择排序" class="tocs-link">选择排序</a></li>
            <li><a href="#插入排序" class="tocs-link">插入排序</a></li>
            <li><a href="#快速排序" class="tocs-link">快速排序</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#基础版" class="tocs-link">基础版</a></li>
                <li><a href="#基准数优化" class="tocs-link">基准数优化</a></li>
                <li><a href="#为什么要从右开始查找" class="tocs-link">为什么要从右开始查找</a></li>
                <li><a href="#例题" class="tocs-link">例题</a></li>
              </ol>
            </li>
            <li><a href="#归并排序" class="tocs-link">归并排序</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#例题-1" class="tocs-link">例题</a></li>
              </ol>
            </li>
            <li><a href="#希尔排序" class="tocs-link">希尔排序</a></li>
            <li><a href="#拓扑排序" class="tocs-link">拓扑排序</a></li>
            <li><a href="#堆排序" class="tocs-link">堆排序</a></li>
            <li><a href="#其他" class="tocs-link">其他</a></li>
          </ol>
        </aside>
      </nav>
    </div>
    <script src="../js/demo-preview.js?v=1.21.13"></script>
    <div class="footer warpper">Created by <a href="https://github.com/shixiaocaia" target="_blank">shixiaocaia</a> | Powered by <a href="https://github.com/jaywcjlove/idoc" target="_blank">idoc</a><br>Think less and do more.</div>
    <script src="../js/tocbot.js?v=1.21.13"></script>
  </body>
</html>
