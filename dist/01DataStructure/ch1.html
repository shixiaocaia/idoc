<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数组 iDoc</title>
    <meta name="description" content="在一个有序数组中查找某一个数或者位置可以考虑二分">
    <meta name="keywords" content="notebook">
    <link rel="stylesheet" type="text/css" href="../css/main.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/tocbot.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/media.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/sidebar.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/copy.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/fancybox.css?v=1.25.0">
    <link rel="icon" href="../logo.png" type="image/x-icon">
    <script src="../js/copy.js?v=1.25.0"></script>
    <script src="../js/dark-mode.js?v=1.25.0"></script>
    <script src="../js/markdown-style.js?v=1.25.0"></script>
    <script src="../js/jquery.min.js?v=1.25.0"></script>
    <script src="../js/fancybox.umd.js?v=1.25.0"></script>
  </head>
  <body><button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
    <script>
// Get the button:
let mybutton = document.getElementById("myBtn");
// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};
// 顶部隐藏，底部隐藏
function scrollFunction() {
if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
mybutton.style.display = "block";
} else {
mybutton.style.display = "none";
}
}
// When the user clicks on the button, scroll to the top of the document
function topFunction() {
document.body.scrollTop = 0; // For Safari
document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
}
</script>
    <header class="header">
      <article class="inner warpper"><a class="logo" href="../index.html"><img alt="iDoc logo" src="../logo.png">
<span class="title">iDoc</span></a>
        <div class="content">
          <ul class="menu">
            <li><a href="../index.html" target="" class="">Home</a></li>
            <li><a href="../00Go/index.html" target="" class="">Go</a></li>
            <li><a href="index.html" target="" class="active">DataStructure</a></li>
            <li><a href="../01ComputerNetwork/index.html" target="" class="">ComputerNetwrok</a></li>
            <li><a href="../01DataBase/index.html" target="" class="">DataBase</a></li>
            <li><a href="../01OperatingSystem/index.html" target="" class="">OperatingSystem</a></li>
            <li><a href="../03Other/index.html" target="" class="">Other</a></li>
          </ul><a href="https://github.com/shixiaocaia" target="_blank" rel="noopener noreferrer" title="Github" name="Github" class="github"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg></a>
          <dark-mode permanent=""></dark-mode>
        </div>
      </article>
    </header>
    <div class="warpper-content warpper sidebar">
      <div class="sidebar-border">
        <aside class="sidebar" role="navigation">
          <div>
            <a href="index.html" class="">↩️README</a>
            <label>Leetcode</label>
            <a href="ch1.html" class="">数组</a>
            <a href="ch2.html" class="">链表</a>
            <a href="ch3.html" class="">哈希表</a>
            <a href="ch4.html" class="">字符串</a>
            <a href="ch5.html" class="">栈与队列</a>
            <a href="ch6.html" class="">二叉树</a>
            <a href="ch7.html" class="">回溯</a>
            <a href="ch8.html" class="">贪心</a>
            <a href="ch9.html" class="">动态规划</a>
            <a href="ch11.html" class="">排序</a>
            <a href="ch12.html" class="">图论</a>
            <a href="ch13.html" class="">其他</a>
          </div>
        </aside>
      </div>
      <markdown-style>
        <h1 id="数组"><a aria-hidden="true" tabindex="-1" href="#数组" class="anchor"><span class="icon icon-link"></span></a>数组</h1>
        <h2 id="二分查找"><a aria-hidden="true" tabindex="-1" href="#二分查找" class="anchor"><span class="icon icon-link"></span></a>二分查找</h2>
        <p>在一个<strong>有序</strong>数组中查找某一个数或者位置可以考虑二分</p>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2"><span class="token keyword">public</span><span class="token operator">:</span>
</span><span class="code-line line-number" line="3">    <span class="token keyword">int</span> <span class="token function">search</span><span class="token punctuation">(</span>vector<span class="token operator">&#x3C;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&#x26;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="4">        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="5">        <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="6"><span class="token comment">// 右区间为闭区间，下标从size-1开始</span>
</span><span class="code-line line-number" line="7">        
</span><span class="code-line line-number" line="8">        <span class="token keyword">while</span><span class="token punctuation">(</span>left <span class="token operator">&#x3C;=</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>
</span><span class="code-line line-number" line="9">            <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment">// 防止溢出 等同于(left + right)/2</span>
</span><span class="code-line line-number" line="10">            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span>
</span><span class="code-line line-number" line="11">                right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="12">            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&#x3C;</span> target<span class="token punctuation">)</span>
</span><span class="code-line line-number" line="13">                left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="14">            <span class="token keyword">else</span> <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="15">        <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="16">        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="17">    <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="18"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span></code><input type="hidden" value="class Solution {
public:
    int search(vector<int>&#x26; nums, int target) {
        int left = 0;
        int right = nums.size()-1;
// 右区间为闭区间，下标从size-1开始
        
        while(left <= right){
            int mid = left + (right - left) / 2;// 防止溢出 等同于(left + right)/2
            if(nums[mid] > target)
                right = mid - 1;
            else if(nums[mid] < target)
                left = mid + 1;
            else return mid;
        }
        return -1;
    }
};
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <ul>
          <li>这里防止溢出是指，当left和right同为int较大型数据时候，(left+right)容易溢出，而left + (right - left) / 2，相等价也避免了溢出的问题。</li>
          <li>二分的时间复杂度：O(log n)</li>
        </ul>
        <h3 id="例题"><a aria-hidden="true" tabindex="-1" href="#例题" class="anchor"><span class="icon icon-link"></span></a>例题</h3>
        <p><a href="https://leetcode.cn/problems/search-insert-position/">LC35.搜索插入位置</a></p>
        <blockquote>
          <ol>
            <li>数组中找到，返回序号</li>
            <li>数组中插入，最终left==right时，若nums[right]&#x3C;target, 那么left=left+1（也等价于right+1,因为二者重合了，数值相同），若nums[left] > target, 那么right=right -1但是实际插入位置应该就在此处，因此为right+1，两种比值可以更新为一种right+1。</li>
            <li>越界插入，如果小于所有数，在头部插入，最后更新为[0,-1], 实际插入为left或者right+1。如果大于所有数，在尾部插入，最后更新为[nums.size()+1,num.size()],实际插入为left或者right+1。</li>
          </ol>
          <p>总结：最后如果没有找到这个数，最终都可以归纳为right+1情况。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">LC34.在排序数组中查找元素的第一个和最后一个位置</a></p>
        <blockquote>
          <p>本题卡了我很久一个点：<strong>数组越界访问问题</strong>，剪枝判断应该先判断越界问题再判断大小，否则会出现数组的越界访问。</p>
          <p>三刷，合并左右遍历问题</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">33. 搜索旋转排序数组</a></p>
        <blockquote>
          <p>找到原数组的left值，对<code>[left, nums.size() - 1 + left]</code>进行二分，再通过取余对应旋转后数组的下标数值。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/find-the-duplicate-number">287. 寻找重复数</a></strong></p>
        <blockquote>
          <p>抽屉原理，把十个苹果放在九个抽屉里，肯定有个抽屉放多了一个。</p>
          <p>这样我们遍历[1,n]，如果[0,mid]区间内小于mid的数大于mid，那么肯定在[0,mid]这个区间内容有重复的数。</p>
          <p>时间复杂度：<em>O</em>(<em>N</em>log<em>N</em>)，在二分里面嵌套了一个for循环。</p>
          <p>空间复杂度：O(1)，使用了一个 cnt 变量，因此空间复杂度为 O(1)。</p>
          <p>双指针做法。</p>
        </blockquote>
        <h2 id="双指针"><a aria-hidden="true" tabindex="-1" href="#双指针" class="anchor"><span class="icon icon-link"></span></a>双指针</h2>
        <blockquote>
          <p>双指针主要分为两类：左右指针和快慢指针。</p>
          <p>左右指针：两个指针相向而行或者向背而行</p>
          <p>快慢指针：两个指针同向而行，一快一慢。</p>
          <p>双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了。</p>
          <p>多个指针，指向不同的下标，满足条件时移动对应的一个指针，指针用于划分数组部分。</p>
        </blockquote>
        <h3 id="同向双指针"><a aria-hidden="true" tabindex="-1" href="#同向双指针" class="anchor"><span class="icon icon-link"></span></a>同向双指针</h3>
        <p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/submissions/">209.长度最小的子数组</a></p>
        <p><strong><a href="https://leetcode.cn/problems/subarray-product-less-than-k/description/">713. 乘积小于 K 的子数组</a></strong></p>
        <blockquote>
          <p>209是不满足条件变化，713不满足条件时变，有一定的相关性。</p>
          <p>713自己第一遍没写出来，没有想到以r为右边界时，符合区间个数，停留在209区间长度的思路上。</p>
          <p>当[l, r]满足时，[l + 1,r]...[r, r]都是满足，即这一段的长度。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/max-consecutive-ones-iii/">1004. 最大连续 1 的个数 III</a></p>
        <p><a href="https://leetcode.cn/problems/replace-the-substring-for-balanced-string/">1234. 替换子串得到平衡字符串</a></p>
        <p><a href="https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/">1658. 将 x 减到 0 的最小操作数</a></p>
        <h3 id="相向双指针"><a aria-hidden="true" tabindex="-1" href="#相向双指针" class="anchor"><span class="icon icon-link"></span></a>相向双指针</h3>
        <p><a href="https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/description/">167. 两数之和 II - 输入有序数组</a></p>
        <blockquote>
          <p>二分、双指针，相向而行。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/3sum/">15.三树之和</a></p>
        <h3 id="例题-1"><a aria-hidden="true" tabindex="-1" href="#例题-1" class="anchor"><span class="icon icon-link"></span></a>例题</h3>
        <p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/">LC26. 删除有序数组中的重复项</a></p>
        <p><a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-list/description/">LC83. 删除排序链表中的重复元素</a></p>
        <p><a href="https://leetcode.cn/problems/move-zeroes/">LC283.移动零</a></p>
        <p><a href="https://leetcode.cn/problems/backspace-string-compare/">LC844.比较含退格的字符串</a></p>
        <blockquote>
          <p>
            第一种用栈暴力做
            第二种是，明白#字符只针对前一个字符进行退格基础上，那我们便可以后续遍历这两个数组，确定一个不会移动的字符时，进行比较。
          </p>
          <p>当序列都在边界范围时进行比较，else的时候分为三种情况，最后合并为一种，这里比较复杂一点。</p>
          <p>🆙二刷：思考的顺序，从前还是从后处理的顺序。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/squares-of-a-sorted-array/">LC977.有序数组的平方</a></p>
        <blockquote>
          <p>使用双向指针，由于原数组按照非递减排序，那么平方后的数，应该在两头，通过双向指针指向头和尾，进行比较大小移动。</p>
          <p>每次比较左边和右边哪个数更大，更新左右边界，用一个k记录ans数组的位置。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/merge-intervals">56. 合并区间</a></p>
        <blockquote>
          <p>以左边界排序，排序后的数组左边界肯定在右侧。</p>
          <p>维护一个区间l，r，当下一个区间的左边界超过当前区间的右侧，那么就要存入档案，以及更新区间。否则的话只需要更新右区间。</p>
          <p>最后不能忘记最后一组区间需要手动存入。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/sort-colors">75. 颜色分类</a></p>
        <blockquote>
          <p>刷油漆战略。</p>
          <p>由于num &#x3C;= 2，我们线全部刷成2，如果小于等于1，刷一个1（有一个错误的2刷成了1），如果小于0，刷一个0（纠正了一个错误1），分别用两个指针指向0，1的起始位置。</p>
        </blockquote>
        <p><strong>其他章节双指针思路题</strong></p>
        <blockquote>
          <p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">LC19.删除链表的倒数第N个节点</a></p>
        </blockquote>
        <h2 id="滑动窗口"><a aria-hidden="true" tabindex="-1" href="#滑动窗口" class="anchor"><span class="icon icon-link"></span></a>滑动窗口</h2>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2"><span class="token keyword">public</span><span class="token operator">:</span>
</span><span class="code-line line-number" line="3">    <span class="token keyword">int</span> <span class="token function">minSubArrayLen</span><span class="token punctuation">(</span><span class="token keyword">int</span> target<span class="token punctuation">,</span> vector<span class="token operator">&#x3C;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&#x26;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="4">        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="5">        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="6">        <span class="token keyword">int</span> minlen <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="7">
</span><span class="code-line line-number" line="8">        <span class="token keyword">for</span> <span class="token punctuation">(</span>right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> right <span class="token operator">&#x3C;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> right<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="9">            sum <span class="token operator">+=</span> nums<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//字串和</span>
</span><span class="code-line line-number" line="10">            <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&#x3C;=</span> right <span class="token operator">&#x26;&#x26;</span> sum <span class="token operator">>=</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//更新答案和起始位置</span>
</span><span class="code-line line-number" line="11">                minlen <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>minlen<span class="token punctuation">,</span> right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="12">                sum <span class="token operator">-=</span> nums<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="13">            <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="14">        <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="15">
</span><span class="code-line line-number" line="16">        <span class="token keyword">return</span> minlen <span class="token operator">==</span> INT_MAX <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> minlen<span class="token punctuation">;</span> <span class="token comment">//判断有没有找到合适的子串</span>
</span><span class="code-line line-number" line="17">    <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="18"><span class="token punctuation">}</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="19">
</span></code><input type="hidden" value="class Solution {
public:
    int minSubArrayLen(int target, vector<int>&#x26; nums) {
        int left = 0, right;
        int sum = 0;
        int minlen = INT_MAX;

        for (right = 0; right < nums.size(); right++) {
            sum += nums[right]; //字串和
            while (left <= right &#x26;&#x26; sum >= target) { //更新答案和起始位置
                minlen = min(minlen, right - left + 1);
                sum -= nums[left++];
            }
        }

        return minlen == INT_MAX ? 0 : minlen; //判断有没有找到合适的子串
    }
};

"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1">最小滑窗模板：给定数组 nums，定义滑窗的左右边界 i<span class="token punctuation">,</span> j，求满足某个条件的滑窗的最小长度。
</span><span class="code-line line-number" line="2"><span class="token keyword">while</span> j <span class="token operator">&#x3C;</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">:</span>
</span><span class="code-line line-number" line="3">    判断<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span>是否满足条件
</span><span class="code-line line-number" line="4">    <span class="token keyword">while</span> 满足条件：
</span><span class="code-line line-number" line="5">        不断更新结果<span class="token punctuation">(</span>注意在<span class="token keyword">while</span>内更新！<span class="token punctuation">)</span>
</span><span class="code-line line-number" line="6">        i <span class="token operator">+=</span> <span class="token number">1</span> （最大程度的压缩i，使得滑窗尽可能的小）
</span><span class="code-line line-number" line="7">    j <span class="token operator">+=</span> <span class="token number">1</span>
</span><span class="code-line line-number" line="8">        
</span><span class="code-line line-number" line="9">最大滑窗模板：给定数组 nums，定义滑窗的左右边界 i<span class="token punctuation">,</span> j，求满足某个条件的滑窗的最大长度。
</span><span class="code-line line-number" line="10"><span class="token keyword">while</span> j <span class="token operator">&#x3C;</span> <span class="token function">len</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token operator">:</span>
</span><span class="code-line line-number" line="11">    判断<span class="token punctuation">[</span>i<span class="token punctuation">,</span> j<span class="token punctuation">]</span>是否满足条件
</span><span class="code-line line-number" line="12">    <span class="token keyword">while</span> 不满足条件：
</span><span class="code-line line-number" line="13">        i <span class="token operator">+=</span> <span class="token number">1</span> （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）
</span><span class="code-line line-number" line="14">    不断更新结果（注意在<span class="token keyword">while</span>外更新！）
</span><span class="code-line line-number" line="15">    j <span class="token operator">+=</span> <span class="token number">1</span>
</span></code><input type="hidden" value="最小滑窗模板：给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最小长度。
while j < len(nums):
    判断[i, j]是否满足条件
    while 满足条件：
        不断更新结果(注意在while内更新！)
        i += 1 （最大程度的压缩i，使得滑窗尽可能的小）
    j += 1
        
最大滑窗模板：给定数组 nums，定义滑窗的左右边界 i, j，求满足某个条件的滑窗的最大长度。
while j < len(nums):
    判断[i, j]是否满足条件
    while 不满足条件：
        i += 1 （最保守的压缩i，一旦满足条件了就退出压缩i的过程，使得滑窗尽可能的大）
    不断更新结果（注意在while外更新！）
    j += 1
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <h3 id="例题-2"><a aria-hidden="true" tabindex="-1" href="#例题-2" class="anchor"><span class="icon icon-link"></span></a>例题</h3>
        <p><a href="https://leetcode.cn/problems/minimum-size-subarray-sum/">LC209.最小子串长度</a></p>
        <blockquote>
          <p>本题可以用前缀和+二分做，通过s[j]-s[i] >= target,可以变化为 s[j] >= s[i]+target。在s数组中寻找第一个大于 s[i]+target位置，进行更新大小，使用了C++ lower_bound()函数</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/fruit-into-baskets/">LC904.水果篮子</a></strong></p>
        <blockquote>
          <p>大佬的滑动窗口思路，我不断地把水果放到篮子中，当水果种类大于2种时，进行更新篮子中水果种类，最后更新result。</p>
          <p>这里的更新篮子思路是：从左边界left开始更新，将这个序号下的水果数-1，当移动到删除完这个水果数为0时，此时水果种类-1，加上前面右边界更新的一个新的，刚好为2种，继续更新答案。</p>
          <p>🆙二刷没做出来，没想到用map来映射这是第几种水果，如果遇到0的说明是新的一种，如果水果种树大于2时，更新左边界，而答案是时时更新的。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/minimum-window-substring/">LC76.最小覆盖字串</a></p>
        <blockquote>
          <p>自己做的时候，忽略了字符串重复出现问题。以及在移动左边界上欠缺考虑，看题解使用的方法是在左边的字符数量已经在后面出现次数大于了所需数量，再去更新右边界。</p>
          <p>难点：字串问题划分为最大和最小，<strong>边界更新时机很重要</strong>。</p>
          <ol>
            <li>维护两个哈希表，一个hs，一个ht。</li>
            <li>定义两个指针，左指针j，右指针i，维护一个窗口[i, j]。</li>
            <li>每向右一步，把s[i] 加入hs当中，hs[s[i]] ++。</li>
            <li>对于新加入的s[i], 如果<code>hs[s[i]] &#x3C;= ht[s[i]]</code>，说明是必要的，且没超过需求的字符数量，用一个cnt记录一共需要多少个。</li>
            <li>当hs[s[j]] > ht[s[j]时，说明hs哈希表中s[j]的数量多于ht哈希表中s[j]的数量，此时我们就需要向右收缩滑动窗口，j++并使hs[s[j]]--，即hs[s[j ++ ]] --。每次更新保证这个字符数量是复合要求的，所以不更新cnt的大小。</li>
            <li>当<code>cnt == t.size</code>时，说明此时滑动窗口包含符串 <code>t</code> 的全部字符。我们重复上述过程找到最小窗口即为答案。</li>
            <li>更新答案时候保证这是复合字符串t长度的。</li>
          </ol>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string">LC438.找到字符串中所有字母异位词</a></strong></p>
        <blockquote>
          <p>注意如果p长度大于s，那么一定没有结果，直接返回。</p>
          <p>然后记录p数组的字母构成数量。维护一个滑动窗口。当前的字母数量小于0维护左边界。最好当前窗口长度等于p长度时，记录左边界。</p>
          <p><strong>左边界一定是满足p子串的开始，不会有浪费。</strong></p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">LC3.无重复字符的最长子串</a></p>
        <blockquote>
          <p>滑动窗口，当出现重现字符时，更新左边界，如果没有重复出现就更新答案。</p>
          <p>双指针 + 哈希表。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/?envType=study-plan&#x26;id=lcof&#x26;plan=lcof&#x26;plan_progress=fi7d972">剑指 Offer 57 - II. 和为s的连续正数序列</a></p>
        <h2 id="前缀和"><a aria-hidden="true" tabindex="-1" href="#前缀和" class="anchor"><span class="icon icon-link"></span></a>前缀和</h2>
        <p>前缀和主要适用的场景是原始数组不会被修改的情况下，频繁查询某个区间的累加和。</p>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">int</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="3">    <span class="token comment">// 构造前缀和</span>
</span><span class="code-line line-number" line="4">    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sum <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="5">    sum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 
</span><span class="code-line line-number" line="6">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
</span><span class="code-line line-number" line="7">        sum<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="8">    
</span><span class="code-line line-number" line="9">    <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="10">    <span class="token comment">// 穷举所有子数组</span>
</span><span class="code-line line-number" line="11">    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&#x3C;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
</span><span class="code-line line-number" line="12">        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&#x3C;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
</span><span class="code-line line-number" line="13">            <span class="token comment">// sum of nums[j..i-1]</span>
</span><span class="code-line line-number" line="14">            <span class="token keyword">if</span> <span class="token punctuation">(</span>sum<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> sum<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> k<span class="token punctuation">)</span>
</span><span class="code-line line-number" line="15">                ans<span class="token operator">++</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="16"> 
</span><span class="code-line line-number" line="17">    <span class="token keyword">return</span> ans<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="18"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="int subarraySum(int[] nums, int k) {
    int n = nums.length;
    // 构造前缀和
    int[] sum = new int[n + 1];
    sum[0] = 0; 
    for (int i = 0; i < n; i++)
        sum[i + 1] = sum[i] + nums[i];
    
    int ans = 0;
    // 穷举所有子数组
    for (int i = 1; i <= n; i++)
        for (int j = 0; j < i; j++)
            // sum of nums[j..i-1]
            if (sum[i] - sum[j] == k)
                ans++;
 
    return ans;
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <p><a href="https://leetcode.cn/problems/subarray-sum-equals-k">560. 和为K的子数组</a></p>
        <p>直接的前缀和TL，O(n^2)。</p>
        <p>
          <img src="http://pic.shixiaocaia.fun/202302131920381.png" alt=" ">
        </p>
        <h2 id="差分"><a aria-hidden="true" tabindex="-1" href="#差分" class="anchor"><span class="icon icon-link"></span></a>差分</h2>
        <p>差分数组的主要适用场景是频繁对原始数组的某个区间的元素进行增减。</p>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1">diff<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> num<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="2">
</span><span class="code-line line-number" line="3">diff<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> k<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="4">diff<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> k<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="5">
</span><span class="code-line line-number" line="6">num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="7">num<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> diff<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//diff[i] + k,导致num[i] + k,后面都加了k</span>
</span><span class="code-line line-number" line="8">
</span><span class="code-line line-number" line="9"><span class="token comment">//对diff[j + 1] - k,后面的num[j + 1] - k和前面的+ k抵消。</span>
</span></code><input type="hidden" value="diff[i] = num[i] - num[i - 1];

diff[i] += k;
diff[j] -= k;

num[i] = num[i - 1] + diff[i];
num[i + 1] = num[i] + diff[i + 1]; //diff[i] + k,导致num[i] + k,后面都加了k

//对diff[j + 1] - k,后面的num[j + 1] - k和前面的+ k抵消。
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <p><a href="https://leetcode.cn/problems/corporate-flight-bookings">1109. 航班预订统计</a></p>
        <p><a href="https://leetcode.cn/problems/path-sum-iii">437. 路径总和 III</a></p>
        <blockquote>
          <p>计算一个路径下结点值之和为sum，转化为两个节点的前缀和差值为sum，即中间这个路径的值为sum。</p>
          <p>记得初始化，umap[0] = 1,这边如何理解呢？子节点到根节点前缀和pre 刚好等于 target这种情况</p>
          <p>这边有个状态恢复，是因为加入当前的前缀和信息，只能针对它后续的子节点，比如左子树上的前缀和，不能影响另一侧的右子树上的前缀和（题目要求路径是向下的）。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/?envType=study-plan&#x26;id=lcof&#x26;plan=lcof&#x26;plan_progress=fi7d972">剑指 Offer 66. 构建乘积数组</a></p>
        <h2 id="模拟"><a aria-hidden="true" tabindex="-1" href="#模拟" class="anchor"><span class="icon icon-link"></span></a>模拟</h2>
        <p><a href="https://leetcode.cn/problems/spiral-matrix-ii/">LC59.螺旋矩阵2</a></p>
        <p><a href="https://leetcode.cn/problems/spiral-matrix/">LC54.螺旋矩阵1</a></p>
        <p><a href="https://leetcode.cn/problems/robot-bounded-in-circle/description/">1041.困于环中的机器人</a></p>
        <blockquote>
          <p>通过计算四次操作距离，比较南北距离以及东西距离是否相等来判断能否回到原点。</p>
          <p>如果一次操作后，指向北方，说明会一直往一个方向递增。</p>
          <p>如果指向南方，再经过一次必然会反向回到原文。</p>
          <p>如果指向东西方，最多需要四次回到原处。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/degree-of-an-array/">697.数组的度</a></p>
        <p><a href="https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/">448. 找到所有数组中消失的数字</a></p>
      </markdown-style>
      <nav class="tocs">
        <aside class="inner toc">
          <ol class="tocs-list">
            <li><a href="#二分查找" class="tocs-link">二分查找</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#例题" class="tocs-link">例题</a></li>
              </ol>
            </li>
            <li><a href="#双指针" class="tocs-link">双指针</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#同向双指针" class="tocs-link">同向双指针</a></li>
                <li><a href="#相向双指针" class="tocs-link">相向双指针</a></li>
                <li><a href="#例题-1" class="tocs-link">例题</a></li>
              </ol>
            </li>
            <li><a href="#滑动窗口" class="tocs-link">滑动窗口</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#例题-2" class="tocs-link">例题</a></li>
              </ol>
            </li>
            <li><a href="#前缀和" class="tocs-link">前缀和</a></li>
            <li><a href="#差分" class="tocs-link">差分</a></li>
            <li><a href="#模拟" class="tocs-link">模拟</a></li>
          </ol>
        </aside>
      </nav>
    </div>
    <script src="../js/demo-preview.js?v=1.25.0"></script>
    <div class="footer warpper">Created by <a href="https://github.com/shixiaocaia" target="_blank">shixiaocaia</a> | Powered by <a href="https://github.com/jaywcjlove/idoc" target="_blank">idoc</a><br>Think less and do more.</div>
    <script src="../js/tocbot.js?v=1.25.0"></script>
  </body>
</html>
