<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>链表 iDoc</title>
    <meta name="description" content="一般回溯算法的返回值为void，参数根据需要填写。">
    <meta name="keywords" content="notebook">
    <link rel="stylesheet" type="text/css" href="../css/main.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/tocbot.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/media.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/sidebar.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/copy.css?v=1.21.13">
    <link rel="stylesheet" type="text/css" href="../css/demo-preview.css?v=1.21.13">
    <link rel="icon" href="../logo.png" type="image/x-icon">
    <script src="../js/copy.js?v=1.21.13"></script>
    <script src="../js/dark-mode.js?v=1.21.13"></script>
    <script src="../js/markdown-style.js?v=1.21.13"></script>
  </head>
  <body id="idoctotop"><a href="#idoctotop" class="gototop">top</a>
    <header class="header">
      <article class="inner warpper"><a class="logo" href="../index.html"><img alt="iDoc logo" src="../logo.png">
<span class="title">iDoc</span></a>
        <div class="content">
          <ul class="menu">
            <li><a href="../index.html" target="" class="">Home</a></li>
            <li><a href="../00CPP/index.html" target="" class="">Cpp</a></li>
            <li><a href="index.html" target="" class="active">DataStructure</a></li>
            <li><a href="../01OperatingSystem/index.html" target="" class="">OperatingSystem</a></li>
            <li><a href="../01ComputerNetwork/index.html" target="" class="">ComputerNetwrok</a></li>
            <li><a href="../01DataBase/index.html" target="" class="">DataBase</a></li>
            <li><a href="../02MyWeb/index.html" target="" class="">Webserver</a></li>
            <li><a href="../00Other/index.html" target="" class="">Other</a></li>
          </ul><a href="https://github.com/shixiaocaia" target="_blank" rel="noopener noreferrer" title="Github" name="Github" class="github"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg></a>
          <dark-mode permanent=""></dark-mode>
        </div>
      </article>
    </header>
    <div class="warpper-content warpper sidebar">
      <div class="sidebar-border">
        <aside class="sidebar" role="navigation">
          <div>
            <a href="index.html" class="">README</a>
            <label>Leetcode</label>
            <a href="ch1.html" class="">数组</a>
            <a href="ch2.html" class="">链表</a>
            <a href="ch3.html" class="">哈希表</a>
            <a href="ch4.html" class="">字符串</a>
            <a href="ch5.html" class="">栈与队列</a>
            <a href="ch6.html" class="">二叉树</a>
            <a href="ch7.html" class="">回溯</a>
            <a href="ch8.html" class="">贪心</a>
            <a href="ch9.html" class="">动态规划</a>
            <a href="ch10.html" class="">单调栈</a>
            <a href="ch11.html" class="">排序</a>
            <a href="ch12.html" class="">其他</a>
          </div>
        </aside>
      </div>
      <markdown-style>
        <h2 id="回溯"><a aria-hidden="true" tabindex="-1" href="#回溯" class="anchor"><span class="icon icon-link"></span></a>回溯</h2>
        <p><strong>确认函数模板返回值以及参数</strong></p>
        <p>一般回溯算法的返回值为void，参数根据需要填写。</p>
        <p><strong>回溯函数终止条件</strong></p>
        <p>找到能满足答案情况时，存放答案，并结束本层的递归。</p>
        <p><strong>回溯搜索的遍历过程</strong></p>
        <pre class="language-cpp"><code class="language-cpp code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>XXX<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
</span><span class="code-line line-number" line="3">        加入答案；
</span><span class="code-line line-number" line="4">        <span class="token keyword">return</span><span class="token punctuation">;</span>
</span><span class="code-line line-number" line="5">    <span class="token punctuation">}</span>
</span><span class="code-line line-number" line="6">    
</span><span class="code-line line-number" line="7">    <span class="token keyword">for</span> <span class="token punctuation">(</span>选择：本层集合中元素（树中节点孩子的数量就是集合的大小）<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="code-line line-number" line="8">        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> 去重<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="9">        处理节点<span class="token punctuation">;</span>
</span><span class="code-line line-number" line="10">        <span class="token function">backtracking</span><span class="token punctuation">(</span>路径，选择列表<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 递归</span>
</span><span class="code-line line-number" line="11">        回溯，撤销处理结果
</span><span class="code-line line-number" line="12">    <span class="token punctuation">}</span>    
</span><span class="code-line line-number" line="13"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="void dfs(XXX, int index){
    if(){
        加入答案；
        return;
    }
    
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        if(...) 去重;
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }    
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <h2 id="例题"><a aria-hidden="true" tabindex="-1" href="#例题" class="anchor"><span class="icon icon-link"></span></a>例题</h2>
        <p><strong><a href="https://leetcode.cn/problems/combinations/">LC77. 组合</a></strong></p>
        <blockquote>
          <p>在本科竞赛时，经常暴力写到的DFS，BFS，其本质也是递归。参数包括本身的n，k，再增加一个起始坐标，标记前面已经使用的数字，间接去重。终止条件是已经找到k个数，通过数组的长度判断。遍历过程就是不断放入一个数，继续递归下一个树，然后回退这个数。</p>
          <p>剪枝：当起始位置开始可以选的数数量小于所需的时候，跳出。</p>
          <p>当前已选的数：path.size()</p>
          <p>剩余可选的数：n - startindex + 1</p>
          <p>还需要选的数：k - path.size()</p>
          <p>所以开始的位置必须 k - path.size() >= n - startindex + 1 即startindex >= n - k + path.size() + 1</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/combination-sum-iii/">216. 组合总和 III</a></strong></p>
        <blockquote>
          <p>DFS模板题，剪枝也和上一题思路差不多</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></strong></p>
        <blockquote>
          <p>题解思路，用一个字符串常量 ，映射每个字符串组，再将每个字符</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></strong></p>
        <blockquote>
          <p>在写这题的时候，纠结出现重复的情况，实际上就是下一个寻址的起始位置，仍然包含本身，可以重复拿。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/combination-sum-ii/">🆙40. 组合总和 II</a></strong></p>
        <blockquote>
          <p>对比上题，这题每个数只能使用一次了，但不是这么简单。</p>
          <p>要考虑数字重复出现，有两个 1 的情况下， 1 + 1 + 6 = 8 也是可以的。</p>
          <p>因此本题的重点在于去重，一开始我考虑了candidates[i] == candidates[i - 1] ，如果这个数和上次放入一样跳过，那么1 1 6就会被排除，看了题解一句话，我们要去重的是同层的遍历相同的数字情况，比如，我 1 2（第一个2）遍历，和 1 2（第二个2）开始遍历，就是重复的，但是1 2 2这种是可以的，因此要加一个判断当前位置是不是新的一层的开头。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/palindrome-partitioning/">🆙131. 分割回文串</a></strong></p>
        <blockquote>
          <p>分割字符串，如果当前子串是回文串就进行下一层遍历，否则继续截取更长的子串长度。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/restore-ip-addresses/">🆙93. 复原 IP 地址</a></strong></p>
        <blockquote>
          <p>stoi( )函数，头文件：#include
            <cstring> 把数字字符串转换成int输出。</cstring>
          </p>
          <p>字串截取，每次处理完，也把s截取为处理完的字符串。</p>
          <p>当处理完第四段，如果s为空即找到一组答案，否则弹出。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></strong></p>
        <blockquote>
          <p>模板题，每一次超出可选范围时跳出即可。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/subsets-ii/">90. 子集 II</a></strong></p>
        <blockquote>
          <p>模板题，对比前面的有一题思路相同，我们要去重的是同一层填入相同的数。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/increasing-subsequences/">491. 递增子序列</a></strong></p>
        <blockquote>
          <p>remake</p>
          <p>第一遍卡在了去重。</p>
          <p>随想录思路：先处理continue的条件，加上unset去重。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></strong></p>
        <blockquote>
          <p>DFS模板题，每一次遍历所有的数组，并判断这个数是否被使用过，没有的话填入，最后如果vec数组的大小等于nums数组大小，为一种情况。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></strong></p>
        <blockquote>
          <p>对比46题，本题中需要增加去重的操作，如果这个数和上一个数相同，并且是未使用的，说明是同层的数，并且未被使用过，肯定是同层已经遍历完的，用这个可以判断是不是同层的结点。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/reconstruct-itinerary/">🆙332. 重新安排行程</a></strong></p>
        <blockquote>
          <p>Hard 题。</p>
          <p>如果选择正确的容器来映射关系。</p>
          <p>以及注意如何正确初始化一个二维数组：</p>
          <p>vector&#x3C;vector
            <string>
              > exp{
              {"MUC", "LHR"},
              {"JFK", "MUC"},
              {"SFO", "SJC"},
              {"LHR", "SFO"}
              };
            </string>
          </p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/n-queens/">🆙51. N 皇后</a></strong></p>
        <blockquote>
          <p>自己写的时候，思路还是不够清晰，纠结以下的点，挨个挨个遍历，实际上，每行只能放一个，dfs每一行，再遍历一行的点即可。</p>
          <p>check时候，行和列都没问题。怎么检索对角线，要分为左斜和右斜</p>
          <p>二刷没问题，学习使用vector写二维数组以及初始化。</p>
        </blockquote>
        <p><strong><a href="https://leetcode.cn/problems/sudoku-solver/">🆙37. 解数独</a></strong></p>
        <blockquote>
          <p>Hard 题，双层递归，终止条件判断。</p>
          <p>一个个填写，填满找到答案。</p>
          <p>二刷通过，当时卡了一下vector的二维数组<code>vector&#x3C;vector&#x3C;char>> board</code>，用<code>board.size()</code>则得出行向量的维度，即这个表的行数，<code>board[0].size()</code>表明一个行向量的维度，即由多少列。</p>
          <p>注意这题的返回值是bool，而不是具体数值。</p>
        </blockquote>
        <p><a href="https://leetcode.cn/problems/number-of-islands">200. 岛屿数量</a></p>
        <blockquote>
          <p>BFS模板题。</p>
        </blockquote>
      </markdown-style>
      <nav class="tocs">
        <aside class="inner toc">
          <ol class="tocs-list">
            <li><a href="#回溯" class="tocs-link">回溯</a></li>
            <li><a href="#例题" class="tocs-link">例题</a></li>
          </ol>
        </aside>
      </nav>
    </div>
    <script src="../js/demo-preview.js?v=1.21.13"></script>
    <div class="footer warpper">Created by <a href="https://github.com/shixiaocaia" target="_blank">shixiaocaia</a> | Powered by <a href="https://github.com/jaywcjlove/idoc" target="_blank">idoc</a><br>Think less and do more.</div>
    <script src="../js/tocbot.js?v=1.21.13"></script>
  </body>
</html>
