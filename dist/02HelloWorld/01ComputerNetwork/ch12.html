<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTPS / HTTPS 今天是个好天气</title>
    <meta name="description" content="优点：">
    <meta name="keywords" content="notebook">
    <link rel="stylesheet" type="text/css" href="../../css/main.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../../css/tocbot.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../../css/media.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../../css/sidebar.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../../css/copy.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../../css/fancybox.css?v=1.25.0">
    <link rel="icon" href="../../logo.png" type="image/x-icon">
    <script src="../../js/copy.js?v=1.25.0"></script>
    <script src="../../js/dark-mode.js?v=1.25.0"></script>
    <script src="../../js/markdown-style.js?v=1.25.0"></script>
    <script src="../../js/jquery.min.js?v=1.25.0"></script>
    <script src="../../js/fancybox.umd.js?v=1.25.0"></script>
  </head>
  <body><button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
    <script>
// Get the button:
let mybutton = document.getElementById("myBtn");
// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};
// 顶部隐藏，底部隐藏
function scrollFunction() {
if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
mybutton.style.display = "block";
} else {
mybutton.style.display = "none";
}
}
// When the user clicks on the button, scroll to the top of the document
function topFunction() {
document.body.scrollTop = 0; // For Safari
document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
}
</script>
    <header class="header">
      <article class="inner warpper"><a class="logo" href="../../index.html"><img alt="今天是个好天气 logo" src="../../logo.png">
<span class="title">今天是个好天气</span></a>
        <div class="content">
          <ul class="menu">
            <li><a href="../../index.html" target="" class="">Home</a></li>
            <li><a href="../../00Go/index.html" target="" class="">Go</a></li>
            <li><a href="../../01MySQL/index.html" target="" class="">MySQL</a></li>
            <li><a href="../../01Redis/index.html" target="" class="">Redis</a></li>
            <li><a href="../../01LeetCode/index.html" target="" class="">LeetCode</a></li>
            <li><a href="../index.html" target="" class="active">Hello World</a></li>
          </ul><a href="https://github.com/shixiaocaia" target="_blank" rel="noopener noreferrer" title="Github" name="Github" class="github"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg></a>
          <dark-mode permanent=""></dark-mode>
        </div>
      </article>
    </header>
    <div class="warpper-content warpper sidebar">
      <div class="sidebar-border">
        <aside class="sidebar" role="navigation">
          <div>
            <a href="../index.html" class="">↩️README</a>
            <label>计算机网络</label>
            <a href="ch01.html" class="">网络发展过程</a>
            <a href="ch41.html" class="">键入url到渲染显示</a>
            <a href="ch11.html" class="">HTTP报文</a>
            <a href="ch12.html" class="">HTTPS / HTTP1、2、3</a>
            <a href="ch21.html" class="">三次握手/四次挥手</a>
            <a href="ch22.html" class="">socket</a>
            <a href="ch23.html" class="">可靠的TCP</a>
            <a href="ch31.html" class="">IP知识全家桶</a>
            <a href="ch32.html" class="">ping的工作原理</a>
            <label>操作系统</label>
            <a href="../01OperatingSystem/ch51.html" class="">优化程序性能</a>
            <a href="../01OperatingSystem/ch61.html" class="">存储器</a>
            <a href="../01OperatingSystem/ch71.html" class="">链接</a>
            <a href="../01OperatingSystem/ch81.html" class="">进程、线程、调度</a>
            <a href="../01OperatingSystem/ch82.html" class="">问题</a>
            <a href="../01OperatingSystem/ch91.html" class="">虚拟内存</a>
            <label>工具</label>
            <a href="../03Other/environment.html" class="">配个环境</a>
            <a href="../03Other/git.html" class="">Git</a>
            <a href="../03Other/shell.html" class="">Shell</a>
            <a href="../03Other/docker.html" class="">Docker</a>
            <a href="../03Other/python.html" class="">python</a>
          </div>
        </aside>
      </div>
      <markdown-style>
        <h1 id="https--https"><a aria-hidden="true" tabindex="-1" href="#https--https" class="anchor"><span class="icon icon-link"></span></a>HTTPS / HTTPS</h1>
        <h2 id="http优缺点"><a aria-hidden="true" tabindex="-1" href="#http优缺点" class="anchor"><span class="icon icon-link"></span></a>HTTP优缺点</h2>
        <p>优点：</p>
        <ul>
          <li>简单：HTTP 基本的报文格式就是 <code>header + body</code>，易于理解，降低了学习和使用的门槛</li>
          <li>灵活和易于扩展：请求字段和结构没有固定死，可以灵活设置</li>
          <li>应用广泛和跨平台</li>
        </ul>
        <p>缺点：</p>
        <ul>
          <li>通信使用明文（不加密），内容可能会被<strong>窃听</strong></li>
          <li>不验证通信方的身份，因此可能遭到<strong>伪装</strong></li>
          <li>无法证明报文的完整性，可能遭到<strong>篡改</strong></li>
        </ul>
        <h2 id="https"><a aria-hidden="true" tabindex="-1" href="#https" class="anchor"><span class="icon icon-link"></span></a>HTTPS</h2>
        <h3 id="区别"><a aria-hidden="true" tabindex="-1" href="#区别" class="anchor"><span class="icon icon-link"></span></a>区别</h3>
        <table>
          <thead>
            <tr>
              <th align="center">HTTP</th>
              <th align="center">HTTPS</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">超文本传输协议</td>
              <td align="center">超文本传输协议</td>
            </tr>
            <tr>
              <td align="center">明文传输</td>
              <td align="center">加密传输（TCP和HTTP之间加入了SSL/TLS安全协议）</td>
            </tr>
            <tr>
              <td align="center">三次握手后开始传输</td>
              <td align="center">增加SSL/TLS的握手过程</td>
            </tr>
            <tr>
              <td align="center">默认端口号：80</td>
              <td align="center">默认端口号：443</td>
            </tr>
            <tr>
              <td align="center">不需要证书</td>
              <td align="center">需要CA（证书权威机构）申请数字证书</td>
            </tr>
          </tbody>
        </table>
        <h2 id="http11"><a aria-hidden="true" tabindex="-1" href="#http11" class="anchor"><span class="icon icon-link"></span></a>HTTP/1.1</h2>
        <ul>
          <li><strong>延迟难以下降</strong>，虽然现在网络的「带宽」相比以前变多了，但是延迟降到一定幅度后，就很难再下降了，说白了就是到达了延迟的下限；</li>
          <li><strong>并发连接有限</strong>，谷歌浏览器最大并发连接数是 6 个，而且每一个连接都要经过 TCP 和 TLS 握手耗时，以及 TCP 慢启动过程给流量带来的影响；</li>
          <li><strong>队头阻塞问题</strong>，同一连接只能在完成一个 HTTP 事务（请求和响应）后，才能处理下一个事务；</li>
          <li><strong>HTTP 头部巨大且重</strong>，由于 HTTP 协议是无状态的，每一个请求都得携带 HTTP 头部，特别是对于有携带 Cookie 的头部，而 Cookie 的大小通常很大；</li>
          <li><strong>不支持服务器推送消息</strong>，因此当客户端需要获取通知时，只能通过定时器不断地拉取消息，这无疑浪费大量了带宽和服务器资源。</li>
        </ul>
        <h2 id="http20"><a aria-hidden="true" tabindex="-1" href="#http20" class="anchor"><span class="icon icon-link"></span></a>HTTP/2.0</h2>
        <h3 id="头部压缩"><a aria-hidden="true" tabindex="-1" href="#头部压缩" class="anchor"><span class="icon icon-link"></span></a>头部压缩</h3>
        <p>含很多固定的字段，比如 Cookie、User Agent、Accept 等，这些字段加起来也高达几百字节甚至上千字节，所以有必要<strong>压缩</strong>。</p>
        <p>HTTP/2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 <strong>HPACK</strong> 算法，HPACK 算法主要包含三个组成部分：</p>
        <ul>
          <li>静态字典；</li>
          <li>动态字典；</li>
          <li>Huffman 编码（压缩算法）；</li>
        </ul>
        <p>客户端和服务器两端都会建立和维护「<strong>字典</strong>」，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，<strong>可达到 50%~90% 的高压缩率</strong>。</p>
        <p>静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建<strong>动态表</strong>，它的 Index 从 <code>62</code> 起步，会在编码解码的时候随时更新。</p>
        <h3 id="二进制编码"><a aria-hidden="true" tabindex="-1" href="#二进制编码" class="anchor"><span class="icon icon-link"></span></a>二进制编码</h3>
        <p>将 HTTP/1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析。</p>
        <p>
          <img src="https://camo.githubusercontent.com/1c35c3b57d9e16e9a44a4a63b83971a1e2f85344b94d45a2b42ed8b3ea3a00c0/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470322f2545342542412538432545382542462539422545352538382542362545352542382541372e706e67" alt="img">
        </p>
        <p>在 HTTP/2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP/1.1 节省了 2 个字节（200每一位单独表示，需要三个字节）。</p>
        <h3 id="并发传输"><a aria-hidden="true" tabindex="-1" href="#并发传输" class="anchor"><span class="icon icon-link"></span></a>并发传输</h3>
        <p>HTTP/1.1 的实现是基于请求-响应模型的。同一个连接中，HTTP 完成一个事务（请求与响应），才能处理下一个事务。</p>
        <p>如果响应迟迟不来，那么后续的请求是无法发送的，也造成了<strong>队头阻塞</strong>的问题。</p>
        <p>HTTP/2通过 Stream 这个设计，<strong>多个 Stream 复用一条 TCP 连接，达到并发的效果</strong>，解决了 HTTP/1.1 队头阻塞的问题，提高了 HTTP 传输的吞吐量。</p>
        <p>多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成：</p>
        <p>
          <img src="D:/DownLoadForAll/68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470322f73747265616d322e706e67" alt="img">
        </p>
        <p>在 HTTP/2 连接上，<strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而<strong>同一 Stream 内部的帧必须是严格有序的</strong>。</p>
        <p>服务端和客户端都可以建立Stream， 客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>
        <p>当 HTTP/2 实现 100 个并发 Stream 时，只需要建立一次 TCP 连接，而 HTTP/1.1 需要建立 100 个 TCP 连接，每个 TCP 连接都要经过 TCP 握手、慢启动以及 TLS 握手过程，这些都是很耗时的。</p>
        <p>HTTP/2 还可以对每个 Stream 设置不同<strong>优先级</strong>，帧头中的「标志位」可以设置优先级，比如客户端访问 HTML/CSS 和图片资源时，希望服务器先传递 HTML/CSS，再传图片，那么就可以通过设置 Stream 的优先级来实现，以此提高用户体验。</p>
        <h3 id="服务器主动推送资源"><a aria-hidden="true" tabindex="-1" href="#服务器主动推送资源" class="anchor"><span class="icon icon-link"></span></a>服务器主动推送资源</h3>
        <p>HTTP/1.1 不支持服务器主动推送资源给客户端，都是由客户端向服务器发起请求后，才能获取到服务器响应的资源。</p>
        <p>服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。</p>
        <h2 id="http30"><a aria-hidden="true" tabindex="-1" href="#http30" class="anchor"><span class="icon icon-link"></span></a>HTTP/3.0</h2>
        <p>基于 TCP 实现的，于是存在的缺陷有三个。</p>
        <ul>
          <li>队头阻塞；</li>
          <li>TCP 与 TLS 的握手时延迟；</li>
          <li>网络迁移需要重新连接；</li>
        </ul>
        <h4 id="队头阻塞"><a aria-hidden="true" tabindex="-1" href="#队头阻塞" class="anchor"><span class="icon icon-link"></span></a>队头阻塞</h4>
        <p>HTTP/2 多个请求是跑在一个 TCP 连接中的，那么当 TCP 丢包时，整个 TCP 都要等待重传，那么就会阻塞该 TCP 连接中的所有请求。</p>
        <p>因为 TCP 是<strong>字节流协议</strong>，TCP 层必须保证收到的字节数据是完整且有序的，如果序列号较低的 TCP 段在网络传输中丢失了，即使序列号较高的 TCP 段已经被接收了，应用层也无法从内核中读取到这部分数据，从 HTTP 视角看，就是请求被阻塞了。</p>
        <h4 id="tcp与tls握手延迟"><a aria-hidden="true" tabindex="-1" href="#tcp与tls握手延迟" class="anchor"><span class="icon icon-link"></span></a>TCP与TLS握手延迟</h4>
        <p>发起 HTTP 请求时，需要经过 TCP 三次握手和 TLS 四次握手（TLS 1.2）的过程，因此共需要 3 个 RTT 的时延才能发出请求数据。</p>
        <p>TCP 由于具有「拥塞控制」的特性，所以刚建立连接的 TCP 会有个「慢启动」的过程，它会对 TCP 连接产生“减速”效果。</p>
        <h4 id="网络迁移"><a aria-hidden="true" tabindex="-1" href="#网络迁移" class="anchor"><span class="icon icon-link"></span></a>网络迁移</h4>
        <p>一个 TCP 连接是由四元组（源 IP 地址，源端口，目标 IP 地址，目标端口）确定的，这意味着如果 IP 地址或者端口变动了，就会导致需要 TCP 与 TLS 重新握手，这不利于移动设备切换网络的场景，比如 4G 网络环境切换成 WiFi。</p>
        <p>要解决这个问题，就必须把<strong>传输层协议替换成 UDP</strong>，这个大胆的决定，HTTP/3 做了！</p>
        <h3 id="quic协议"><a aria-hidden="true" tabindex="-1" href="#quic协议" class="anchor"><span class="icon icon-link"></span></a>QUIC协议</h3>
        <p>UDP 是一个简单、不可靠的传输协议，而且是 UDP 包之间是无序的，也没有依赖关系。</p>
        <p>而且，UDP 是不需要连接的，也就不需要握手和挥手的过程，所以天然的就比 TCP 快。</p>
        <p>HTTP/3基于UDP协议，并且应用层加入了QUIC协议。它具有类似 TCP 的连接管理、拥塞窗口、流量控制的网络特性，相当于将不可靠传输的 UDP 协议变成“可靠”的了，所以不用担心数据包丢失的问题。</p>
        <h4 id="无队头阻塞"><a aria-hidden="true" tabindex="-1" href="#无队头阻塞" class="anchor"><span class="icon icon-link"></span></a>无队头阻塞</h4>
        <p>QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p>
        <p>由于 QUIC 使用的传输协议是 UDP，UDP 不关心数据包的顺序，如果数据包丢失，UDP 也不关心。</p>
        <p>为了保证数据包的安全性，每个数据包都有一个序号唯一标识。当某个流中的一个数据包丢失了，即使该流的其他数据包到达了，数据也无法被 HTTP/3 读取，直到 QUIC 重传丢失的报文，数据才会交给 HTTP/3。</p>
        <p>而其他流的数据报文只要被完整接收，HTTP/3 就可以读取到数据。这与 HTTP/2 不同，HTTP/2 只要某个流中的数据包丢失了，其他流也会因此受影响（由于TCP的有序字节流问题）。</p>
        <p>QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p>
        <h4 id="更快连接建立"><a aria-hidden="true" tabindex="-1" href="#更快连接建立" class="anchor"><span class="icon icon-link"></span></a>更快连接建立</h4>
        <p>HTTP/3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p>
        <p>基于UDP，不需要通过TCP连接，QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”，再加上 QUIC 使用的是 TLS 1.3，因此仅需 1 个 RTT 就可以「同时」完成建立连接与密钥协商，甚至在第二次连接的时候，应用数据包可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p>
        <h4 id="连接迁移"><a aria-hidden="true" tabindex="-1" href="#连接迁移" class="anchor"><span class="icon icon-link"></span></a>连接迁移</h4>
        <p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。</p>
        <p>当移动设备的网络从 4G 切换到 WiFi 时，意味着 <strong>IP 地址变化了</strong>，那么就必须要断开连接，然后重新建立连接，而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p>
        <p>QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p>
        <h3 id="http3协议"><a aria-hidden="true" tabindex="-1" href="#http3协议" class="anchor"><span class="icon icon-link"></span></a>HTTP/3协议</h3>
        <h4 id="帧结构更简单"><a aria-hidden="true" tabindex="-1" href="#帧结构更简单" class="anchor"><span class="icon icon-link"></span></a>帧结构更简单</h4>
        <p>
          <img src="..\..\img\68747470733a2f2f63646e2e7869616f6c696e636f64696e672e636f6d2f67682f7869616f6c696e636f6465722f496d616765486f737434406d61696e2f2545372542442539312545372542422539432f68747470332f68747470336672616d652e706e67" alt="img">
        </p>
        <p>HTTP/3 自身不需要再定义 Stream，直接使用 QUIC 里的 Stream，于是 HTTP/3 的帧的结构也变简单了</p>
        <h4 id="头部压缩-1"><a aria-hidden="true" tabindex="-1" href="#头部压缩-1" class="anchor"><span class="icon icon-link"></span></a>头部压缩</h4>
        <p>HTTP/3 在头部压缩算法这一方面也做了升级，升级成了 <strong>QPACK</strong>。与 HTTP/2 中的 HPACK 编码方式相似，HTTP/3 中的 QPACK 也采用了静态表、动态表及 Huffman 编码。</p>
        <h4 id="qpack"><a aria-hidden="true" tabindex="-1" href="#qpack" class="anchor"><span class="icon icon-link"></span></a>QPACK</h4>
        <p><strong>动态表是具有时序性的，如果首次出现的请求发生了丢包，后续的收到请求，对方就无法解码出 HPACK 头部，因为对方还没建立好动态表，因此后续的请求解码会阻塞到首次请求中丢失的数据包重传过来</strong></p>
        <p>QUIC 会有两个特殊的单向流，所谓的单向流只有一端可以发送消息，双向则指两端都可以发送消息，传输 HTTP 消息时用的是双向流，这两个单向流的用法：</p>
        <ul>
          <li>一个叫 QPACK Encoder Stream，用于将一个字典（Key-Value）传递给对方，比如面对不属于静态表的 HTTP 请求头部，客户端可以通过这个 Stream 发送字典；</li>
          <li>一个叫 QPACK Decoder Stream，用于响应对方，告诉它刚发的字典已经更新到自己的本地动态表了，后续就可以使用这个字典来编码了。</li>
        </ul>
        <p>这两个特殊的单向流是用来<strong>同步双方的动态表</strong>，编码方收到解码方更新确认的通知后，才使用动态表编码 HTTP 头部。</p>
        <blockquote>
          <p>双方确认使用动态表，避免阻塞。</p>
        </blockquote>
      </markdown-style>
      <nav class="tocs">
        <aside class="inner toc">
          <ol class="tocs-list">
            <li><a href="#http优缺点" class="tocs-link">HTTP优缺点</a></li>
            <li><a href="#https" class="tocs-link">HTTPS</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#区别" class="tocs-link">区别</a></li>
              </ol>
            </li>
            <li><a href="#http11" class="tocs-link">HTTP/1.1</a></li>
            <li><a href="#http20" class="tocs-link">HTTP/2.0</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#头部压缩" class="tocs-link">头部压缩</a></li>
                <li><a href="#二进制编码" class="tocs-link">二进制编码</a></li>
                <li><a href="#并发传输" class="tocs-link">并发传输</a></li>
                <li><a href="#服务器主动推送资源" class="tocs-link">服务器主动推送资源</a></li>
              </ol>
            </li>
            <li><a href="#http30" class="tocs-link">HTTP/3.0</a></li>
          </ol>
        </aside>
      </nav>
    </div>
    <script src="../../js/demo-preview.js?v=1.25.0"></script>
    <div class="footer warpper">Created by <a href="https://github.com/shixiaocaia" target="_blank">shixiaocaia</a> | Powered by <a href="https://github.com/jaywcjlove/idoc" target="_blank">idoc</a><br>Think less and do more.</div>
    <script src="../../js/tocbot.js?v=1.25.0"></script>
  </body>
</html>
