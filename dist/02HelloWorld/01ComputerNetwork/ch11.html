<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP常见的问题 iDoc</title>
    <meta name="description" content="HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。">
    <meta name="keywords" content="notebook">
    <link rel="stylesheet" type="text/css" href="../../css/main.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../../css/tocbot.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../../css/media.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../../css/sidebar.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../../css/copy.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../../css/fancybox.css?v=1.25.0">
    <link rel="icon" href="../../logo.png" type="image/x-icon">
    <script src="../../js/copy.js?v=1.25.0"></script>
    <script src="../../js/dark-mode.js?v=1.25.0"></script>
    <script src="../../js/markdown-style.js?v=1.25.0"></script>
    <script src="../../js/jquery.min.js?v=1.25.0"></script>
    <script src="../../js/fancybox.umd.js?v=1.25.0"></script>
  </head>
  <body><button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
    <script>
// Get the button:
let mybutton = document.getElementById("myBtn");
// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};
// 顶部隐藏，底部隐藏
function scrollFunction() {
if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
mybutton.style.display = "block";
} else {
mybutton.style.display = "none";
}
}
// When the user clicks on the button, scroll to the top of the document
function topFunction() {
document.body.scrollTop = 0; // For Safari
document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
}
</script>
    <header class="header">
      <article class="inner warpper"><a class="logo" href="../../index.html"><img alt="iDoc logo" src="../../logo.png">
<span class="title">iDoc</span></a>
        <div class="content">
          <ul class="menu">
            <li><a href="../../index.html" target="" class="">Home</a></li>
            <li><a href="../../00Go/index.html" target="" class="">Go</a></li>
            <li><a href="../../01MySQL/index.html" target="" class="">MySQL</a></li>
            <li><a href="../../01Redis/index.html" target="" class="">Redis</a></li>
            <li><a href="../../01LeetCode/index.html" target="" class="">LeetCode</a></li>
            <li><a href="../index.html" target="" class="active">Hello World</a></li>
          </ul><a href="https://github.com/shixiaocaia" target="_blank" rel="noopener noreferrer" title="Github" name="Github" class="github"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg></a>
          <dark-mode permanent=""></dark-mode>
        </div>
      </article>
    </header>
    <div class="warpper-content warpper sidebar">
      <div class="sidebar-border">
        <aside class="sidebar" role="navigation">
          <div>
            <a href="../index.html" class="">↩️README</a>
            <label>计算机网络</label>
            <a href="ch00.html" class="">问题收集</a>
            <a href="ch11.html" class="">常见问题</a>
            <a href="ch21.html" class="">三次握手/四次挥手</a>
            <a href="ch22.html" class="">socket</a>
            <a href="ch23.html" class="">可靠的TCP</a>
            <a href="ch31.html" class="">IP知识全家桶</a>
            <a href="ch32.html" class="">ping的工作原理</a>
            <a href="ch01.html" class="">网络发展</a>
            <a href="ch41.html" class="">键入url到渲染显示</a>
            <label>操作系统</label>
            <a href="../01OperatingSystem/ch51.html" class="">优化程序性能</a>
            <a href="../01OperatingSystem/ch61.html" class="">存储器</a>
            <a href="../01OperatingSystem/ch71.html" class="">链接</a>
            <a href="../01OperatingSystem/ch81.html" class="">进程、线程、调度</a>
            <a href="../01OperatingSystem/ch82.html" class="">问题</a>
            <a href="../01OperatingSystem/ch91.html" class="">虚拟内存</a>
            <label>工具</label>
            <a href="../03Other/environment.html" class="">配个环境</a>
            <a href="../03Other/vim.html" class="">Vim</a>
            <a href="../03Other/git.html" class="">Git</a>
            <a href="../03Other/shell.html" class="">Shell</a>
            <a href="../03Other/docker.html" class="">Docker</a>
          </div>
        </aside>
      </div>
      <markdown-style>
        <h1 id="http常见的问题"><a aria-hidden="true" tabindex="-1" href="#http常见的问题" class="anchor"><span class="icon icon-link"></span></a>HTTP常见的问题</h1>
        <h2 id="是什么"><a aria-hidden="true" tabindex="-1" href="#是什么" class="anchor"><span class="icon icon-link"></span></a>是什么</h2>
        <p>HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。</p>
        <p>可以拆分成三部分：</p>
        <ul>
          <li>超文本：现如今的「超文本」，包括了图片、文字、视频等，最关键还有超链接。</li>
          <li>传输：HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范，两点之间有任意的中继。</li>
          <li>协议：HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。</li>
        </ul>
        <p><strong>HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</strong></p>
        <h3 id="常见的状态码"><a aria-hidden="true" tabindex="-1" href="#常见的状态码" class="anchor"><span class="icon icon-link"></span></a>常见的状态码</h3>
        <p>
          <img src="../../img/202303301107244.png" alt=" 五大类 HTTP 状态码 ">
        </p>
        <h3 id="常见字段"><a aria-hidden="true" tabindex="-1" href="#常见字段" class="anchor"><span class="icon icon-link"></span></a>常见字段</h3>
        <ul>
          <li>connection中的<code>keep-live</code>和TCP中的<code>keepalive</code>的区别</li>
        </ul>
        <h2 id="http报文是什么样"><a aria-hidden="true" tabindex="-1" href="#http报文是什么样" class="anchor"><span class="icon icon-link"></span></a>HTTP报文是什么样</h2>
        <p>
          <img src="../../img/62e061618977565c22c2cf09930e1d3c.png" alt="img">
        </p>
        <p>HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：</p>
        <ol>
          <li>起始行（start line）：描述请求或响应的基本信息；</li>
          <li>头部字段集合（header）：使用 key-value 形式更详细地说明报文；</li>
          <li>消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。</li>
        </ol>
        <blockquote>
          <ul>
            <li>这其中前两部分起始行和头部字段经常又合称为“<strong>请求头</strong>”或“<strong>响应头</strong>”，消息正文又称为“<strong>实体</strong>”，但与“<strong>header</strong>”对应，很多时候就直接称为“<strong>body</strong>”。</li>
            <li>HTTP规定报文必须有header，可以没有body，在header之后必须有一个空行（CRLF）。</li>
          </ul>
        </blockquote>
        <blockquote>
          <p>空行作为头部字段的结束标志，如果多了一个CRLF，服务器解析HTTP报文时会误以为读取完了所有头字段，开始解析报文主题。</p>
          <ul>
            <li>如果实际上没有实体或者为空，空行不会有太大影响</li>
            <li>如果不为空，额外空行会破坏HTTP报文的结构，可能会导致服务器无法正确解析报文</li>
          </ul>
        </blockquote>
        <h3 id="请求行"><a aria-hidden="true" tabindex="-1" href="#请求行" class="anchor"><span class="icon icon-link"></span></a>请求行</h3>
        <p>主要包括：</p>
        <ol>
          <li>请求方法：是一个动词，如 GET/POST，表示对资源的操作；</li>
          <li>请求目标：通常是一个 URI，标记了请求方法要操作的资源；</li>
          <li>版本号：表示报文使用的 HTTP 协议版本。</li>
        </ol>
        <p>这三个部分通常使用空格（space）来分隔，最后要用 CRLF 换行表示结束。</p>
        <h3 id="状态行"><a aria-hidden="true" tabindex="-1" href="#状态行" class="anchor"><span class="icon icon-link"></span></a>状态行</h3>
        <p>响应报文的起始行，叫做状态行，而不叫做响应行。</p>
        <p>主要包括：</p>
        <ol>
          <li>版本号：表示报文使用的 HTTP 协议版本；</li>
          <li>状态码：一个三位数，用代码的形式表示处理的结果，比如 200 是成功，500 是服务器错误；</li>
          <li>原因：作为数字状态码补充，是更详细的解释文字，帮助人理解原因。</li>
        </ol>
        <h3 id="头部字段"><a aria-hidden="true" tabindex="-1" href="#头部字段" class="anchor"><span class="icon icon-link"></span></a>头部字段</h3>
        <p>请求头和响应头的结构是基本一样的，唯一的区别是起始行。</p>
        <p>头部字段是 key-value 的形式，key 和 value 之间用“:”分隔，最后用 CRLF 换行表示字段结束。比如在“Host: 127.0.0.1”这一行里 key 就是“Host”，value 就是“127.0.0.1”。</p>
        <blockquote>
          <p>HTTP头字段灵活，不仅可以使用标准的头，还可以自定义头。</p>
        </blockquote>
        <p>本上可以分为四大类：</p>
        <ol>
          <li>通用字段：在请求头和响应头里都可以出现；</li>
          <li>请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；</li>
          <li>响应字段：仅能出现在响应头里，补充说明响应报文的信息；</li>
          <li>实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。</li>
        </ol>
        <p>常用字段：</p>
        <ul>
          <li>Host：请求字段，告诉服务器这个请求应该由哪个主机来处理。HTTP/1.1 里唯一要求<strong>必须提供</strong>的头字段是 Host，它必须出现在请求头里，标记虚拟主机名。</li>
          <li>User-Agent：请求字段，使用一个字符串来描述发起 HTTP 请求的客户端，服务器可以依据它来返回最合适此浏览器显示的页面，“Mozilla”“Chrome”“Safari”。</li>
          <li>Date：HTTP报文的创建时间，搭配其他字段决定缓存策略。</li>
          <li>Server：响应字段，只能出现在响应头里，告诉客户端当前正在提供 Web 服务的软件名称和版本号，例如在我们的实验环境里它就是“Server: openresty/1.15.8.1”，即使用的是 OpenResty 1.15.8.1。不是必须的，因为暴露了服务器信息，是危险的。</li>
          <li>Content-Length：实体字段，请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么 body 就是不定长的，需要使用 chunked 方式分段传输。</li>
        </ul>
        <h2 id="请求方法"><a aria-hidden="true" tabindex="-1" href="#请求方法" class="anchor"><span class="icon icon-link"></span></a>请求方法</h2>
        <ol>
          <li>GET：获取资源，可以理解为读取或者下载数据；</li>
          <li>HEAD：获取资源的元信息；</li>
          <li>POST：向资源提交数据，相当于写入或上传数据；</li>
          <li>PUT：类似 POST；</li>
          <li>DELETE：删除资源；</li>
          <li>CONNECT：建立特殊的连接隧道；</li>
          <li>OPTIONS：列出可对资源实行的方法；</li>
          <li>TRACE：追踪请求 - 响应的传输路径。</li>
        </ol>
        <h3 id="get"><a aria-hidden="true" tabindex="-1" href="#get" class="anchor"><span class="icon icon-link"></span></a>GET</h3>
        <ul>
          <li>一般GET 的语义是从服务器获取指定的资源，包括文本、视频、页面等多个资源，也可以是由 PHP、Java 动态生成的页面或者其他格式的数据。</li>
          <li>GET一般写在url中，浏览器会对url的长度有限制</li>
        </ul>
        <h3 id="head"><a aria-hidden="true" tabindex="-1" href="#head" class="anchor"><span class="icon icon-link"></span></a>HEAD</h3>
        <ul>
          <li>与GET方法类似，也是请求从服务器获取资源，服务器返回响应头，资源的元信息，不返回实体数据。</li>
          <li>响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。比如检查一个文件是否存在，检查一个文件是否有最新版本</li>
        </ul>
        <h3 id="post"><a aria-hidden="true" tabindex="-1" href="#post" class="anchor"><span class="icon icon-link"></span></a>POST</h3>
        <ul>
          <li>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理。</li>
          <li>POST 请求携带数据的位置一般是写在报文 body 中，body中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</li>
        </ul>
        <h3 id="put"><a aria-hidden="true" tabindex="-1" href="#put" class="anchor"><span class="icon icon-link"></span></a>PUT</h3>
        <ul>
          <li>通常 POST 表示的是“新建”“create”的含义，而 PUT 则是“修改”“update”的含义。</li>
          <li>因为它与 POST 的语义、功能太过近似，有的服务器甚至就直接禁止使用 PUT 方法，只用 POST 方法上传数据。</li>
        </ul>
        <h3 id="安全与幂等"><a aria-hidden="true" tabindex="-1" href="#安全与幂等" class="anchor"><span class="icon icon-link"></span></a>安全与幂等</h3>
        <p>概念：</p>
        <ul>
          <li>安全：指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。</li>
          <li>幂等：多次执行相同的操作，结果都是相同的。</li>
        </ul>
        <p>安全很容易分辨：GET和HEAD是只读的，POST和PUT会修改。</p>
        <p>幂等：GET和HEAD只读很容易区分，而POST是多次提交数据会创建多个资源不是幂等的，相当于INSERT，而PUT相当于UPDATE所以是幂等的。DELET重复删除同一个资源会提示不存在，所以也是幂等的。</p>
        <h3 id="get-vs-post"><a aria-hidden="true" tabindex="-1" href="#get-vs-post" class="anchor"><span class="icon icon-link"></span></a>GET VS POST</h3>
        <ul>
          <li>一般情况下，安全和幂等关系，是否可以缓存
            <ul>
              <li>因此一般情况下，GET方法只读所以是安全和幂等的，POST方法会提交和修改数据是不安全和不幂等的。</li>
              <li>实际中GET方法用于新增和修改数据就可能是不安全不幂等的，同理POST请求也是。</li>
            </ul>
          </li>
          <li>GET请求可以带上body吗
            <ul>
              <li>任何请求都可以用上body，只是GET请求获取资源用不上body</li>
              <li>同理，URL查询不是GET独有的，POST请求中URL也有参数</li>
            </ul>
          </li>
        </ul>
        <h2 id="写出正确的网址"><a aria-hidden="true" tabindex="-1" href="#写出正确的网址" class="anchor"><span class="icon icon-link"></span></a>写出正确的网址</h2>
        <p>URI是统一资源标识符，本质上是一个字符串，唯一地标记资源的位置或者名字。</p>
        <p>URI 最常用的形式，由 scheme、host:port、path 和 query 四个部分组成，但有的部分可以视情况省略。</p>
        <p>
          <img src="../../img/46581d7e1058558d8e12c1bf37d30d2a.png" alt="img">
        </p>
        <ul>
          <li><code>scheme</code>表示协议名，表示资源使用哪个协议来访问。常见的http，https。</li>
          <li><code>://</code>将scheme和后面部分分离。</li>
          <li><code>host:port</code>表示资源所在的主机名和端口号
            <ul>
              <li>主机名可以是 IP 地址或者域名的形式，必须要有，否则浏览器就会找不到服务器。</li>
              <li>但端口号有时可以省略，浏览器等客户端会依据 scheme 使用默认的端口号，例如 HTTP 的默认端口号是 80，HTTPS 的默认端口号是 443。</li>
            </ul>
          </li>
          <li><code>path</code>表示资源所在位置。比如<code>/11-1</code>、<code>/rfc2023</code></li>
          <li><code>?query</code>表示查询资源，是多个“key=value”的字符串，这些 KV 值用字符“&#x26;”连接，浏览器和客户端都可以按照这个格式把长串的查询参数解析成可理解的字典或关联数组形式。是对资源附加的额外要求。</li>
        </ul>
        <hr>
        <ul>
          <li>URI只能使用ASCII码，对于其他的字符转换为16进制字节值。</li>
        </ul>
        <h2 id="缓存原理"><a aria-hidden="true" tabindex="-1" href="#缓存原理" class="anchor"><span class="icon icon-link"></span></a>缓存原理</h2>
        <p>对重复性的HTTP请求，每次得到数据都一样时，把[请求 + 缓存]放在本地，下次直接读取本地数据。</p>
        <p>HTTP 协议的头部有不少是针对缓存的字段，实现缓存技术都要用到<code>Cache-control</code>和<code>expires</code>来判断缓存的过期情况。</p>
        <p>在第一次发送请求报文后，服务器在响应报文当中标注了<code>cache-control</code>，当报文过期后，向服务器发送请求时，会更新<code>cache-control</code>。</p>
        <p>
          <img src="../../img/http%E7%BC%93%E5%AD%98.png" alt="img">
        </p>
        <h3 id="强制缓存"><a aria-hidden="true" tabindex="-1" href="#强制缓存" class="anchor"><span class="icon icon-link"></span></a>强制缓存</h3>
        <p>浏览器判断缓存有没有过期，没有过期会直接使用本地缓存，决定权在浏览器。</p>
        <ul>
          <li>强缓存是利用了<code>Cache-Control</code>相对时间和<code>Expires</code>相对时间来判断资源在客户端的有效期</li>
          <li>如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，<strong>Cache-Control 的优先级高于 Expires</strong></li>
        </ul>
        <h3 id="协商缓存"><a aria-hidden="true" tabindex="-1" href="#协商缓存" class="anchor"><span class="icon icon-link"></span></a>协商缓存</h3>
        <p>浏览器判断过期的报文是否发生变更，通过本地缓存当中的<code>Last-Modified</code>和<code>ETag</code>两种标签判断。</p>
        <p>如果没有变更，会发送<code>304</code>报文告知客户端可以使用本地缓存，否则返回200有更新返回最新的资源，同时更新的标签值。</p>
        <h3 id="为什么etag与优先级更高"><a aria-hidden="true" tabindex="-1" href="#为什么etag与优先级更高" class="anchor"><span class="icon icon-link"></span></a>为什么ETag与优先级更高</h3>
        <ol>
          <li>在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求，因此<code>Last-Modified</code>基于修改时间的方式不够准确。</li>
          <li>可能有些文件是在秒级以内修改的，<code>If-Modified-Since</code> 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；</li>
          <li>有些服务器不能精确获取文件的最后修改时间。</li>
        </ol>
        <h3 id="整体流程"><a aria-hidden="true" tabindex="-1" href="#整体流程" class="anchor"><span class="icon icon-link"></span></a>整体流程</h3>
        <p>当使用 ETag 字段实现的协商缓存的过程：</p>
        <ul>
          <li>
            <p>当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；</p>
          </li>
          <li>
            <p>当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：</p>
            <ul>
              <li>如果没有过期，则直接使用本地缓存；</li>
              <li>如果缓存过期了，会在 Request 头部加上 If-None-Match / If-Modified-Since字段，该字段的值就是 ETag / Last-Modified唯一标识；</li>
            </ul>
          </li>
          <li>
            <p>服务器再次收到请求后，</p>
            <p>会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较</p>
            <ul>
              <li><strong>如果值相等，则返回 304 Not Modified，不会返回资源</strong>；</li>
              <li>如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；</li>
            </ul>
          </li>
          <li>
            <p>如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。</p>
          </li>
        </ul>
        <h2 id="http特性"><a aria-hidden="true" tabindex="-1" href="#http特性" class="anchor"><span class="icon icon-link"></span></a>HTTP特性</h2>
        <h3 id="http-11优缺点"><a aria-hidden="true" tabindex="-1" href="#http-11优缺点" class="anchor"><span class="icon icon-link"></span></a>HTTP 1.1优缺点</h3>
        <ul>
          <li>简单：HTTP 基本的报文格式就是 <code>header + body</code>，易于理解，降低了学习和使用的门槛</li>
          <li>灵活和易于扩展：请求字段和结构没有固定死，可以灵活设置</li>
          <li>应用广泛和跨平台</li>
          <li>无状态：服务器不会记忆HTTP的状态，进行关联性操作时要反复判断，但也节省了存储信息的负担，解决办法：Cooki技术</li>
          <li>明文传输：方便阅读，便于抓包调试，但是信息容易被窃取</li>
          <li>不安全：明文传输，不验证通信方的身份，无法证明报文的完整新，主要通过HTTPS解决</li>
        </ul>
        <h2 id="http与https"><a aria-hidden="true" tabindex="-1" href="#http与https" class="anchor"><span class="icon icon-link"></span></a>HTTP与HTTPS</h2>
        <h3 id="区别"><a aria-hidden="true" tabindex="-1" href="#区别" class="anchor"><span class="icon icon-link"></span></a>区别</h3>
        <table>
          <thead>
            <tr>
              <th align="center">HTTP</th>
              <th align="center">HTTPS</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td align="center">超文本传输协议</td>
              <td align="center">超文本传输协议</td>
            </tr>
            <tr>
              <td align="center">明文传输</td>
              <td align="center">加密传输（TCP和HTTP之间加入了SSL/TLS安全协议）</td>
            </tr>
            <tr>
              <td align="center">三次握手后开始传输</td>
              <td align="center">增加SSL/TLS的握手过程</td>
            </tr>
            <tr>
              <td align="center">默认端口号：80</td>
              <td align="center">默认端口号：443</td>
            </tr>
            <tr>
              <td align="center">不需要证书</td>
              <td align="center">需要CA（证书权威机构）申请数字证书</td>
            </tr>
          </tbody>
        </table>
        <h3 id="https如何解决了http问题"><a aria-hidden="true" tabindex="-1" href="#https如何解决了http问题" class="anchor"><span class="icon icon-link"></span></a>HTTPS如何解决了HTTP问题</h3>
        <p>在TCP/HTTP之间增加了SSL/TLS协议，解决了明文传输过程中的窃听风险、篡改风险、冒充风险问题。</p>
        <h4 id="混合加密"><a aria-hidden="true" tabindex="-1" href="#混合加密" class="anchor"><span class="icon icon-link"></span></a>混合加密</h4>
        <p>为了解决信息被窃听的问题，HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式，使得未经的解密的其他用户只能看到密文。</p>
        <p>一般将加密算法分为：</p>
        <ul>
          <li><strong>对称加密</strong>加密和解密使用同一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li>
          <li><strong>非对称加密</strong>使用两个不同的密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li>
        </ul>
        <blockquote>
          <p>使用对称加密前提是通信双方商量出一个密钥，在这个过程中是传输明文，容易被窃取。</p>
          <p>所以有了非对称加密，公钥被窃取时，通过公钥加密的报文，只能被私钥解密。</p>
        </blockquote>
        <p>综合考虑到可靠性和速度，HTTPS采用混合加密方式。</p>
        <p>也就是说，<strong>用非对称加密算法传输密钥，用对称加密算法传输实际数据。</strong> 此密钥一般称为<code>『会话密钥』</code>。</p>
        <blockquote>
          <p>黑客窃取到会话密钥，但是没有私钥解密，以至于在后续无法解密对称加密的数据。</p>
        </blockquote>
        <h4 id="摘要算法"><a aria-hidden="true" tabindex="-1" href="#摘要算法" class="anchor"><span class="icon icon-link"></span></a>摘要算法</h4>
        <p>为了保证传输的内容不被更改，计算出要发送内容的一个摘要，接受报文后再计算一遍，对比前后的值是否发生改变来判断内容是否被篡改。</p>
        <p>在计算机里会用摘要算法（<strong>哈希函数</strong>）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。</p>
        <blockquote>
          <p>计算机网络中常用的摘要算法有：MD5、SHA-1、SHA-256 等。</p>
        </blockquote>
        <p>但是在这个过程中不能保证整个内容和哈希值都被篡改，需要确保内容 + 哈希值都是原始发送的内容。</p>
        <p>增加了一个<strong>鉴别密钥</strong>，获取方式等同于会话密钥，摘要算法的输入变为数据+鉴别密钥，在经过篡改后的数据，另一端收到后会发现解密后鉴别密钥变更，被篡改了。</p>
        <blockquote>
          <p>为了进一步提升安全性，实际上客户端和服务器将使用不同的<code>会话密钥</code>和<code>鉴别密钥</code>，也就是一共需要四个密钥：</p>
          <ol>
            <li>用于从客户端发送到服务器的数据的<code>会话密钥</code>；</li>
            <li>用于从服务器发送到客户端的数据的<code>会话密钥</code>；</li>
            <li>用于从客户端发送到服务器的数据的<code>鉴别密钥</code>；</li>
            <li>用于从服务器发送到客户端的数据的<code>鉴别密钥</code>。</li>
          </ol>
        </blockquote>
        <h4 id="数字证书"><a aria-hidden="true" tabindex="-1" href="#数字证书" class="anchor"><span class="icon icon-link"></span></a>数字证书</h4>
        <p>万一服务器的公钥是被黑客伪造的呢？比如经典的『中间人攻击』问题，这里有点复杂具体可以看<a href="https://www.cnblogs.com/yifeng-coding/p/17031677.html">原文</a>。</p>
        <p>为了避免客户端收到了非正规的网站（中间人），需要一个数字证书。</p>
        <p>通过数字证书解决中间人攻击的具体过程为：</p>
        <ul>
          <li>服务器（正规网站）首先生成一对公钥和私钥，然后将域名、申请者、公钥（注意不是私钥，私钥是无论如何也不能泄露的）等信息整合在一起，生成 .csr 文件，并将此文件发给认证中心 CA。</li>
          <li>CA 收到申请后，会通过各种手段验证申请者的信息，如无异常，则使用摘要算法得到 .csr 中明文信息的一个摘要，再用 CA 自己的<code>私钥</code>对这个摘要进行加密，生成一串密文，密文也称为数字签名。数字证书即包含此数字签名和 .csr 中明文信息。CA 把这个证书返回给申请人。</li>
          <li>为了防止中间人攻击，客户端要求服务器发送其证书，并进行验证。</li>
          <li>客户端在验证证书时，把证书里的签名与及明文信息分别取出来，然后会用自身携带的 CA 机构的<code>公钥</code>去解密签名，得到摘要 1，再利用摘要算法得到明文信息的摘要 2，对比摘要 1 和摘要 2，如果一样，说明证书是合法的，也就是证书里的公钥是正确的，否则说明证书不合法。</li>
        </ul>
        <blockquote>
          <p>这里明文信息的摘要2，是可能被篡改的部分，而通过CA公钥解密得到的信息摘要是明确的。</p>
          <p>此外认证中心的公钥，一般在操作系统中会内置这些，避免公钥被伪造。</p>
          <p>Chrome 浏览器一旦发现一个网站数字证书无效，就会生成如下界面进行提示，如果用户强制访问，则存在一定的风险。（那我经常点开...</p>
        </blockquote>
        <h2 id="https连接建立"><a aria-hidden="true" tabindex="-1" href="#https连接建立" class="anchor"><span class="icon icon-link"></span></a>HTTPS连接建立</h2>
        <p>根据前面所述，进行一下小结：</p>
        <ul>
          <li>HTTPS 通过混合加密算法解决 HTTP 传输数据容易被窃听的问题，此过程需要协商<code>会话密钥</code>。</li>
          <li>HTTPS 通过摘要算法解决 HTTP 传输数据容易被篡改的问题，此过程需要协商<code>鉴别密钥</code>。</li>
          <li>HTTPS 通过数字证书解决 HTTP 协议中身份容易被伪造的问题，此过程需要客户端验证服务器的<code>证书</code>。</li>
        </ul>
        <p>通信双方在SSL / TLS协议握手的时候，来协商会话密钥和鉴别密钥，以及验证证书的合法性。</p>
        <p>
          <img src="../../img/23-HTTPS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="HTTPS 连接建立过程">
        </p>
        <ul>
          <li>
            <p>为什么第三、第四次握手要发送所有握手报文的摘要呢？</p>
            <blockquote>
              <p>主要原因是<strong>防止握手信息被篡改</strong>。比如客户端支持的密码套件列表中，有些加密算法较弱，有些加密算法较强，而此密码套件是明文传输的，万一黑客将此密码套件列表进行了修改，只留下一些安全性较低的加密算法，那么服务器就只能从这些安全性较低的加密算法中选择，安全性大大降低。因此需要通过发送摘要的形式防止握手信息被篡改。</p>
            </blockquote>
          </li>
          <li>
            <p>为什么不直接发送一个主密钥，而是用两个随机数加一个前主密钥重新生成一个主密钥呢？</p>
            <blockquote>
              <p>主要原因是<strong>防止连接重放</strong>。如果没有前面两个随机数，仅仅由客户端生成一个主密钥，并通过服务器<code>公钥</code>加密发送给服务器。那么黑客在嗅探了服务器与客户端之间的所有报文后，可以再次冒充客户端向服务器发送相同的报文（虽然黑客不知道内容是什么），因为报文信息都是之前客户端和服务器验证过的，因此服务器会认为是客户端与其通信，导致又一次连接。</p>
            </blockquote>
          </li>
        </ul>
        <p>整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p>
        <h3 id="客户端校验数字证书的流程是怎样的"><a aria-hidden="true" tabindex="-1" href="#客户端校验数字证书的流程是怎样的" class="anchor"><span class="icon icon-link"></span></a>客户端校验数字证书的流程是怎样的？</h3>
        <blockquote>
          <p>小林coding</p>
        </blockquote>
        <h2 id="https-的应用数据是如何保证完整性的"><a aria-hidden="true" tabindex="-1" href="#https-的应用数据是如何保证完整性的" class="anchor"><span class="icon icon-link"></span></a>HTTPS 的应用数据是如何保证完整性的？</h2>
        <h2 id="https-一定安全可靠吗"><a aria-hidden="true" tabindex="-1" href="#https-一定安全可靠吗" class="anchor"><span class="icon icon-link"></span></a>HTTPS 一定安全可靠吗？</h2>
        <h2 id="http11http2http3-演变"><a aria-hidden="true" tabindex="-1" href="#http11http2http3-演变" class="anchor"><span class="icon icon-link"></span></a>HTTP/1.1、HTTP/2、HTTP/3 演变</h2>
        <h3 id="http11"><a aria-hidden="true" tabindex="-1" href="#http11" class="anchor"><span class="icon icon-link"></span></a>HTTP/1.1</h3>
        <ul>
          <li>对比1.0 增加了长连接方式，改善了性能开销</li>
          <li>支持管道传输（但是一般浏览器并不支持</li>
        </ul>
        <h3 id="http2"><a aria-hidden="true" tabindex="-1" href="#http2" class="anchor"><span class="icon icon-link"></span></a>HTTP/2</h3>
        <ul>
          <li>头部压缩（1.1只能压缩body）：如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</li>
          <li>二进制格式：头信息和数据体都是二进制，并且统称为帧（frame），计算机可以解析和传输报文信息，并不需要转码操作。</li>
          <li>并发传输：在1.1中基于请求-响应报文，完成一个请求与响应，才能处理响应下一个，但是如果中途有一个阻塞，那么会造成后续的断发。在2.0当中引入Stream概念，多个Stream复用在一条TCP连接当中。</li>
          <li>服务器主动推送资源：客户端和服务器<strong>双方都可以建立 Stream</strong>，传输消息。比如在1.1当中html和css分别作请求和响应，在2.0服务端可以主动推送需要的css进行渲染。</li>
        </ul>
        <blockquote>
          <p>但是2.0虽然通过Stream的并发解决了1.0的队头阻塞问题，但是基于TCP实现的面向字节流，当一个报文的前1个字节延迟到达时，其他字节存放在缓冲区，全部到达后应用层才能从内核当中拿到数据。</p>
        </blockquote>
        <h3 id="http3"><a aria-hidden="true" tabindex="-1" href="#http3" class="anchor"><span class="icon icon-link"></span></a>HTTP/3</h3>
        <ul>
          <li>1.1通过stream解决了请求的队头阻塞，但是没有解决响应的队头阻塞。</li>
          <li>2通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。</li>
        </ul>
        <p>HTTP/3把下层的TCP协议改成了UDP。</p>
        <p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p>
        <p>QUIC 有以下 3 个特点。</p>
        <ul>
          <li>无队头阻塞：某个流发生丢包时，只会阻塞这个流，不会影响其他的。</li>
          <li>更快的连接建立：需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</li>
          <li>连接迁移</li>
        </ul>
      </markdown-style>
      <nav class="tocs">
        <aside class="inner toc">
          <ol class="tocs-list">
            <li><a href="#是什么" class="tocs-link">是什么</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#常见的状态码" class="tocs-link">常见的状态码</a></li>
                <li><a href="#常见字段" class="tocs-link">常见字段</a></li>
              </ol>
            </li>
            <li><a href="#http报文是什么样" class="tocs-link">HTTP报文是什么样</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#请求行" class="tocs-link">请求行</a></li>
                <li><a href="#状态行" class="tocs-link">状态行</a></li>
                <li><a href="#头部字段" class="tocs-link">头部字段</a></li>
              </ol>
            </li>
            <li><a href="#请求方法" class="tocs-link">请求方法</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#get" class="tocs-link">GET</a></li>
                <li><a href="#head" class="tocs-link">HEAD</a></li>
                <li><a href="#post" class="tocs-link">POST</a></li>
                <li><a href="#put" class="tocs-link">PUT</a></li>
                <li><a href="#安全与幂等" class="tocs-link">安全与幂等</a></li>
                <li><a href="#get-vs-post" class="tocs-link">GET VS POST</a></li>
              </ol>
            </li>
            <li><a href="#写出正确的网址" class="tocs-link">写出正确的网址</a></li>
            <li><a href="#缓存原理" class="tocs-link">缓存原理</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#强制缓存" class="tocs-link">强制缓存</a></li>
                <li><a href="#协商缓存" class="tocs-link">协商缓存</a></li>
                <li><a href="#为什么etag与优先级更高" class="tocs-link">为什么ETag与优先级更高</a></li>
                <li><a href="#整体流程" class="tocs-link">整体流程</a></li>
              </ol>
            </li>
            <li><a href="#http特性" class="tocs-link">HTTP特性</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#http-11优缺点" class="tocs-link">HTTP 1.1优缺点</a></li>
              </ol>
            </li>
            <li><a href="#http与https" class="tocs-link">HTTP与HTTPS</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#区别" class="tocs-link">区别</a></li>
                <li><a href="#https如何解决了http问题" class="tocs-link">HTTPS如何解决了HTTP问题</a>
                  <ol class="tocs-list is-collapsed">
                    <li><a href="#混合加密" class="tocs-link">混合加密</a></li>
                    <li><a href="#摘要算法" class="tocs-link">摘要算法</a></li>
                    <li><a href="#数字证书" class="tocs-link">数字证书</a></li>
                  </ol>
                </li>
              </ol>
            </li>
            <li><a href="#https连接建立" class="tocs-link">HTTPS连接建立</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#客户端校验数字证书的流程是怎样的" class="tocs-link">客户端校验数字证书的流程是怎样的？</a></li>
              </ol>
            </li>
            <li><a href="#https-的应用数据是如何保证完整性的" class="tocs-link">HTTPS 的应用数据是如何保证完整性的？</a></li>
            <li><a href="#https-一定安全可靠吗" class="tocs-link">HTTPS 一定安全可靠吗？</a></li>
            <li><a href="#http11http2http3-演变" class="tocs-link">HTTP/1.1、HTTP/2、HTTP/3 演变</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#http11" class="tocs-link">HTTP/1.1</a></li>
                <li><a href="#http2" class="tocs-link">HTTP/2</a></li>
                <li><a href="#http3" class="tocs-link">HTTP/3</a></li>
              </ol>
            </li>
          </ol>
        </aside>
      </nav>
    </div>
    <script src="../../js/demo-preview.js?v=1.25.0"></script>
    <div class="footer warpper">Created by <a href="https://github.com/shixiaocaia" target="_blank">shixiaocaia</a> | Powered by <a href="https://github.com/jaywcjlove/idoc" target="_blank">idoc</a><br>Think less and do more.</div>
    <script src="../../js/tocbot.js?v=1.25.0"></script>
  </body>
</html>
