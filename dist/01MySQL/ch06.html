<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>锁 今天是个好天气</title>
    <meta name="description" content="使用MVCC（多版本并发控制）属于一致性读，性能相比加锁更好，但是在一些情况下不得不加锁。">
    <meta name="keywords" content="notebook">
    <link rel="stylesheet" type="text/css" href="../css/main.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/tocbot.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/media.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/sidebar.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/copy.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/fancybox.css?v=1.25.0">
    <link rel="icon" href="../logo.png" type="image/x-icon">
    <script src="../js/copy.js?v=1.25.0"></script>
    <script src="../js/dark-mode.js?v=1.25.0"></script>
    <script src="../js/markdown-style.js?v=1.25.0"></script>
    <script src="../js/jquery.min.js?v=1.25.0"></script>
    <script src="../js/fancybox.umd.js?v=1.25.0"></script>
  </head>
  <body><button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
    <script>
// Get the button:
let mybutton = document.getElementById("myBtn");
// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};
// 顶部隐藏，底部隐藏
function scrollFunction() {
if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
mybutton.style.display = "block";
} else {
mybutton.style.display = "none";
}
}
// When the user clicks on the button, scroll to the top of the document
function topFunction() {
document.body.scrollTop = 0; // For Safari
document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
}
</script>
    <header class="header">
      <article class="inner warpper"><a class="logo" href="../index.html"><img alt="今天是个好天气 logo" src="../logo.png">
<span class="title">今天是个好天气</span></a>
        <div class="content">
          <ul class="menu">
            <li><a href="../index.html" target="" class="">Home</a></li>
            <li><a href="../00Go/index.html" target="" class="">Go</a></li>
            <li><a href="index.html" target="" class="active">MySQL</a></li>
            <li><a href="../01Redis/index.html" target="" class="">Redis</a></li>
            <li><a href="../01LeetCode/index.html" target="" class="">LeetCode</a></li>
            <li><a href="../02HelloWorld/index.html" target="" class="">Hello World</a></li>
          </ul><a href="https://github.com/shixiaocaia" target="_blank" rel="noopener noreferrer" title="Github" name="Github" class="github"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg></a>
          <dark-mode permanent=""></dark-mode>
        </div>
      </article>
    </header>
    <div class="warpper-content warpper sidebar">
      <div class="sidebar-border">
        <aside class="sidebar" role="navigation">
          <div>
            <a href="index.html" class="">↩️README</a>
            <label>SQL</label>
            <a href="ch00.html" class="">Hello MySQL</a>
            <a href="ch01.html" class="">SQL</a>
            <a href="ch02.html" class="">写点SQL</a>
            <label>MySQL原理</label>
            <a href="ch03.html" class="">InnoDB存储引擎</a>
            <a href="ch04.html" class="">索引</a>
            <a href="ch05.html" class="">事务</a>
            <label>锁</label>
            <a href="ch06.html" class="">有哪些锁</a>
            <a href="ch07.html" class="">MySQL如何加锁</a>
          </div>
        </aside>
      </div>
      <markdown-style>
        <h1 id="锁"><a aria-hidden="true" tabindex="-1" href="#锁" class="anchor"><span class="icon icon-link"></span></a>锁</h1>
        <p>使用MVCC（多版本并发控制）属于一致性读，性能相比加锁更好，但是在一些情况下不得不加锁。</p>
        <ul>
          <li>
            <p>共享锁，Shared Lock，简称S锁。在事务读取一条记录时，需要先获得S锁。</p>
          </li>
          <li>
            <p>独占锁，Exclusive Lock，简称X锁。在事务改动一条记录时，需要先获取该记录的X锁。</p>
          </li>
        </ul>
        <p>S锁和S锁之间是兼容的，S锁和X锁是不兼容的，X锁和X锁之间也是不兼容的。</p>
        <blockquote>
          <p>在事务A获取S锁后，事务B还可以申请S锁，如果申请X锁会阻塞。</p>
          <p>先申请X锁后，无法申请X锁和S锁。</p>
        </blockquote>
        <ul>
          <li><code>SELECT ... LOCK IN SHARE MODE</code>：对读取到的记录加S锁</li>
          <li><code>SELECT ... FOR UPDATE</code>：对读取的记录加X锁</li>
        </ul>
        <hr>
        <p>锁的粒度比较粗的比如表级锁，影响的记录是全表，对于行级锁针对单个记录，称其锁粒度比较低，锁粒度低可以实现精准的控制。</p>
        <h2 id="全局锁"><a aria-hidden="true" tabindex="-1" href="#全局锁" class="anchor"><span class="icon icon-link"></span></a>全局锁</h2>
        <h3 id="使用"><a aria-hidden="true" tabindex="-1" href="#使用" class="anchor"><span class="icon icon-link"></span></a>使用</h3>
        <ul>
          <li><code>flush tables with read lock</code>，之后整个数据库处于只读状态，其他线程操作会被阻塞吗，如对数据的增删改，对表结构的更改。</li>
          <li><code>unlock tables</code>，释放全局锁。</li>
        </ul>
        <h3 id="应用场景"><a aria-hidden="true" tabindex="-1" href="#应用场景" class="anchor"><span class="icon icon-link"></span></a>应用场景</h3>
        <ul>
          <li>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</li>
          <li>保证了数据安全的同时，备份期间业务停滞。</li>
        </ul>
        <blockquote>
          <p>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p>
          <p>像MyISAM不支持事务的引擎，备份数据库时需要使用全局锁。</p>
        </blockquote>
        <h2 id="表级锁"><a aria-hidden="true" tabindex="-1" href="#表级锁" class="anchor"><span class="icon icon-link"></span></a>表级锁</h2>
        <p>MySQL 里面表级别的锁有这几种：</p>
        <ul>
          <li>表锁；</li>
          <li>元数据锁（MDL）;</li>
          <li>意向锁；</li>
          <li>AUTO-INC 锁；</li>
        </ul>
        <h3 id="表锁"><a aria-hidden="true" tabindex="-1" href="#表锁" class="anchor"><span class="icon icon-link"></span></a>表锁</h3>
        <ul>
          <li>表级别的共享锁，也就是读锁：<code>lock tables t_student read;</code></li>
          <li>表级别的独占锁，也就是写锁：<code>lock tables t_stuent write;</code></li>
          <li><code>unlock tables</code>，释放锁。</li>
        </ul>
        <p>表锁会限制所有线程的读写操作。尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能。</p>
        <h3 id="元数据锁"><a aria-hidden="true" tabindex="-1" href="#元数据锁" class="anchor"><span class="icon icon-link"></span></a>元数据锁</h3>
        <p>简称MDL，我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p>
        <ul>
          <li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li>
          <li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li>
          <li>当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。</li>
        </ul>
        <p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p>
        <p><strong>MDL 不需要显示调用，那它是在什么时候释放的?</strong></p>
        <blockquote>
          <p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p>
        </blockquote>
        <p><strong>为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？</strong></p>
        <blockquote>
          <p>这是因为申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p>
        </blockquote>
        <p>所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。</p>
        <hr>
        <p>在InnoDB存储引擎当中，在对表SELECT、INSERT、DELETE、UPDATE时，不会为这个表添加表级别的S锁和X锁，在server层使用了MDL。其表级别的S锁和X锁比较鸡肋，不会提供额外保护，只会降低并发能力。</p>
        <h3 id="意向锁"><a aria-hidden="true" tabindex="-1" href="#意向锁" class="anchor"><span class="icon icon-link"></span></a>意向锁</h3>
        <p>由于S锁和X锁和是互斥的，对于整个表加上S锁和X锁前，需要检查整个表是否有记录存在锁，由此有了意向锁：在事务准备在某条记录上加上S锁或者X锁时，在表级别上增加意向锁。</p>
        <ul>
          <li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个IS锁**「意向共享锁」Intention Shared Lock**；</li>
          <li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个IX锁**「意向独占锁」Intention Exclusive Lock**；</li>
        </ul>
        <p>意向共享锁和意向独占锁是表级锁，之间不会产生冲突，IX锁和X锁和S锁不兼容，IS锁只和X锁不兼容。</p>
        <p>IX锁和IS锁是用来快速判断记录是否上锁的，避免用遍历的方式查看。</p>
        <h3 id="auto-inc-锁"><a aria-hidden="true" tabindex="-1" href="#auto-inc-锁" class="anchor"><span class="icon icon-link"></span></a>AUTO-INC 锁</h3>
        <p>表里的主键通常都会设置成自增的，这是通过对主键字段声明 <code>AUTO_INCREMENT</code> 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 <strong>AUTO-INC 锁</strong>实现的。</p>
        <p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是在一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p>
        <blockquote>
          <p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 <code>AUTO_INCREMENT</code> 修饰的字段的值是连续递增的。</p>
        </blockquote>
        <p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p>
        <p>在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p>
        <p>在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p>
        <blockquote>
          <p>一般插入语句在执行前就可以确定具体插入的记录数，就是用轻量级的锁，避免锁定表，提升插入性能。</p>
        </blockquote>
        <h2 id="行级锁"><a aria-hidden="true" tabindex="-1" href="#行级锁" class="anchor"><span class="icon icon-link"></span></a>行级锁</h2>
        <p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，其支持事务不相关的表级锁。</p>
        <p>行级锁的类型主要有三类：</p>
        <ul>
          <li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
          <li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li>
          <li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
        </ul>
        <h3 id="record-lock"><a aria-hidden="true" tabindex="-1" href="#record-lock" class="anchor"><span class="icon icon-link"></span></a>Record Lock</h3>
        <p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p>
        <ul>
          <li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li>
          <li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li>
        </ul>
        <h3 id="gap-lock"><a aria-hidden="true" tabindex="-1" href="#gap-lock" class="anchor"><span class="icon icon-link"></span></a>Gap Lock</h3>
        <p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p>
        <p>给记录加上Gap锁，避免当前记录和前一条记录之间插入新的记录造成幻读现象，只有Gap锁释放了才会释放阻塞。</p>
        <blockquote>
          <p>针对末尾，对Supermum记录（记录页面最大记录的，在最后）加上gap锁。</p>
        </blockquote>
        <h3 id="next-key-lock"><a aria-hidden="true" tabindex="-1" href="#next-key-lock" class="anchor"><span class="icon icon-link"></span></a>Next-Key Lock</h3>
        <p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock的组合，锁住某条记录，同时组织前面的间隙插入新记录。</p>
        <p>next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p>
        <h3 id="插入意向锁"><a aria-hidden="true" tabindex="-1" href="#插入意向锁" class="anchor"><span class="icon icon-link"></span></a>插入意向锁</h3>
        <p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了Gap锁（next-key lock 也包含Gap锁）。</p>
        <p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放Gap锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p>
        <p>插入意向锁之间是可以兼容的，实际上是不会阻碍其他事务获取该记录上的任何锁。</p>
        <h2 id="隐式锁"><a aria-hidden="true" tabindex="-1" href="#隐式锁" class="anchor"><span class="icon icon-link"></span></a>隐式锁</h2>
        <p>在内存当中生成锁结构并不是零成本的事，所以提出了隐式锁的概念，比如一般情况下INSERT不需要生成锁结构。</p>
        <p><strong>在插入记录的同时，此时进行读写，可能会出现脏写、脏读情况</strong></p>
        <blockquote>
          <p>对于聚簇索引，是有隐藏列trx_id的，通过判断之前的记录是否为活跃事务，不是的话说明已经提交可以获取，否则的话未这个事务创建一个X锁，锁状态为false，再为自己创建一个X锁，状态为true。</p>
        </blockquote>
        <blockquote>
          <p>对于二级索引，查看Page Header当中的，PAGE_MAX_TRX_ID，对该页面做改动的最大的事务ID，如果小于当前活跃的最小事务id，说明对该页面的修改已经提交，否则就需要定位到二级索引记录位置，通过回表到聚簇索引，重复上述的操作。</p>
        </blockquote>
        <p>可以看到<strong>通过事务ID，隐式锁延缓了生成锁结构</strong>，</p>
      </markdown-style>
      <nav class="tocs">
        <aside class="inner toc">
          <ol class="tocs-list">
            <li><a href="#全局锁" class="tocs-link">全局锁</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#使用" class="tocs-link">使用</a></li>
                <li><a href="#应用场景" class="tocs-link">应用场景</a></li>
              </ol>
            </li>
            <li><a href="#表级锁" class="tocs-link">表级锁</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#表锁" class="tocs-link">表锁</a></li>
                <li><a href="#元数据锁" class="tocs-link">元数据锁</a></li>
                <li><a href="#意向锁" class="tocs-link">意向锁</a></li>
                <li><a href="#auto-inc-锁" class="tocs-link">AUTO-INC 锁</a></li>
              </ol>
            </li>
            <li><a href="#行级锁" class="tocs-link">行级锁</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#record-lock" class="tocs-link">Record Lock</a></li>
                <li><a href="#gap-lock" class="tocs-link">Gap Lock</a></li>
                <li><a href="#next-key-lock" class="tocs-link">Next-Key Lock</a></li>
                <li><a href="#插入意向锁" class="tocs-link">插入意向锁</a></li>
              </ol>
            </li>
            <li><a href="#隐式锁" class="tocs-link">隐式锁</a></li>
          </ol>
        </aside>
      </nav>
    </div>
    <script src="../js/demo-preview.js?v=1.25.0"></script>
    <div class="footer warpper">Created by <a href="https://github.com/shixiaocaia" target="_blank">shixiaocaia</a> | Powered by <a href="https://github.com/jaywcjlove/idoc" target="_blank">idoc</a><br>Think less and do more.</div>
    <script src="../js/tocbot.js?v=1.25.0"></script>
  </body>
</html>
