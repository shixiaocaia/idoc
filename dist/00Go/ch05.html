<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数据结构 今天是个好天气</title>
    <meta name="description" content="[]byte转string：">
    <meta name="keywords" content="notebook">
    <link rel="stylesheet" type="text/css" href="../css/main.css?v=1.26.6">
    <link rel="stylesheet" type="text/css" href="../css/tocbot.css?v=1.26.6">
    <link rel="stylesheet" type="text/css" href="../css/media.css?v=1.26.6">
    <link rel="stylesheet" type="text/css" href="../css/sidebar.css?v=1.26.6">
    <link rel="stylesheet" type="text/css" href="../css/copy.css?v=1.26.6">
    <link rel="stylesheet" type="text/css" href="../css/fancybox.css?v=1.26.6">
    <link rel="icon" href="../logo.png" type="image/x-icon">
    <script src="../js/copy.js?v=1.26.6"></script>
    <script src="../js/dark-mode.js?v=1.26.6"></script>
    <script src="../js/markdown-style.js?v=1.26.6"></script>
    <script src="../js/jquery.min.js?v=1.26.6"></script>
    <script src="../js/fancybox.umd.js?v=1.26.6"></script>
  </head>
  <body><button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
    <script>
// Get the button:
let mybutton = document.getElementById("myBtn");
// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};
// 顶部隐藏，底部隐藏
function scrollFunction() {
if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
mybutton.style.display = "block";
} else {
mybutton.style.display = "none";
}
}
// When the user clicks on the button, scroll to the top of the document
function topFunction() {
document.body.scrollTop = 0; // For Safari
document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
}
</script>
    <header class="header">
      <article class="inner warpper"><a class="logo" href="../index.html"><img alt="今天是个好天气 logo" src="../logo.png">
<span class="title">今天是个好天气</span></a>
        <div class="content">
          <ul class="menu">
            <li><a href="../index.html" target="" class="">Home</a></li>
            <li><a href="index.html" target="" class="active">Go</a></li>
            <li><a href="../01MySQL/index.html" target="" class="">MySQL</a></li>
            <li><a href="../01Redis/index.html" target="" class="">Redis</a></li>
            <li><a href="../01LeetCode/index.html" target="" class="">LeetCode</a></li>
            <li><a href="../02HelloWorld/index.html" target="" class="">Hello World</a></li>
          </ul><a href="https://github.com/shixiaocaia" target="_blank" rel="noopener noreferrer" title="Github" name="Github" class="github"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg></a>
          <dark-mode permanent=""></dark-mode>
        </div>
      </article>
    </header>
    <div class="warpper-content warpper sidebar">
      <div class="sidebar-border">
        <aside class="sidebar" role="navigation">
          <div>
            <a href="index.html" class="">↩️README</a>
            <label>Hello World</label>
            <a href="ch00.html" class="">配个环境</a>
            <a href="ch01.html" class="">基础语法</a>
            <a href="ch02.html" class="">并发编程</a>
            <label>Web编程</label>
            <a href="ch03.html" class="">gorm</a>
            <a href="ch04.html" class="">gin</a>
            <label>原理深入</label>
            <a href="ch05.html" class="">逃逸分析</a>
            <a href="ch06.html" class="">数据结构</a>
          </div>
        </aside>
      </div>
      <markdown-style>
        <h1 id="数据结构"><a aria-hidden="true" tabindex="-1" href="#数据结构" class="anchor"><span class="icon icon-link"></span></a>数据结构</h1>
        <h2 id="string"><a aria-hidden="true" tabindex="-1" href="#string" class="anchor"><span class="icon icon-link"></span></a>String</h2>
        <ul>
          <li>字符串可以为empty，不可以为nil。</li>
          <li>字符串是不可以修改的，值不可变。</li>
          <li>字符串的本质是字符数组，每个字符在存储时对应一个或者多个整数（根据编码方式决定）</li>
        </ul>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">type</span> stringStruct <span class="token keyword">struct</span><span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    str unsafe<span class="token punctuation">.</span>Pointer
</span><span class="code-line line-number" line="3">    <span class="token builtin">len</span> <span class="token builtin">int</span>
</span><span class="code-line line-number" line="4"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="type stringStruct struct{
    str unsafe.Pointer
    len int
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <ul>
          <li>string类型的底层是一个指向byte类型的切片。</li>
          <li>这里的len是字符串中字节的个数，而不是字符的个数。</li>
          <li>从这里可以看出string类型定义没有容量Cap，所以字符串类型<strong>不能被扩容</strong>，实际上的拼接、追加是通过<strong>拷贝</strong>实现的。</li>
        </ul>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1">str <span class="token operator">:=</span> <span class="token string">"hello"</span>
</span><span class="code-line line-number" line="2">str <span class="token operator">=</span> <span class="token string">"Goland"</span>
</span><span class="code-line line-number" line="3">
</span><span class="code-line line-number" line="4">str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"I"</span> <span class="token comment">// error</span>
</span></code><input type="hidden" value="str := &#x22;hello&#x22;
str = &#x22;Goland&#x22;

str[0] = &#x22;I&#x22; // error
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <ul>
          <li>实际中我们使用的是重新赋值，而不是修改。</li>
          <li>每个字符在存储时对应一个整数，我们将一个字符赋值给byte类型是不允许的。</li>
        </ul>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1">str <span class="token operator">=</span> <span class="token string">"Hello world"</span>
</span><span class="code-line line-number" line="2">strbyte <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">72</span> <span class="token number">101</span> <span class="token number">108</span> <span class="token number">108</span> <span class="token number">111</span> <span class="token number">32</span> <span class="token number">119</span> <span class="token number">111</span> <span class="token number">114</span> <span class="token number">108</span> <span class="token number">100</span><span class="token punctuation">]</span>
</span><span class="code-line line-number" line="3"><span class="token function">string</span><span class="token punctuation">(</span>strbyte<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"Hello world"</span>
</span></code><input type="hidden" value="str = &#x22;Hello world&#x22;
strbyte = [72 101 108 108 111 32 119 111 114 108 100]
string(strbyte) = &#x22;Hello world&#x22;
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <ul>
          <li>实际中我们可以将string类型转换为[]byte，但是注意转换后是一个拷贝，对源字符串没有影响。</li>
        </ul>
        <hr>
        <p>[]byte转string：</p>
        <ul>
          <li>新申请内存空间，构建内存地址为addr，长度为len</li>
          <li>构建string对象，指针地址为addr，len字段为len</li>
          <li>将切片数值内容拷贝到string所指的内存空间当中</li>
        </ul>
        <blockquote>
          <p>[]byte转string，在某个场景下，临时转换时，不会发生内存拷贝。</p>
        </blockquote>
        <p>string转[]byte：</p>
        <ul>
          <li>新申请切片内存空间</li>
          <li>将string中指针执行内存区域的内容拷贝到新切片当中</li>
        </ul>
        <hr>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1">str1 <span class="token operator">:=</span> <span class="token string">"goland"</span>
</span><span class="code-line line-number" line="2">
</span><span class="code-line line-number" line="3">json <span class="token operator">:=</span> <span class="token string">`{"hello", "goland", "name": ["zhangsan"]}`</span>
</span></code><input type="hidden" value="str1 := &#x22;goland&#x22;

json := &#x60;{&#x22;hello&#x22;, &#x22;goland&#x22;, &#x22;name&#x22;: [&#x22;zhangsan&#x22;]}&#x60;
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <ul>
          <li>使用双引号时，遇到部分特殊符号需要使用转移字符</li>
          <li>使用反引号，可以在复杂场景当中保证原始内容</li>
        </ul>
        <hr>
        <p>由于Go中string不能拷贝，发生拼接时会发生内存的拷贝，存在性能损耗。</p>
        <p>常见的拼接包括了：</p>
        <ul>
          <li>+操作符</li>
          <li>fmt.Sprintf（一般用于字符串的格式化）</li>
          <li>bytes.Buffer</li>
          <li>strings.Builder</li>
          <li>append(性能较好，一般用这个)</li>
        </ul>
        <h2 id="slice"><a aria-hidden="true" tabindex="-1" href="#slice" class="anchor"><span class="icon icon-link"></span></a>Slice</h2>
        <p>Q：Slice和数组的区别，Slice的扩容方式</p>
        <p>Slice可以理解动态数组，数据扩容，是一种引用类型（值拷贝，是拷贝整个指针结构体的内容）</p>
        <p>支持自动扩容，长度可变，申明时不需要指针大小。</p>
        <hr>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">type</span> stringStruct <span class="token keyword">struct</span><span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    str unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 指针变量，指向一块连续的内存空间</span>
</span><span class="code-line line-number" line="3">    <span class="token builtin">len</span> <span class="token builtin">int</span>
</span><span class="code-line line-number" line="4">    <span class="token builtin">cap</span> <span class="token builtin">int</span>
</span><span class="code-line line-number" line="5"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="type stringStruct struct{
    str unsafe.Pointer // 指针变量，指向一块连续的内存空间
    len int
    cap int
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <p>可以类比到上面的string的底层，多了一个cap，支持扩容。</p>
        <p>在初始化时，如果没有指定cap，那么cap和len相等。</p>
        <hr>
        <p>在截取切片时，指向同一个底层数据，所以注意更新切片时，可能改变原切片的值。</p>
        <p>在对切片进行复制时，复制后的切片和原来的切片指向同一块内存区域。但是数组赋值是创建新的内存区域。</p>
        <blockquote>
          <p>这里的复制是复制了上述的结构体（重要的是其中的指针）。</p>
        </blockquote>
        <hr>
        <p>追加元素不足时，slice会自动扩容</p>
        <p>1.17之前：</p>
        <ol>
          <li>如果新的容量 >= 原容量的两倍，就使用新的容量大小</li>
          <li>否则，看切片容量小于1024，就扩展为原容量的两倍</li>
          <li>若大于1024，就会反复在原切片容量上增加1/4，直到新容量大于等于需要的容量。</li>
          <li>进行一个内存对其</li>
        </ol>
        <p>1.17以后：</p>
        <ol>
          <li>如果新的容量 >= 原容量的两倍，就使用新的容量大小</li>
          <li>否则，看切片容量小于256，就扩展为原容量的两倍</li>
          <li>若大于等于256，就会根据公式扩容，直到新容量大于等于需要的容量。</li>
          <li>进行一个内存对其</li>
        </ol>
        <hr>
        <p>为了使得赋值后的数组互不干扰，应该使用copy函数。</p>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1">temp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 注意len</span>
</span><span class="code-line line-number" line="2"><span class="token function">copy</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> cur<span class="token punctuation">)</span>
</span></code><input type="hidden" value="temp := make([]int, len(cur)) // 注意len
copy(temp, cur)
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <h2 id="map"><a aria-hidden="true" tabindex="-1" href="#map" class="anchor"><span class="icon icon-link"></span></a>Map</h2>
        <p>map中key不允许重复且要能够比较。</p>
        <p>在go当中，map的底层是hash表，用变种拉链法来解决hash冲突问题。</p>
        <h3 id="哈希冲突"><a aria-hidden="true" tabindex="-1" href="#哈希冲突" class="anchor"><span class="icon icon-link"></span></a>哈希冲突</h3>
        <p>将多个k-v键值对散列的存储在buckets中，buckets可以理解为一个连续的数组。</p>
        <p>给定一个key/value键值对，存储到合适位置，需要经过两步骤：</p>
        <ul>
          <li>计算hash值：将key转化为一个hash值</li>
          <li>计算索引位置：用hash值对所有桶数取模得到一个索引值，得到了要插入的键值对位置</li>
        </ul>
        <blockquote>
          <p>哈希冲突指的是当两个key计算出的hash值相等时，那后续的索引也是相同的，会冲突。</p>
        </blockquote>
        <p><strong>拉链法：</strong></p>
        <p>是很多语言使用的方法。主要实现是底层不直接使用连续数据来存储数据元素，而是通过数组和链表组合使用，数据里存储一个指针，指向一个链表。</p>
        <p>当哈希值相同时，链接到同一个链表当中，如果没有冲突显然一个链表当中只有一个元素。</p>
        <p>当冲突严重，链表长度过长时候，可以用红黑树代替链表。</p>
        <blockquote>
          <p>保证数组中的指针是唯一不重复的，链表中节点存放冲突的节点，或者是单一的。</p>
        </blockquote>
        <p><strong>开放地址法</strong>：</p>
        <p>将具体数据元素存储在数组桶中，在要插入新元素时，先根据哈希函数计算出hash值，根据hash值计算索引，如果发现冲突了，发现索引位置已经有数据了，就继续向后探测，直到找到未使用的数据槽位置。</p>
        <h3 id="底层结构"><a aria-hidden="true" tabindex="-1" href="#底层结构" class="anchor"><span class="icon icon-link"></span></a>底层结构</h3>
        <p>底层是一个指向hmap的指针，占用8个字节。</p>
        <ul>
          <li>buckets中包含了多个bmap的bucket数组，bucket底层采用链式结构将bmap连接起来。</li>
          <li>处理冲突使用优化的拉链法，链表中每个节点存储的不是一个键值对，而是8个。</li>
        </ul>
        <h3 id="访问原理"><a aria-hidden="true" tabindex="-1" href="#访问原理" class="anchor"><span class="icon icon-link"></span></a>访问原理</h3>
        <ol>
          <li>判断map是否为空或者无数据，返回无数据或者nil</li>
          <li>map写检测，如果正处于写状态，此时不能读取，panic</li>
          <li>计算hash值和掩码</li>
          <li>判断当前map是否处于扩容状态
            <ol>
              <li>根据状态位判断当前桶是否被迁移</li>
              <li>被迁移在新桶中找，否则根据掩码找到位置</li>
            </ol>
          </li>
          <li>依次遍历桶以及溢出桶来查找key
            <ol>
              <li>遍历桶内的八个槽位</li>
              <li>比较该槽位的tophash和当前的key的tophash是否相等
                <ol>
                  <li>相等，继续比较key是否相同，相同返回value</li>
                  <li>不相等，查找该槽位后继是否为空状态
                    <ol>
                      <li>是，key在以后的槽中也没有，这个key不存在，直接返回零值</li>
                      <li>否，遍历下一个槽位</li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>当前桶没有找到，则遍历溢出桶，用同样的方式查找</li>
        </ol>
        <h3 id="赋值原理"><a aria-hidden="true" tabindex="-1" href="#赋值原理" class="anchor"><span class="icon icon-link"></span></a>赋值原理</h3>
        <p>原map中存在key就更新对应的value，若map不存在key，则插入键值对key/value。</p>
        <blockquote>
          <p>map在赋值操作前要初始化，使用make，而不是var声明。</p>
        </blockquote>
        <blockquote>
          <p>map是非线程安全的，不支持并发读写操作，当其他进程正在读写map时，执行map赋值会报读写并发错误。</p>
        </blockquote>
        <ol>
          <li>map写检测，若正处于写状态，表示此时不能进行读取，报pannic</li>
          <li>计算出hash值，将map置为写状态</li>
          <li>判断桶数据是否为空，为空初始化桶数组</li>
          <li>目标桶查找
            <ol>
              <li>根据hash值找到桶的位置</li>
              <li>判断是否在扩容：若正在扩容，迁移这个桶，并且还另外帮忙多迁移一个桶以及它的溢出桶</li>
              <li>获取目标桶的指针，计算出tophash，开始后面的key查找过程</li>
            </ol>
          </li>
          <li>key查找
            <ol>
              <li>遍历桶和它的溢出桶的每个槽位</li>
              <li>判断槽位的tophash和目标tophash
                <ol>
                  <li>不相等
                    <ol>
                      <li>槽位tophash为空，标记这个位置为候选位置</li>
                      <li>槽位tophash的标志位后继为空，说明这个keyvalue之前没有被插入过，插入key/value</li>
                      <li>tophash标志位不为空，说明存储着其他key，说明当前槽的tophash不符合，继续遍历下一个槽</li>
                    </ol>
                  </li>
                  <li>相等
                    <ol>
                      <li>判断当前的槽位和目标key是否相等
                        <ol>
                          <li>不相等，继续遍历下一个槽位</li>
                          <li>相等，找到了目标key，原来已经存在键值对，则修改key1对应的value</li>
                        </ol>
                      </li>
                    </ol>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
          <li>key插入
            <ol>
              <li>
                若map中既没有找到key,且根据这个key找到的桶及其这个桶的溢出桶中没有空
                的槽位了，要申请一个新的溢出桶，在新申请的桶里插入
              </li>
              <li>否则在找到的位置插入</li>
            </ol>
          </li>
          <li>收尾程序
            <ol>
              <li>再次判断map的写状态</li>
              <li>清除map的写状态</li>
            </ol>
          </li>
        </ol>
        <h3 id="删除原理"><a aria-hidden="true" tabindex="-1" href="#删除原理" class="anchor"><span class="icon icon-link"></span></a>删除原理</h3>
        <h3 id="扩容原理"><a aria-hidden="true" tabindex="-1" href="#扩容原理" class="anchor"><span class="icon icon-link"></span></a>扩容原理</h3>
        <p>在上面介绍map的写入操作的时候，其实忽略了一个点，那就是随着不断地往map里写入元素，会导致map的数据量变得很大，hash性能会逐渐变差，而且溢出桶会越来越多，导致查找的性能变得很差。所以，需要更多的桶和更大的内存保证哈希的读写性能。</p>
        <p>当map遇到以下两种情况会触发扩容：</p>
        <ul>
          <li>map负载因子已经超过6.5——双倍扩容</li>
          <li>溢出桶数量过多——等量扩容（溢出桶数量接数组桶数量时）</li>
        </ul>
        <blockquote>
          <p>map不是一个原子操作，不是一次性完成的，在扩容前要判断当前是否正在扩容，避免二次扩容混论。</p>
        </blockquote>
        <blockquote>
          <p>负载因子 = 哈希表中元素数量 / 桶的数量</p>
        </blockquote>
        <p><strong>为什么负载因子是6.5？</strong></p>
        <p>负载因子是定义是6.5，经过测试后取出的一个比较合理的值。</p>
        <p>每个bucket有8个空位，假设map里所有的数组桶都装满元素，没有一个数组桶有溢出桶，这时负载因子刚好是8。</p>
        <p>负载因子是6.5的时候，说明数组桶快要用完了，存在溢出的情况，查找一个key可能要去遍历溢出桶，会造成查找性能下降，所以有必要扩容。</p>
        <p><strong>溢出桶数量过多？</strong></p>
        <p>负载因子小，map中元素总数少，但是bucket数量多，包含了大量的溢出桶。</p>
        <p><strong>扩容过程</strong></p>
        <p>go对map扩容，不是一次性将所有数据从旧的桶搬到新的桶。如果map数据量过大，会影响性能，因此采用是一种<strong>渐进式</strong>的数据转移技术，遵循<strong>写时赋值</strong>规则，对<strong>用到的数据迁移</strong>。</p>
        <p><strong>迁移时机</strong></p>
        <p>数据迁移一般发生在插入或者修改、删除key的时候，在扩容完毕后（预分配内存）后，不会立马进行迁移，而是采取写时复制方式，当访问到具体bucket时，才会逐渐从旧桶迁移到新桶。</p>
        <h3 id="遍历"><a aria-hidden="true" tabindex="-1" href="#遍历" class="anchor"><span class="icon icon-link"></span></a>遍历</h3>
        <p>每次遍历的数据顺序是不同的，因为每次开始遍历时，随机一个桶下标，桶内遍历的起点槽下边，遍历时候从这个桶开始，在遍历每个桶时，都从这个槽下标开始。</p>
        <blockquote>
          <p>为什么随机开始</p>
          <ol>
            <li>go扩容是渐进式的，遍历map时可能发生扩容，key位置会发生改变，下次遍历不是原来位置</li>
            <li>hash表插入数据每次插入位置也是变化的，数据删除和添加位置也会变化，因为同一个桶以及溢出链表中数据位置不分先后。</li>
          </ol>
          <p>防止用户错误的依赖于每次迭代的顺序，索性随机每次遍历位置。</p>
        </blockquote>
        <p>遍历的流程大致是以下几个步骤：</p>
        <ol>
          <li>map的并发写检测，判断map是否处于并发写状态，是则panic</li>
          <li>判断是否已经遍历完了，遍历完了直接退出</li>
          <li>开始遍历</li>
          <li>首选确定一个随机开始遍历的起始桶下标作为startBucket,然后确定一个随机的槽位下标作为offset</li>
          <li>根据startBucket和offset?开始遍历当前桶和当前桶的溢出桶，如果当前桶正在扩容，则进行步骤6，否则进行步骤7</li>
          <li>在遍历处于扩容状态的bucket的时候，因为当前bucket正在扩容，我们并不会遍历这个桶，而是会找到这个桶的l旧桶old_bucket,遍历l旧桶中的一部分key,这些key重新hash计算后能够散列到bucket中，对那些key经过重新hash计算不散列到bucket中的key,则跳过</li>
          <li>根据遍历初始化的时候选定的随机槽位开始遍历桶内的各个key/value</li>
          <li>继续遍历oucket溢出指针指向的溢出链表中的溢出桶</li>
          <li>假如遍历到了起始桶startBucket,则说明遍历完了，结束遍历</li>
        </ol>
      </markdown-style>
      <nav class="tocs">
        <aside class="inner toc">
          <ol class="tocs-list">
            <li><a href="#string" class="tocs-link">String</a></li>
            <li><a href="#slice" class="tocs-link">Slice</a></li>
            <li><a href="#map" class="tocs-link">Map</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#哈希冲突" class="tocs-link">哈希冲突</a></li>
                <li><a href="#底层结构" class="tocs-link">底层结构</a></li>
                <li><a href="#访问原理" class="tocs-link">访问原理</a></li>
                <li><a href="#赋值原理" class="tocs-link">赋值原理</a></li>
                <li><a href="#删除原理" class="tocs-link">删除原理</a></li>
                <li><a href="#扩容原理" class="tocs-link">扩容原理</a></li>
                <li><a href="#遍历" class="tocs-link">遍历</a></li>
              </ol>
            </li>
          </ol>
        </aside>
      </nav>
    </div>
    <script src="../js/demo-preview.js?v=1.26.6"></script>
    <div class="footer warpper">Created by <a href="https://github.com/shixiaocaia" target="_blank">shixiaocaia</a> | Powered by <a href="https://github.com/jaywcjlove/idoc" target="_blank">idoc</a><br>Think less and do more.</div>
    <script src="../js/tocbot.js?v=1.26.6"></script>
  </body>
</html>
