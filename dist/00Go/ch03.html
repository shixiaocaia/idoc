<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数据结构 今天是个好天气</title>
    <meta name="description" content="[]byte转string：">
    <meta name="keywords" content="notebook">
    <link rel="stylesheet" type="text/css" href="../css/main.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/tocbot.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/media.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/sidebar.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/copy.css?v=1.25.0">
    <link rel="stylesheet" type="text/css" href="../css/fancybox.css?v=1.25.0">
    <link rel="icon" href="../logo.png" type="image/x-icon">
    <script src="../js/copy.js?v=1.25.0"></script>
    <script src="../js/dark-mode.js?v=1.25.0"></script>
    <script src="../js/markdown-style.js?v=1.25.0"></script>
    <script src="../js/jquery.min.js?v=1.25.0"></script>
    <script src="../js/fancybox.umd.js?v=1.25.0"></script>
  </head>
  <body><button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>
    <script>
// Get the button:
let mybutton = document.getElementById("myBtn");
// When the user scrolls down 20px from the top of the document, show the button
window.onscroll = function() {scrollFunction()};
// 顶部隐藏，底部隐藏
function scrollFunction() {
if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
mybutton.style.display = "block";
} else {
mybutton.style.display = "none";
}
}
// When the user clicks on the button, scroll to the top of the document
function topFunction() {
document.body.scrollTop = 0; // For Safari
document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
}
</script>
    <header class="header">
      <article class="inner warpper"><a class="logo" href="../index.html"><img alt="今天是个好天气 logo" src="../logo.png">
<span class="title">今天是个好天气</span></a>
        <div class="content">
          <ul class="menu">
            <li><a href="../index.html" target="" class="">Home</a></li>
            <li><a href="index.html" target="" class="active">Go</a></li>
            <li><a href="../01MySQL/index.html" target="" class="">MySQL</a></li>
            <li><a href="../01Redis/index.html" target="" class="">Redis</a></li>
            <li><a href="../01LeetCode/index.html" target="" class="">LeetCode</a></li>
            <li><a href="../02HelloWorld/index.html" target="" class="">Hello World</a></li>
          </ul><a href="https://github.com/shixiaocaia" target="_blank" rel="noopener noreferrer" title="Github" name="Github" class="github"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
            </svg></a>
          <dark-mode permanent=""></dark-mode>
        </div>
      </article>
    </header>
    <div class="warpper-content warpper sidebar">
      <div class="sidebar-border">
        <aside class="sidebar" role="navigation">
          <div>
            <a href="index.html" class="">↩️README</a>
            <label>Hello World</label>
            <a href="ch00.html" class="">配个环境</a>
            <a href="ch01.html" class="">基础语法</a>
            <a href="ch02.html" class="">并发编程</a>
            <label>Web编程</label>
            <a href="ch05.html" class="">脚手架使用</a>
            <a href="ch06.html" class="">RPC</a>
            <label>原理深入</label>
            <a href="ch03.html" class="">数据结构</a>
            <a href="ch04.html" class="">逃逸分析</a>
          </div>
        </aside>
      </div>
      <markdown-style>
        <h1 id="数据结构"><a aria-hidden="true" tabindex="-1" href="#数据结构" class="anchor"><span class="icon icon-link"></span></a>数据结构</h1>
        <h2 id="string"><a aria-hidden="true" tabindex="-1" href="#string" class="anchor"><span class="icon icon-link"></span></a>String</h2>
        <ul>
          <li>字符串可以为empty，不可以为nil。</li>
          <li>字符串是不可以修改的，值不可变。</li>
          <li>字符串的本质是字符数组，每个字符在存储时对应一个或者多个整数（根据编码方式决定）</li>
        </ul>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">type</span> stringStruct <span class="token keyword">struct</span><span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    str unsafe<span class="token punctuation">.</span>Pointer
</span><span class="code-line line-number" line="3">    <span class="token builtin">len</span> <span class="token builtin">int</span>
</span><span class="code-line line-number" line="4"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="type stringStruct struct{
    str unsafe.Pointer
    len int
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <ul>
          <li>string类型的底层是一个指向byte类型的切片。</li>
          <li>这里的len是字符串中字节的个数，而不是字符的个数。</li>
          <li>从这里可以看出string类型定义没有容量Cap，所以字符串类型<strong>不能被扩容</strong>，实际上的拼接、追加是通过<strong>拷贝</strong>实现的。</li>
        </ul>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1">str <span class="token operator">:=</span> <span class="token string">"hello"</span>
</span><span class="code-line line-number" line="2">str <span class="token operator">=</span> <span class="token string">"Goland"</span>
</span><span class="code-line line-number" line="3">
</span><span class="code-line line-number" line="4">str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"I"</span> <span class="token comment">// error</span>
</span></code><input type="hidden" value="str := &#x22;hello&#x22;
str = &#x22;Goland&#x22;

str[0] = &#x22;I&#x22; // error
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <ul>
          <li>实际中我们使用的是重新赋值，而不是修改。</li>
          <li>每个字符在存储时对应一个整数，我们将一个字符赋值给byte类型是不允许的。</li>
        </ul>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1">str <span class="token operator">=</span> <span class="token string">"Hello world"</span>
</span><span class="code-line line-number" line="2">strbyte <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">72</span> <span class="token number">101</span> <span class="token number">108</span> <span class="token number">108</span> <span class="token number">111</span> <span class="token number">32</span> <span class="token number">119</span> <span class="token number">111</span> <span class="token number">114</span> <span class="token number">108</span> <span class="token number">100</span><span class="token punctuation">]</span>
</span><span class="code-line line-number" line="3"><span class="token function">string</span><span class="token punctuation">(</span>strbyte<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"Hello world"</span>
</span></code><input type="hidden" value="str = &#x22;Hello world&#x22;
strbyte = [72 101 108 108 111 32 119 111 114 108 100]
string(strbyte) = &#x22;Hello world&#x22;
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <ul>
          <li>实际中我们可以将string类型转换为[]byte，但是注意转换后是一个拷贝，对源字符串没有影响。</li>
        </ul>
        <hr>
        <p>[]byte转string：</p>
        <ul>
          <li>新申请内存空间，构建内存地址为addr，长度为len</li>
          <li>构建string对象，指针地址为addr，len字段为len</li>
          <li>将切片数值内容拷贝到string所指的内存空间当中</li>
        </ul>
        <blockquote>
          <p>[]byte转string，在某个场景下，临时转换时，不会发生内存拷贝。</p>
        </blockquote>
        <p>string转[]byte：</p>
        <ul>
          <li>新申请切片内存空间</li>
          <li>将string中指针执行内存区域的内容拷贝到新切片当中</li>
        </ul>
        <hr>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1">str1 <span class="token operator">:=</span> <span class="token string">"goland"</span>
</span><span class="code-line line-number" line="2">
</span><span class="code-line line-number" line="3">json <span class="token operator">:=</span> <span class="token string">`{"hello", "goland", "name": ["zhangsan"]}`</span>
</span></code><input type="hidden" value="str1 := &#x22;goland&#x22;

json := &#x60;{&#x22;hello&#x22;, &#x22;goland&#x22;, &#x22;name&#x22;: [&#x22;zhangsan&#x22;]}&#x60;
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <ul>
          <li>使用双引号时，遇到部分特殊符号需要使用转移字符</li>
          <li>使用反引号，可以在复杂场景当中保证原始内容</li>
        </ul>
        <hr>
        <p>由于Go中string不能拷贝，发生拼接时会发生内存的拷贝，存在性能损耗。</p>
        <p>常见的拼接包括了：</p>
        <ul>
          <li>+操作符</li>
          <li>fmt.Sprintf（一般用于字符串的格式化）</li>
          <li>bytes.Buffer</li>
          <li>strings.Builder</li>
          <li>append(性能较好，一般用这个)</li>
        </ul>
        <h2 id="slice"><a aria-hidden="true" tabindex="-1" href="#slice" class="anchor"><span class="icon icon-link"></span></a>Slice</h2>
        <p>Q：Slice和数组的区别，Slice的扩容方式</p>
        <p>Slice可以理解动态数组，数据扩容，是一种引用类型（值拷贝，是拷贝整个指针结构体的内容）</p>
        <p>支持自动扩容，长度可变，申明时不需要指针大小。</p>
        <hr>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1"><span class="token keyword">type</span> stringStruct <span class="token keyword">struct</span><span class="token punctuation">{</span>
</span><span class="code-line line-number" line="2">    str unsafe<span class="token punctuation">.</span>Pointer <span class="token comment">// 指针变量，指向一块连续的内存空间</span>
</span><span class="code-line line-number" line="3">    <span class="token builtin">len</span> <span class="token builtin">int</span>
</span><span class="code-line line-number" line="4">    <span class="token builtin">cap</span> <span class="token builtin">int</span>
</span><span class="code-line line-number" line="5"><span class="token punctuation">}</span>
</span></code><input type="hidden" value="type stringStruct struct{
    str unsafe.Pointer // 指针变量，指向一块连续的内存空间
    len int
    cap int
}
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <p>可以类比到上面的string的底层，多了一个cap，支持扩容。</p>
        <p>在初始化时，如果没有指定cap，那么cap和len相等。</p>
        <hr>
        <p>在截取切片时，指向同一个底层数据，所以注意更新切片时，可能改变原切片的值。</p>
        <p>在对切片进行复制时，复制后的切片和原来的切片指向同一块内存区域。但是数组赋值是创建新的内存区域。</p>
        <blockquote>
          <p>这里的复制是复制了上述的结构体（重要的是其中的指针）。</p>
        </blockquote>
        <hr>
        <p>追加元素不足时，slice会自动扩容</p>
        <p>1.17之前：</p>
        <ol>
          <li>如果新的容量 >= 原容量的两倍，就使用新的容量大小</li>
          <li>否则，看切片容量小于1024，就扩展为原容量的两倍</li>
          <li>若大于1024，就会反复在原切片容量上增加1/4，直到新容量大于等于需要的容量。</li>
          <li>进行一个内存对其</li>
        </ol>
        <p>1.17以后：</p>
        <ol>
          <li>如果新的容量 >= 原容量的两倍，就使用新的容量大小</li>
          <li>否则，看切片容量小于256，就扩展为原容量的两倍</li>
          <li>若大于等于256，就会根据公式扩容，直到新容量大于等于需要的容量。</li>
          <li>进行一个内存对齐</li>
        </ol>
        <hr>
        <p>为了使得赋值后的数组互不干扰，应该使用copy函数。</p>
        <pre class="language-go"><code class="language-go code-highlight"><span class="code-line line-number" line="1">temp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// 注意len</span>
</span><span class="code-line line-number" line="2"><span class="token function">copy</span><span class="token punctuation">(</span>temp<span class="token punctuation">,</span> cur<span class="token punctuation">)</span>
</span></code><input type="hidden" value="temp := make([]int, len(cur)) // 注意len
copy(temp, cur)
"><div onclick="copied(this)" class="copied"><svg class="octicon-copy" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path></svg><svg class="octicon-check" aria-hidden="true" viewBox="0 0 16 16" fill="currentColor" height="12" width="12"><path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path></svg></div></pre>
        <h2 id="map"><a aria-hidden="true" tabindex="-1" href="#map" class="anchor"><span class="icon icon-link"></span></a>Map</h2>
        <p>为了实现一个性能优异的哈希表，需要关注两个关键点。</p>
        <ul>
          <li>哈希函数的选择：选择的好，使得哈希函数的结果分布尽可能均匀，从而减少哈希冲突。</li>
          <li>哈希冲突的解决：当输入的键足够多，容易发生冲突，常见的解决办法：开放寻址法和拉链法。</li>
          <li>计算索引位置：根据hash函数将key转换为一个hash值，用hash值对所有的桶数取模得到一个索引值。</li>
        </ul>
        <h3 id="开放地址法"><a aria-hidden="true" tabindex="-1" href="#开放地址法" class="anchor"><span class="icon icon-link"></span></a>开放地址法</h3>
        <ul>
          <li>当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置。</li>
          <li>开放寻址法中对性能影响最大的是<strong>装载因子</strong>，它是数组中元素的数量与数组大小的比值。
            <ul>
              <li>随着装载因子的增加，线性探测的平均用时就会逐渐增加，这会影响哈希表的读写性能。</li>
              <li>当装载率超过 70% 之后，哈希表的性能就会急剧下降，而一旦装载率达到 100%，整个哈希表就会完全失效，这时查找和插入任意元素的时间复杂度都是 𝑂(𝑛)。</li>
            </ul>
          </li>
          <li>使用开放寻址法来实现哈希表，那么实现哈希表底层的数据结构就是数组，不过因为数组的长度有限。</li>
        </ul>
        <h3 id="拉链法"><a aria-hidden="true" tabindex="-1" href="#拉链法" class="anchor"><span class="icon icon-link"></span></a>拉链法</h3>
        <p>拉链法是哈希表最常见的实现方法，大多数的编程语言都用拉链法实现哈希表，它的实现比较开放地址法稍微复杂一些，但是平均查找的长度也比较短，各个用于存储节点的内存都是动态申请的，可以节省比较多的存储空间。</p>
        <ul>
          <li>找到键相同的键值对 — 更新键对应的值；</li>
          <li>没有找到键相同的键值对 — 在链表的末尾追加新的键值对；</li>
        </ul>
        <h3 id="数据结构-1"><a aria-hidden="true" tabindex="-1" href="#数据结构-1" class="anchor"><span class="icon icon-link"></span></a>数据结构</h3>
        <p>go语言的map其实是一个指向hmap的指针，占用8个字节。</p>
        <p>
          <img src="..\img\561d2e339e4d40119af819d7c3a77485.webp" alt="hmap.png">
        </p>
        <ul>
          <li><code>count</code> 表示已经存储的键值对数目</li>
          <li><code>flags</code>标记map的一些的状态</li>
          <li><code>noverflow</code>溢出桶的数量的近似值</li>
          <li><code>B</code> 表示当前哈希表持有的 <code>buckets</code> 数量，2^B个</li>
          <li><code>hash0</code> 是哈希的种子，它能为哈希函数的结果引入随机性</li>
          <li><code>bucket</code>记录桶在哪里</li>
          <li><code>oldbuckets</code> 记录扩容阶段，旧桶在哪里</li>
          <li><code>nevacuate</code>记录即将迁移的旧桶编号</li>
        </ul>
        <blockquote>
          <p>渐进式扩容，内容避免一次性扩容带来的瞬时抖动问题。</p>
        </blockquote>
        <p>当B > 4即桶的个数大于2^4，认为发生溢出的概率比较大，会预先分配2^(B-4)个桶，并且这些桶和普通桶是连续分配的，后面作为溢出桶。</p>
        <ul>
          <li><code>extra</code>记录已使用的溢出桶地址，旧桶使用的溢出桶地址，下一个空闲溢出桶地址。</li>
        </ul>
        <p>
          <img src="..\img\image-20230721225057582.png" alt="image-20230721225057582">
        </p>
        <p>hmap中包含了多个结构为bmap的bucket数组，底层采用链表结构将bmap连接起来，处理冲突使用了优化的拉链法。</p>
        <ul>
          <li>每个bmap可以存放八对键值对。</li>
          <li>前面八个是不同键的哈希的高 8 位，可以快读确认该键所在的哈希桶位置，直接访问桶，减少访问键值对次数以提高性能。</li>
        </ul>
        <h3 id="访问原理"><a aria-hidden="true" tabindex="-1" href="#访问原理" class="anchor"><span class="icon icon-link"></span></a>访问原理</h3>
        <p>对于<code>v:=map[key]</code>这种方式，大体步骤是</p>
        <ul>
          <li>判断map是否为空或者无数据，若为空返回无数据或者对应的控制</li>
          <li>map写检测，如果正在处于写状态，表示此时不能进行读取，panic</li>
          <li>计算出hash值和掩码</li>
          <li>判断当前map是否处于扩容状态，如果扩容
            <ul>
              <li>根据状态位判断当前桶是否被迁移，去新旧桶查找</li>
              <li>根据地址掩码找到对应位置</li>
            </ul>
          </li>
          <li>依次遍历桶以及溢出桶来查找key
            <ul>
              <li>遍历桶内的8个槽位</li>
              <li>比较该槽位的tophash值和当前key的是否相等
                <ul>
                  <li>相等，继续比较key是否相等，相等返回对应的value</li>
                  <li>否则，判断这个槽位是否后继为空
                    <ul>
                      <li>是说明，不在后续的桶，不存在，返回零值</li>
                      <li>是，遍历下一个槽位</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>当前桶没有找到，遍历溢出桶，同样方式查找</li>
        </ul>
        <h3 id="赋值原理"><a aria-hidden="true" tabindex="-1" href="#赋值原理" class="anchor"><span class="icon icon-link"></span></a>赋值原理</h3>
        <p><code>map[key]=value</code>形式，如果存在key更新value，如果不存在则插入新的键值对。</p>
        <blockquote>
          <p>对map进行赋值操作时，需要初始化，否则会panic，注意var只是声明。</p>
        </blockquote>
        <p>map是<strong>非线程安全的</strong>，当有其他线程正在读写map时，执行map的赋值会报并发读写错误。</p>
        <p>大致流程：</p>
        <ul>
          <li>map写检测，如果正在处于写状态，表示此时不能进行读取，报panic</li>
          <li>计算出hash值，将map置为写状态</li>
          <li>判断桶数组是否为空，为空，初始化桶数组</li>
          <li>目标桶查找
            <ul>
              <li>根据hash值找到桶的位置</li>
              <li>判断桶是否处于扩容状态，若正在扩容，迁移这个桶，还要帮忙多迁移一个桶以及它的溢出桶（迁移进度指向的桶）</li>
              <li>获取目标桶的指针，计算出tophash，开始后面的key查找过程</li>
            </ul>
          </li>
          <li>key查找，遍历桶和溢出桶每个槽位
            <ul>
              <li>判断槽位的tophash和目标的tophash</li>
              <li>不相等
                <ul>
                  <li>槽位tophash为空，标记这个位置为候选位置</li>
                  <li>槽位的tophash标位置为后继为空，直接插入key/value</li>
                  <li>不为空，继续遍历下一个槽</li>
                </ul>
              </li>
              <li>相等
                <ul>
                  <li>判断当前槽位的key与目标key是否相等
                    <ul>
                      <li>不相等，继续遍历下一个位置</li>
                      <li>相等，找到目标key的位置，存在就更新值，跳到收尾操作</li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>key插入
            <ul>
              <li>若map中没有找到key，且这个桶和溢出桶都没有槽位了，申请一个溢出桶，并插入</li>
              <li>否则找到的位置插入</li>
            </ul>
          </li>
          <li>收尾
            <ul>
              <li>再次判断map的写状态</li>
              <li>清楚map写状态</li>
            </ul>
          </li>
        </ul>
        <h3 id="扩容原理"><a aria-hidden="true" tabindex="-1" href="#扩容原理" class="anchor"><span class="icon icon-link"></span></a>扩容原理</h3>
        <p>随着元素不断插入，会导致map的数据量增加，hash性能变差，溢出桶增加，因此需要更多的桶和内存来保证哈希的读写性能，所以map会自动触发扩容。</p>
        <p>以下两种情况会触发扩容：</p>
        <ul>
          <li>map的负载因子超过6.5：双倍扩容</li>
          <li>溢出桶数量过多：等量扩容（溢出桶数量接近正常桶数量）</li>
        </ul>
        <blockquote>
          <p>扩容需要判断当前是否为扩容状态，避免二次扩容冲突。</p>
          <p>经过测试6.5时数组桶快要用完的情况，存在溢出要去遍历溢出桶，所以需要扩容。</p>
          <p>删除过多元素时，负载因子减小，再插入很多元素会创建更多的溢出桶，导致查找元素时去遍历查过的溢出桶链表，因此选择扩容，把之前的数组桶和溢出桶中元素重排。</p>
        </blockquote>
        <p>整个过程：</p>
        <ul>
          <li>map扩容采取了渐进式扩容，避免性能的影响，遵循写时赋值，每次只对使用到的数据进行迁移。</li>
          <li>扩容发生在赋值操作时，满足上述两个条件触发。</li>
        </ul>
        <p>迁移时机：</p>
        <ul>
          <li>判断当前bucket是否已经迁移，没有迁移就做迁移操作，通过tophash的第一个hash值判断</li>
          <li>数据迁移时，可能到大小相同的桶，就依然存放在原先的位置，如果是双倍扩容，会发生变化</li>
          <li>确定完bucket后，按照bucket键值对进行迁移</li>
        </ul>
        <h3 id="删除原理"><a aria-hidden="true" tabindex="-1" href="#删除原理" class="anchor"><span class="icon icon-link"></span></a>删除原理</h3>
        <p>和访问原理差不多，会进行写检测，寻找bucket和key过程</p>
        <p>
          从delete map单个key/value的原理可以看出，当我们删除一个键值对的时候，这个键值对在桶中的
          内存并不会被释放，所以对与map的频繁写入和删除可能会造成内存泄漏。
        </p>
        <h3 id="遍历原理"><a aria-hidden="true" tabindex="-1" href="#遍历原理" class="anchor"><span class="icon icon-link"></span></a>遍历原理</h3>
        <p>每次遍历的数据顺序不同，随机一个桶以及桶内的起点槽下标，遍历时从这个桶开始，在遍历每个桶时都从这个槽开始。</p>
        <p>why：</p>
        <ul>
          <li>一方面：因为go的扩容不是一个原子操作，是渐进式的，所以在遍历map的时候，可能发生扩容，一旦发生扩容，key的位置就发生了重大的变化，下次遍历map的时候结果就不可能按原来的顺序了。</li>
          <li>另一方面：hash表中数据每次插入的位置是变化的，同一个map变量内，数据删除再添加的位置也有可能变化，因为在同一个桶及溢出链表中数据的位置不分先后。</li>
        </ul>
        <p>主要步骤，先初始化迭代器：</p>
        <ul>
          <li>判断map是否为空</li>
          <li>保存map的B值和当前桶指针，即保存遍历开始时map的数据快照，避免扩容时map的B值和桶指针发生改变</li>
          <li>随机一个开始遍历的起始桶下标</li>
          <li>随机一个槽位下标，后续每个桶内的遍历都从这个槽位开始</li>
          <li>把map置为遍历状态</li>
          <li>开始执行一次遍历过程</li>
        </ul>
        <hr>
        <ul>
          <li>map的并发写检测，判断map是否处于并发写状态，是则panic</li>
          <li>判断是否已经遍历完了，遍历完了直接退出</li>
          <li>开始遍历</li>
          <li>首选确定一个随机开始遍历的起始桶下标作为startBucket,然后确定一个随机的槽位下标作为offset</li>
          <li>根据startBucket和offset开始遍历当前桶和当前桶的谥出桶，如果当前桶正在扩容，则进行步骤6,否则进行步骤7</li>
          <li>在遍历处于扩容状态的bucket的时候，因为当前bucketi正在扩容，我们并不会遍历这个桶，而是会找到这个桶的I旧桶old_bucket,遍历l旧桶中的一部分key,这些key重新hash计算后能够散列到bucketr中，对那些key经过重新hash计算不散列到bucket中的key,则跳过</li>
          <li>根据遍历初始化的时候选定的随机槽位开始遍历桶内的各个key/value</li>
          <li>继续遍历bucket溢出指针指向的溢出链表中的溢出桶</li>
          <li>假如遍历到了起始桶startBucket,则说明遍历完了，结束遍历</li>
        </ul>
      </markdown-style>
      <nav class="tocs">
        <aside class="inner toc">
          <ol class="tocs-list">
            <li><a href="#string" class="tocs-link">String</a></li>
            <li><a href="#slice" class="tocs-link">Slice</a></li>
            <li><a href="#map" class="tocs-link">Map</a>
              <ol class="tocs-list is-collapsed">
                <li><a href="#开放地址法" class="tocs-link">开放地址法</a></li>
                <li><a href="#拉链法" class="tocs-link">拉链法</a></li>
                <li><a href="#数据结构-1" class="tocs-link">数据结构</a></li>
                <li><a href="#访问原理" class="tocs-link">访问原理</a></li>
                <li><a href="#赋值原理" class="tocs-link">赋值原理</a></li>
                <li><a href="#扩容原理" class="tocs-link">扩容原理</a></li>
                <li><a href="#删除原理" class="tocs-link">删除原理</a></li>
                <li><a href="#遍历原理" class="tocs-link">遍历原理</a></li>
              </ol>
            </li>
          </ol>
        </aside>
      </nav>
    </div>
    <script src="../js/demo-preview.js?v=1.25.0"></script>
    <div class="footer warpper">Created by <a href="https://github.com/shixiaocaia" target="_blank">shixiaocaia</a> | Powered by <a href="https://github.com/jaywcjlove/idoc" target="_blank">idoc</a><br>Think less and do more.</div>
    <script src="../js/tocbot.js?v=1.25.0"></script>
  </body>
</html>
