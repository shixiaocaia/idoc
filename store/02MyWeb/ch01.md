线程同步机制类
===

在本项目中使用互斥锁、条件变量、信号量来保证线程的安全。

## 基础API

### RAII

- RAII全称是“Resource Acquisition is Initialization”，直译过来是“资源获取即初始化”.
- 在构造函数中申请分配资源，在析构函数中释放资源。因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定
- RAII的核心思想是将资源或者状态与对象的生命周期绑定，通过C++的语言机制，实现资源和状态的安全管理,**智能指针**是RAII最好的例子。

### 信号量

需要实现的

> - 初始化信号量
> - 用于销毁信号量
> - 对信号加锁，将信号量减一,信号量为0时,sem_wait阻塞
> - 对信号解锁，将信号量加一,信号量大于0时,唤醒调用sem_post的线程

以上，成功返回0，失败返回errno

### 互斥锁

为避免线程更新共享变量时出现问题，可以使用互斥量（mutex 是 mutual exclusion 的缩写）来确保同时仅有一个线程可以访问某项共享资源。可以使用互斥量来保证对任意共享资源的原子访问。

需要实现

> - 初始化互斥锁
> - 销毁互斥锁
> - 互斥锁加锁
> - 互斥锁解锁

以上，成功返回0，失败返回errno

### 条件变量

条件变量提供了一种线程间的通知机制,当某个共享数据达到某个值时,唤醒等待这个共享数据的线程.

需要实现

> - 初始化条件变量
> - 释放条件变量
> - wait / timedwait唤醒一个或者多个等待的线程
> - signal broadcast唤醒所有等待的线程

## 功能

主要是Linux下三种锁进行封装，将锁的创建于销毁函数封装在类的构造与析构函数中，实现RAII机制。

