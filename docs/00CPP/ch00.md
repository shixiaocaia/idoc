语法知识
===

## C++和C语言的区别

- C++中new和delete是对内存分配的运算符，取代了C中的malloc和free。
- 标准C++中的字符串类取代了标准C函数库头文件中的字符数组处理函数（C中没有字符串类型）。
- C++中用来做控制态输入输出的iostream类库替代了标准C中的stdio函数库。
- C++中的try/catch/throw异常处理机制取代了标准C中的setjmp()和longjmp()函数。
- 在C++中，允许有相同的函数名，不过它们的参数类型不能完全相同，这样这些函数就可以相互区别开来。而这在C语言中是不允许的。也就是C++可以重载，C语言不允许。
- C++语言中，允许变量定义语句在程序中的任何地方，只要在是使用它之前就可以；而C语言中，必须要在函数开头部分。而且C++不允许重复定义变量，C语言也是做不到这一点的
- 在C++中，除了值和指针之外，新增了引用。引用型变量是其他变量的一个别名，我们可以认为他们只是名字不相同，其他都是相同的。
- C++相对与C增加了一些关键字，如：bool、using、dynamic_cast、namespace等等

## 条件编译

```cpp
#ifdef P
cout << "test" << endl;
#endif

g++ -DP p1.cpp -o test
```

## enum使用

   > ```cpp
   > enum week {Sun, Mon, Tue, Wed, Thu, Fri, Sat};
   > //默认从Sun = 0 开始，逐个加1
   > 
   > enum week {Sun=7, Mon=1, Tue, Wed, Thu, Fri, Sat};
   > //枚举常量Sun,Mon,Tue,Wed,Thu,Fri,Sat的值分别为7、1、2、3、4、5、

## 左值和右值

在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值。

**左值引用、右值引用**

> 左值引用就是对一个左值进行引用的类型。
>
> 右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。
>
> 右值引用和左值引用都是属于引用类型，并且都是左值,且都必须初始化。

```cpp
int &a = 2; //通常左值引用不能绑定到右值

//常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。
int b = 2;        # 非常量左值
const int &c = b; # 常量左值引用绑定到非常量左值，编译通过
const int d = 2;  # 常量左值
const int &e = c; # 常量左值引用绑定到常量左值，编译通过
const int &b =2;  # 常量左值引用绑定到右值，编程通过
```

```cpp
//&&右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值
int a;
int &&r1 = c;             # 编译失败
int &&r2 = std::move(a);  # 编译通过
```

## 静态成员变量

- 所有对象共享一个静态数据，修改值，会全局修改所有对象的这个值。
- 静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。
- 在类中声明，在类外定义。
- 可以在类外直接定义，但是不能够直接访问。

## 静态成员函数

- 静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。也可以通过对象调用。
- 静态成员函数主要为了访问静态变量，不能访问普通成员变量。
- 如果一个类的成员，既要实现共享，又要实现不可改变，那就用 static const 修饰。定义静态const数据成员时，最好在类内部初始化。
- 没有this指针。

## 区分"."和"->"

对于结构体变量可以同时使用二者。

对于指针只能使用`->`。

##  在main执行之前和之后执行的代码可能是什么？

**main函数执行之前**，主要就是初始化系统相关资源：

- 设置栈指针
- 初始化静态`static`变量和`global`全局变量，即`.data`段的内容
- 将未初始化部分的全局变量赋初值：数值型`short`，`int`，`long`等为`0`，`bool`为`FALSE`，指针为`NULL`等等，即`.bss`段的内容
- 全局对象初始化，在`main`之前调用构造函数，这是可能会执行前的一些代码
- 将main函数的参数`argc`，`argv`等传递给`main`函数，然后才真正运行`main`函数
- `__attribute__((constructor))`

**main函数执行之后**：

- 全局对象的析构函数会在main函数之后执行；
- 可以用 **`atexit`** 注册一个函数，它会在main 之后执行;
- `__attribute__((destructor))`

> `__attribute__`是GCC编译器提供的一个扩展功能，可以用于指定变量、类型、函数等对象的属性。
>
>  **`atexit`** 注册一个函数，在main之后执行，帮助我们处理程序结束时需要做的一些事情，确保程序结束的干净利落。

## 结构体内存对齐问题？

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
- 未特殊说明时，按结构体中size最大的成员对齐（若有double成员，按8字节对齐。）

> 在实际开发中，结构体内存对齐问题非常重要，因为结构体的内存分配方式会直接影响程序的性能、可靠性以及可移植性。
>
> 1. **节省内存空间**：结构体的内存对齐可以避免内存浪费，因为缺少内存对齐可能会使结构体中每个成员的地址随意分布，导致有很多“空隙”无法使用，浪费了很多内存空间。
> 2. **提高程序性能**：结构体的内存对齐可以提高程序的性能，因为对齐可以使得结构体成员的访问变得更加快速和高效。
> 3. **保证程序的可靠性**：结构体的内存对齐可以保证程序的可靠性，因为缺少内存对齐可能会导致某些成员被错误地放置在了其它成员的地址上，从而产生“数据对齐错误”的问题。
> 4. **保证程序的可移植性**：不同的编译器可能会对结构体进行不同的内存对齐方式，造成不同的内存布局，这可能会影响程序的可移植性。因此在使用结构体时，需要根据具体项目的需求设计合适的内存对齐方式，以保证程序的可移植性。

c++11以后引入两个关键字 [alignas](https://zh.cppreference.com/w/cpp/language/alignas)与 [alignof ](https://zh.cppreference.com/w/cpp/language/alignof)。其中`alignof`可以计算出类型的对齐方式，`alignas`可以指定结构体的对齐方式。

```
#include <iostream>
 
struct Foo
{
    int   i;
    float f;
    char  c;
};
 
// 注：下面的 `alignas(alignof(long double))`
// 如果需要可以简化为  `alignas(long double)`
struct alignas(alignof(long double)) Foo2
{
    // Foo2 成员的定义...
};
 
struct Empty {};
 
struct alignas(64) Empty64 {};
 
int main()
{
    std::cout << "对齐字节数"  "\n"
        "- char                ：" << alignof(char)    << "\n"
        "- 指针                ：" << alignof(int*)     << "\n"
        "- Foo 类              ：" << alignof(Foo)      << "\n"
        "- Foo2 类             ：" << alignof(Foo2)     << "\n"
        "- 空类                ：" << alignof(Empty)    << "\n"
        "- 带 alignas(64) 的空类：" << alignof(Empty64) << "\n";
}
```

> 按照大小为4对齐方式，那么大小不足4的部分，中间会用空白填充。

## 指针和引用的区别

- 指针是一个变量，存储的是一个地址，引用跟原来的变量实质上是同一个东西，是原变量的别名
- 指针可以有多级，引用只有一级
- 指针可以为空，引用不能为NULL且在定义时必须初始化
- 指针在初始化后可以改变指向，而引用在初始化之后不可再改变
- sizeof指针得到的是本指针的大小，sizeof引用得到的是引用所指向变量的大小
- 当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用却可以。
- 引用本质是一个指针，同样会占4字节内存（32位）；指针是具体变量，需要占用存储空间（具体情况还要具体分析）。
- 引用在声明时必须初始化为另一变量，一旦出现必须为typename refname &varname形式；指针声明和定义可以分开，可以先只声明指针变量而不初始化，等用到时再指向具体变量。

## 栈和堆的区别

|                  |                              堆                              |                              栈                              |
| :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   **管理方式**   |         堆中资源由程序员控制（容易产生memory leak）          |             栈资源由编译器自动管理，无需手工控制             |
| **内存管理机制** | 系统有一个记录空闲内存地址的链表，当系统收到程序申请时，遍历该链表，寻找第一个空间大于申请空间的堆结点，删 除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中） | 只要栈的剩余空间大于所申请空间，系统为程序提供内存，否则报异常提示栈溢出。（这一块理解一下链表和队列的区别，不连续空间和连续空间的区别，应该就比较好理解这两种机制的区别了） |
|   **空间大小**   | 堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit 系统理论上是4G），所以堆的空间比较灵活，比较大 | 栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在 编译时确定，VC中可设置） |
|   **碎片问题**   |    对于堆，频繁的new/delete会造成大量碎片，使程序效率降低    | 对于栈，它是有点类似于数据结构上的一个先进后出的栈，进出一一对应，不会产生碎片。（看到这里我突然明白了为什么面试官在问我堆和栈的区别之前先问了我栈和队列的区别） |
|   **生长方向**   |                  堆向上，向高地址方向增长。                  |                  栈向下，向低地址方向增长。                  |
|   **分配方式**   |              堆都是动态分配（没有静态分配的堆）              | 栈有静态分配和动态分配，静态分配由编译器完成（如局部变量分配），动态分配由alloca函数分配，但栈的动态分配的资源由编译器进行释放，无需程序员实现。 |
|   **分配效率**   |  堆由C/C++函数库提供，机制很复杂。所以堆的效率比栈低很多。   | 栈是其系统提供的数据结构，计算机在底层对栈提供支持，分配专门 寄存器存放栈地址，栈操作有专门指令。 |

> **栈和堆哪一个更快一点？**
>
> 毫无疑问是栈快一点。
>
> 因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。
>
> 而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。

## 区别指针类型

- int *p[10]表示指针数组，强调数组概念，是一个数组变量，数组大小为10，数组内每个元素都是指向int类型的指针变量。
- int (*p)[10]表示数组指针，强调是指针，只有一个变量，是指针类型，不过指向的是一个int类型的数组，这个数组大小是10。
- int *p(int)是函数声明，函数名是p，参数是int类型的，返回值是int *类型的。
- int (*p)(int)是函数指针，强调是指针，该指针指向的函数具有int类型参数，并且返回值是int类型的。

## new / delete

二者都可以用于内存的动态申请和释放。

|            new             |                 malloc                  |
| :------------------------: | :-------------------------------------: |
|      返回该类型的指针      |       返回void\*指针,并且需要强转       |
|   先分配内存，再调用构造   |               不调用构造                |
|         delete释放         |                free释放                 |
|       C++**运算符**        | C/C++语言标准库**函数**，需要文件库支持 |
|     不需要指定内存大小     |           指定分配内存的大小            |
|  new作为操作符可以被重载   |               不可以重载                |
| 从自由存储区为对象分配内存 |             从堆区分配内存              |

- 通过new开辟数组，**一定会调用默认构造函数，所以一定要提供默认构造函数。在自定义有参构造函数后，系统不会默认提供，要手动添加。**
- new是封装了malloc，直接free不会报错，但是这只是释放内存，而不会析构对象。new和delete除了分配回收功能外，还会调用构造函数和析构函数。
- 在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free，所以new/delete是必不可少的。
- 释放数组要中括号，告知有多个对象需要释放。`delete[] p;`这样才能调用多次的析构函数，否则只调用一次析构函数，造成内存的泄露。
- 被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。

> new：先分配memory，再调用ctor（构造）
>
> delete：先调用dtor（析构），再释放memory

## 宏定义和函数有何区别

- 宏在预处理阶段完成替换，之后被替换的文本参与编译，相当于直接插入了代码，运行时不存在函数调用，执行起来更快；函数调用在运行时需要跳转到具体调用函数。
- 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值。
- 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
- 宏定义不要在最后加分号。

## 宏定义和typedef区别？

- 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。
- 宏替换发生在编译阶段之前，属于文本插入替换；typedef是编译的一部分。
- 宏不检查类型；typedef会检查数据类型。
- 宏不是语句，不在在最后加分号；typedef是语句，要加分号标识结束。
- 注意对指针的操作，`typedef char * p_char`和`#define p_char char *`区别巨大。

## 变量声明和定义区别？

- 声明仅仅是把变量的声明的位置及类型提供给编译器，并**不分配内存空间**；定义要在**定义的地方为其分配存储空间。**
- 相同变量可以在多处声明（外部变量extern），但只能在一处定义。

## strlen和sizeof区别？

- sizeof是运算符，并不是函数，结果在编译时得到而非运行中获得；strlen是字符处理的库函数。
- sizeof参数可以是任何数据的类型或者数据（sizeof参数不退化）；strlen的参数只能是字符指针且结尾是`'\0'`的字符串。
- 因为sizeof值在编译时确定，所以不能用来得到动态分配（运行时分配）存储空间的大小。

## 一个指针占多少字节？

在16题中有提到sizeof（str）的值为8，是在64位的编译环境下的，指针的占用大小为8字节；

而在32位环境下，指针占用大小为4字节。

**一个指针占内存的大小跟编译环境有关，而与机器的位数无关。**

## 常量指针和指针常量区别？

- 指针常量是一个指针，读成常量的指针，指向一个只读变量，也就是后面所指明的`int const` 和` const int`，都是一个常量，可以写作`int const *p`或`const int *p`。
- 常量指针是一个不能给改变指向的指针。指针是个常量，必须初始化，一旦初始化完成，它的值（也就是存放在指针中的地址）就不能在改变了，即不能中途改变指向，如`int *const p`。

## C++中struct和class的区别

**相同点**

- 两者都拥有成员函数、公有和私有部分
- 任何可以使用class完成的工作，同样可以使用struct完成

**不同点**

- 两者中如果不对成员不指定公私有，struct默认是公有的，class则默认是私有的
- class默认是private继承， 而struct默认是public继承

**引申**：C++和C的struct区别

- C语言中：struct是用户自定义数据类型（UDT）；C++中struct是抽象数据类型（ADT），支持成员函数的定义，（C++中的struct能继承，能实现多态）
- C中struct是没有权限的设置的，且struct中只能是一些变量的集合体，可以封装数据却不可以隐藏数据，而且成员**不可以是函数**
- C++中，struct增加了访问权限，且可以和类一样有成员函数，成员默认访问说明符为public（为了与C兼容）
- struct作为类的一种特例是用来自定义数据结构的。一个结构标记声明后，在C中必须在结构标记前加上struct，才能做结构类型名（除：typedef struct class{};）;C++中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体struct在C++中被当作类的一种特例
