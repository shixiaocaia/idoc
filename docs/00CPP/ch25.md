Effective C++
===

## 尽量替换 \#define

尽量以const，enum，inline替换 \#define。

`#define AspectRatio 10`会在编译时，大量用10替换AspectRatio，而编译器并不知道。

而使用`const int AspectRatio = 10`，避免了重复的替换，可能会导致较小的代码量。

而且在类中常量，也不可以使用`#define`进行定义，在类中我们一般使用`const`进行定义一个常量。

```cpp
class test{
    private:
    	static const double pi; //static class常量在class中声明
    ...
};

const double test:: pi = 3.14;  //在实现文件中定义
```

如果坚持在编译期间使用一个常量作为数组的大小，可以通过使用`enum`定义一个常量来使用。

```cpp
class test{
    private:
    	enum {Num = 5};
    	int scores[Num];
    ...
};

const double test:: pi = 3.14;  //在实现文件中定义
```

对于形似函数的宏，最好改用`inline`函数替换`#define`。

## 尽可能使用const

如果const出现在星号左边，表示被指物为常量；

如果const出现在星号右边，表示指针本身为常量；

如果出现在两侧，表示二者都是常量。

```cpp
std::vector<int> vec;

const std::vector<int>::iterator iter = vec.begin(); //iter的作用是一个T* const
//指针本身是一个常量，不可以移动

std::vector<int>::const_iterator iter = vec.begin(); //iter的作用是一个const T*
//被指物是一个常量，不可改变
```

函数名后加const，表示函数的成员对象不可以改变。

> 部分变量确定可以更改，可以增加`mutable`关键字修饰。

当const和non-const成员函数有着实质等价的实现时，令non-const调用const会避免代码的重复，设计部分的**转型动作**。

## 确定对象使用前已初始化

 尽量在使用前，初始化定义的变量。

对于class中的对象，初始化任务交给构造函数，但是如果在进入构造函数中进行，那是先调用了`default`构造，然后再赋予指定的值，实际当中应该采用**初始化列表**的方式，进行copy构造，提高了效率。

初始化列表的构造顺序是根据变量声明的顺序，因此尽可能按照声明的顺序进行列表初始化更加优雅。

对于**const和reference**一定需要初值，而不是赋值。

对于**non-local static**对象（非在函数内的static对象），应该以local static对象替换，即通过调用函数生成local static然后返回引用，这样保证了static变量在使用时一定经过了初始化，而non-local static对象是随意经过初始化的，对初始化的顺序没有明确的定义。

## C++默认编写调用了哪些函数

当创建空类时，编译器会默认创建default构造函数，copy构造函数，copy assignment操作符，以及析构函数。

> 当我们创建了构造函数时，默认构造函数不会生成。
>
> 当成员具有reference或者const时，编译器拒绝生成`operator=`。

## 拒绝编译器自动生成的函数

由编译器自动生成的函数是`public`的，因此我们可以将不需要的copy构造函数定义为`private`，并且故意不定义，这样可以阻止函数的生成。

```cpp
class test{
public:
    test();
    ~test();
private:
    test(const test&);
    test& operator=(const test&);
}
```

从而避免了一些实例的拷贝、赋值操作。

## 为多态基类声明virtual析构函数

具有多态性质的class，一般在有virtual构造函数时，会再定义一个virtual析构函数。

这样会避免”局部销毁“的问题，即当一个derived class被base class析构时可能造成的未被完全销毁问题。

当然这不代表可以随意将函数声明为virtual。

## 别让异常逃离析构函数

析构函数如果抛出异常，应该捕捉异常，然后吞下异常（不处理）或者结束程序。

如果客户需要对某个操作函数运行期间抛出的异常处理，那么class应该提供一个普通函数执行该操作。 

## 绝不在构造函数和析构函数中调用virtual函数

在创建一个子类时，首先调用的是base的构造函数函数，而如果base的构造函数中调用了纯虚函数，而此时子类的虚函数还未定义，就会抛出错误。

如果父类中定义的只是虚函数，那么可能造成函数调用错误（是父类还是子类的）。

总结，这是由于构造函数和析构函数的发生顺序造成的问题。

> 在这里侯捷提出了在用辅助函数替代初始化列表，效率更高。
