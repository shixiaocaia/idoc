Effective C++
===

## 尽量替换 \#define

尽量以const，enum，inline替换 \#define。

`#define AspectRatio 10`会在编译时，大量用10替换AspectRatio，而编译器并不知道。

而使用`const int AspectRatio = 10`，避免了重复的替换，可能会导致较小的代码量。

而且在类中常量，也不可以使用`#define`进行定义，在类中我们一般使用`const`进行定义一个常量。

```c++
class test{
    private:
    	static const double pi; //static class常量在class中声明
    ...
};

const double test:: pi = 3.14;  //在实现文件中定义
```

如果坚持在编译期间使用一个常量作为数组的大小，可以通过使用`enum`定义一个常量来使用。

```c++
class test{
    private:
    	enum {Num = 5};
    	int scores[Num];
    ...
};

const double test:: pi = 3.14;  //在实现文件中定义
```

对于形似函数的宏，最好改用`inline`函数替换`#define`。

## 尽可能使用const

如果const出现在星号左边，表示被指物为常量；

如果const出现在星号右边，表示指针本身为常量；

如果出现在两侧，表示二者都是常量。

```c++
std::vector<int> vec;

const std::vector<int>::iterator iter = vec.begin(); //iter的作用是一个T* const
//指针本身是一个常量，不可以移动

std::vector<int>::const_iterator iter = vec.begin(); //iter的作用是一个const T*
//被指物是一个常量，不可改变
```

函数名后加const，表示函数的成员对象不可以改变。

> 部分变量确定可以更改，可以增加`mutable`关键字修饰。

当const和non-const成员函数有着实质等价的实现时，令non-const调用const会避免代码的重复，设计部分的**转型动作**。

## 确定对象使用前已初始化

 尽量在使用前，初始化定义的变量。

对于class中的对象，初始化任务交给构造函数，但是如果在进入构造函数中进行，那是先调用了`default`构造，然后再赋予指定的值，实际当中应该采用**初始化列表**的方式，进行copy构造，提高了效率。

初始化列表的构造顺序是根据变量声明的顺序，因此尽可能按照声明的顺序进行列表初始化更加优雅。

对于**const和reference**一定需要初值，而不是赋值。

对于**non-local static**对象（非在函数内的static对象），应该以local static对象替换，即通过调用函数生成local static然后返回引用，这样保证了static变量在使用时一定经过了初始化，而non-local static对象是随意经过初始化的，对初始化的顺序没有明确的定义。
