Effective C++
===

## 尽量替换 \#define

尽量以const，enum，inline替换 \#define。

`#define AspectRatio 10`会在编译时，大量用10替换AspectRatio，而编译器并不知道。

而使用`const int AspectRatio = 10`，避免了重复的替换，可能会导致较小的代码量。

而且在类中常量，也不可以使用`#define`进行定义，在类中我们一般使用`const`进行定义一个常量。

```cpp
class test{
    private:
    	static const double pi; //static class常量在class中声明
    ...
};

const double test:: pi = 3.14;  //在实现文件中定义
```

如果坚持在编译期间使用一个常量作为数组的大小，可以通过使用`enum`定义一个常量来使用。

```cpp
class test{
    private:
    	enum {Num = 5};
    	int scores[Num];
    ...
};

const double test:: pi = 3.14;  //在实现文件中定义
```

对于形似函数的宏，最好改用`inline`函数替换`#define`。

## 尽可能使用const

如果const出现在星号左边，表示被指物为常量；

如果const出现在星号右边，表示指针本身为常量；

如果出现在两侧，表示二者都是常量。

```cpp
std::vector<int> vec;

const std::vector<int>::iterator iter = vec.begin(); //iter的作用是一个T* const
//指针本身是一个常量，不可以移动

std::vector<int>::const_iterator iter = vec.begin(); //iter的作用是一个const T*
//被指物是一个常量，不可改变
```

函数名后加const，表示函数的成员对象不可以改变。

> 部分变量确定可以更改，可以增加`mutable`关键字修饰。

当const和non-const成员函数有着实质等价的实现时，令non-const调用const会避免代码的重复，设计部分的**转型动作**。

## 确定对象使用前已初始化

 尽量在使用前，初始化定义的变量。

对于class中的对象，初始化任务交给构造函数，但是如果在进入构造函数中进行，那是先调用了`default`构造，然后再赋予指定的值，实际当中应该采用**初始化列表**的方式，进行copy构造，提高了效率。

初始化列表的构造顺序是根据变量声明的顺序，因此尽可能按照声明的顺序进行列表初始化更加优雅。

对于**const和reference**一定需要初始化，而不是赋值。

对于**non-local static**对象（非在函数内的static对象），应该以local static对象替换，即通过调用函数生成local static然后返回引用，这样保证了static变量在使用时一定经过了初始化，而non-local static对象是随意经过初始化的，对初始化的顺序没有明确的定义。

## C++默认编写调用了哪些函数

当创建空类时，编译器会默认创建default构造函数，copy构造函数，copy assignment操作符，以及析构函数。

> 当我们创建了构造函数时，默认构造函数不会生成。
>
> 当成员具有reference或者const时，编译器拒绝生成`operator=`。

## 拒绝编译器自动生成的函数

由编译器自动生成的函数是`public`的，因此我们可以将不需要的copy构造函数定义为`private`，并且故意不定义，这样可以阻止函数的生成。

```cpp
class test{
public:
    test();
    ~test();
private:
    test(const test&);
    test& operator=(const test&);
}
```

从而避免了一些实例的拷贝、赋值操作。

## 为多态基类声明virtual析构函数

具有多态性质的class，一般在有virtual构造函数时，会再定义一个virtual析构函数。

这样会避免”局部销毁“的问题，即当一个derived class被base class析构时可能造成的未被完全销毁问题。

当然这不代表可以随意将函数声明为virtual。

## 别让异常逃离析构函数

析构函数如果抛出异常，应该捕捉异常，然后吞下异常（不处理）或者结束程序。

如果客户需要对某个操作函数运行期间抛出的异常处理，那么class应该提供一个普通函数执行该操作。 

## 绝不在构造函数和析构函数中调用virtual函数

在创建一个子类时，首先调用的是base的构造函数函数，而如果base的构造函数中调用了纯虚函数，而此时子类的虚函数还未定义，就会抛出错误。

如果父类中定义的只是虚函数，那么可能造成函数调用错误（是父类还是子类的）。

总结，这是由于构造函数和析构函数的发生顺序造成的问题。

> 在这里侯捷提出了在用辅助函数替代初始化列表，效率更高。

## 令operator=返回一个reference to *this

这样有利于实现连锁赋值，但这不是强制性。

```cpp
x = y = z = 15;

Widget& operator+=(const Widget& rhs){
    ...
    return *this;
}
```

## 在operator= 中处理“自我赋值”

确保this和传参的变量不是同一个变量，避免异常安全性。

```cpp
Widget& Widget::operator=(const Widget& rhs){
    if(this == &rhs) return *this;
    
    delete pb;
    pb = new Bitmapp(*rhs.pb);
    return *this;
}
```

这样避免了`delete pb`时，由于`rhs`指向同一个地址，销毁错内容。

确定任何函数如果操作一个以上的对象，而其中多个对象是同一个对象时，确保其行为是正确的。

## 复制对象时勿忘每一个成分

一个derived class的构造函数，在你自定义自己的copy构造函数之后，进行初始化时少了一部分初始化，编译器不太会报错，不会主动把子类的部分成员属性复制给父类进行构造。

我们应该主动调用父类的copy构造函数，初始化列表一部分子类的变量，以此确保复制“对象内的所有成员变量”和“所有base class成分”。

也不应该在copy构造中调用operator=。

## 以对象管理资源（RAII）

尽量在创建对象时就移动到管理类当中。

当一块已经申请的内存空间，由于函数内过早的return，或者在循环内过早的退出，或者由于异常函数的抛出，导出没有及时的delete，会造成内存泄漏等一些列问题。

由此引出，我们应该尽量将资源放入对象中，依赖C++的析构函数来自动释放，确保资源被释放。

在这其中智能指针就是一个很好的例子，但是智能指针在析构函数内并不能做`delete[]`动作。

## 在资源管理类中小心copying行为

- 复制RAII对象必须一并复制它所管理的资源，所以资源得copying行为决定了RAII对象的copying行为。

> 大部分时候，允许RAII对象被复制并不合理。

- 普通而常见得RAII class copying行为是：抑制copying、施行引用计数法。

 **禁止复制**

假设我们现在有一个互斥器Mutex，用来保证多线程安全。对互斥器加锁，则互斥器所关联的临界资源就无法被其他线程访问。当使用结束以后需要解锁，释放互斥器。

这里我们设计了一个Lock类用来管理互斥器这个资源。在它的构造函数中对互斥器加锁，析构函数中解锁。

设想一下我们要复制Lock对象，会发生什么？一个Lock对象管理Mutex，现在我们试图复制Lock，就表明我们又要用另一个Lock对象管理同一个Mutex，这显然不合理。一个互斥器仅需要也仅能够被一个Lock对象管理，因为不可以对同一个Mutex加两次锁。所以这里我们需要拒绝复制行为。

**对底层资源使用引用计数**

现在让我们回到智能指针上面来。假设我们new了一块动态内存，并用一个智能指针来保存，在智能指针的析构函数中释放这块内存。现在我们需要另一个智能指针也指向这块内存，这是非常常见的事情。一个对象当然可以被多个指针引用，所以这里我们无法拒绝禁止复制这一操作。

但如果不禁止的话，一个智能指针生命期结束了就会调用析构函数释放内存。而另一个指针指向的就是一块被释放的内存。这也是非常严重的错误。

我们可以引入引用计数法。也就是直到最后一个智能指针被销毁，我们才释放这块内存资源。

**复制底层资源**

这就属于深拷贝了，我们不仅复制了一个资源管理对象，底层的资源也复制了一份。这两个资源管理对象和底层资源就是互不干扰的，各自负责管理各自的资源。

**转移底部资源的拥有权**

相当于移交管理权。之前的那个资源管理对象就不负责管理这块资源了。unique_ptr就属于这种，一个unique_ptr对象在被赋值后，原始的对象会将指针置为空。

## 以独立语句将newed对象置入智能指针

这样可以避免编译器任意的选择顺序。否则一旦异常抛出，而new出的对象没有放入智能指针当中，会造成内存的泄漏。

> 这里都抛出异常了，不能直接处理吗，或者终止程序。

## 让接口容易被使用，不易被误用

比如在涉及类接口时，传入参数到构造函数当中，是否合法，比如传入参数含义是month，传入13是非法的。

以函数替换对象更加有效。

使用智能指针指定删除器问题。

## 值传递和引用传递

值传递带来了巨大的构造和析构对象，考虑到如果复制一个stuent类，同时student又继承了person，内部又有string等，代价巨大。因此提倡使用引用传递。

另一方面在使用引用传递可以避免参数的切割，比如以值传递传入的是A对象，但是B函数形参定义的类型是B，A以值传入会转换成B形式，造成参数的切割。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
