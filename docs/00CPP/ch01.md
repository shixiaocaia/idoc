## 条件编译

```cpp
#ifdef P
cout << "test" << endl;
#endif

g++ -DP p1.cpp -o test
```

## enum使用

   > ```cpp
   > enum week {Sun, Mon, Tue, Wed, Thu, Fri, Sat};
   > //默认从Sun = 0 开始，逐个加1
   > 
   > enum week {Sun=7, Mon=1, Tue, Wed, Thu, Fri, Sat};
   > //枚举常量Sun,Mon,Tue,Wed,Thu,Fri,Sat的值分别为7、1、2、3、4、5、

## 左值和右值

在C++11中可以取地址的、有名字的就是左值，反之，不能取地址的、没有名字的就是右值。

**左值引用、右值引用**

> 左值引用就是对一个左值进行引用的类型。
>
> 右值引用就是对一个右值进行引用的类型，事实上，由于右值通常不具有名字，我们也只能通过引用的方式找到它的存在。
>
> 右值引用和左值引用都是属于引用类型，并且都是左值,且都必须初始化。

```cpp
int &a = 2; //通常左值引用不能绑定到右值

//常量左值引用是个“万能”的引用类型。它可以接受非常量左值、常量左值、右值对其进行初始化。
int b = 2;        # 非常量左值
const int &c = b; # 常量左值引用绑定到非常量左值，编译通过
const int d = 2;  # 常量左值
const int &e = c; # 常量左值引用绑定到常量左值，编译通过
const int &b =2;  # 常量左值引用绑定到右值，编程通过
```

```cpp
//&&右值值引用通常不能绑定到任何的左值，要想绑定一个左值到右值引用，通常需要std::move()将左值强制转换为右值
int a;
int &&r1 = c;             # 编译失败
int &&r2 = std::move(a);  # 编译通过
```

## 静态成员变量

- 所有对象共享一个静态数据，修改值，会全局修改所有对象的这个值。
- 静态变量，是在编译阶段就分配空间，对象还没有创建时，就已经分配空间。
- 在类中声明，在类外定义。
- 可以在类外直接定义，但是不能够直接访问。

## 静态成员函数

- 静态成员函数使用方式和静态变量一样，同样在对象没有创建前，即可通过类名调用。也可以通过对象调用。
- 静态成员函数主要为了访问静态变量，不能访问普通成员变量。
- 如果一个类的成员，既要实现共享，又要实现不可改变，那就用 static const 修饰。定义静态const数据成员时，最好在类内部初始化。
- 没有this指针。
