## 概述

- HTTP是无状态的协议，不对之前的响应和请求做持久化处理。

## ARP协议

**ARP协议凭借MAC地址进行通信**

> 通常是经过多台计算机和网络设备中转连接到不同的设备，而在进行中转时，利用下一站设备的MAC地址来搜索下一个中转目标。
>
> ARP协议是一种利用解析地址的协议，根据通信方的IP地址能查到对方的MAC地址。
>
> 在这样的传输过程中，网络设备获得到的是模糊地址。

## URI 和URL

我们要找一个人——张三，我们可以通过他的唯一的标识来找，比如说身份证，那么这个身份证就唯一的标识了一个人，这个身份证就是一个 URI；

而要找到张三，我们不一定要用身份证去找，我们还可以根据地址去找，如 在清华大学18号宿舍楼的404房间第一个床铺的张三，我们也可以唯一确定一个张三，

动物住址协议://地球/中国/北京市/清华大学/18号宿舍楼/404号寝/张三人。而这个地址就是我们用于标识和定位的 URL。

我们从上面可以很明显的看出，**URI 通过任何方法标识一个人即可，如身份证**，而 URL 虽然也可以标识一个人，但是它主要是**通过定位地址的方法标识一个人**，所以 URL 其实是 URI 的一个子集，即 URL 是靠标识定位地址的一个 URI。

---

### URI

统一资源标识符(Uniform Resource Identifier, URI)：是一个用于标识某一互联网资源名称的字符串。

![image-20221119140945077](D:\Code\Typorapic\202211191410691.png)

### URL

统一资源定位符(Uniform Resource Locator, URL)：是一个用于标识和定位某一互联网资源名称的字符串。                                                                                                                                                                       

![image-20221119141215824](http://pic.shixiaocaia.fun/202301301046042.png)

## 告知服务器意图

### GET：获取资源

用来请求访问已被URI识别的资源。指定的资源经服务器解析后返回响应的内容。

### POST：传输实体主体

GET也可以传输实体的主体，但一般不用。

POST的主要目的并不是获取响应的主体内容。

### PUT：传输文件

PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请 求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。

> 鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若 配合 Web 应用程序的验证机制，或架构设计采用 REST（REpresentational State Transfer，表征状态转移）标准的同类
> Web 网站，就可能会开放使用 PUT 方法。

### HEAD：获得报文首部

HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 URI 的有效性及资源更新的日期时间等。

### DELETE：删除文件

DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 请求 URI 删除指定的资源。

> 但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。

### OPTIONS：询问支持的方法

OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

### TRACE：追踪路径

TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方法。

> 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服 务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最后接收到请求的服务器端则返回状态码 200 OK 的响应。
>
> 客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 / 篡改的。
>
> 容易引起跨站追踪，通常不使用。

### CONNECT：要求用隧道协议连接代理

CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

## 下达命令

<img src="http://pic.shixiaocaia.fun/202301301046091.png" alt="image-20221119152430611" style="zoom:50%;" />

- 注意区分方法大小写，以及HTTP协议支持的版本。

## 持久连接

HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。

因此，每次的请求都会造成无谓的 TCP 连接建立和断 开，增加通信量的开销。

为解决上述 TCP 连接的问题，HTTP/1.1 和一部分的 HTTP/1.0 想出了 持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。

> 在 HTTP/1.1 中，所有的连接默认都是持久连接，但在 HTTP/1.0 内并 未标准化。

## 管线化

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。

管线化是指不用等待响应可以发送下一个请求。这样可以同时并行发送多个请求，而不需要一个接一个等待响应。

## 使用Cookie的状态管理

HTTP 是**无状态**协议，它不对之前发生过的请求和响应的状态进行管 理。也就是说，无法根据之前的状态进行本次的请求处理。

> 无状态，由于不保存状态，减少的服务器的CPU和内存资源消耗，并且简单，因此被广泛使用。

保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入 了 Cookie 技术。

Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。

Cookie 会根据从服务器端发送的响应报文内的一个叫做 **Set-Cookie** 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。

服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

## Q：GET和POST区别

