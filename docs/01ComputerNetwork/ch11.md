HTTP常见的问题
===

## 是什么

HTTP 是超文本传输协议，也就是HyperText Transfer Protocol。

可以拆分成三部分：

- 超文本：现如今的「超文本」，包括了图片、文字、视频等，最关键还有超链接。
- 传输：HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范，两点之间有任意的中继。
- 协议：HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范（两个以上的参与者），以及相关的各种控制和错误处理方式（行为约定和规范）。

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

### 常见的状态码

![ 五大类 HTTP 状态码 ](../../img/202303301107244.png)

### 常见字段

- connection中的`keep-live`和TCP中的`keepalive`的区别

## GET和POST

### GET

- 一般GET 的语义是从服务器获取指定的资源，包括文本、视频、页面等多个资源
- GET一般写在url中，浏览器会对url的长度有限制

### POST

- POST 的语义是根据请求负荷（报文body）对指定的资源做出处理。
- POST 请求携带数据的位置一般是写在报文 body 中，body中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。

### 对比

- 一般情况下，安全和幂等关系，是否可以缓存
  - 安全：不会破坏服务器资源
  - 幂等：多次执行相同的操作，结果都是相同的
  - 因此一般情况下，GET方法只读所以是安全和幂等的，POST方法会提交和修改数据是不安全和不幂等的。
  - 实际中GET方法用于新增和修改数据就可能是不安全不幂等的，同理POST请求也是。
- GET请求可以带上body吗
  - 任何请求都可以用上body，只是GET请求获取资源用不上body
  - 同理，URL查询不是GET独有的，POST请求中URL也有参数

## 缓存原理

对重复性的HTTP请求，每次得到数据都一样时，把[请求 + 缓存]放在本地，下次直接读取本地数据。

HTTP 协议的头部有不少是针对缓存的字段，实现缓存技术都要用到`Cache-control`和`expires`来判断缓存的过期情况。

在第一次发送请求报文后，服务器在响应报文当中标注了`cache-control`，当报文过期后，向服务器发送请求时，会更新`cache-control`。

![img](../../img/http缓存.png)

### 强制缓存

浏览器判断缓存有没有过期，没有过期会直接使用本地缓存，决定权在浏览器。

- 强缓存是利用了`Cache-Control`相对时间和`Expires`相对时间来判断资源在客户端的有效期
- 如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，**Cache-Control 的优先级高于 Expires** 

### 协商缓存

浏览器判断过期的报文是否发生变更，通过本地缓存当中的`Last-Modified`和`ETag`两种标签判断。

如果没有变更，会发送`304`报文告知客户端可以使用本地缓存，否则返回200有更新返回最新的资源，同时更新的标签值。

### 为什么ETag与优先级更高

1. 在没有修改文件内容情况下文件的最后修改时间可能也会改变，这会导致客户端认为这文件被改动了，从而重新请求，因此`Last-Modified`基于修改时间的方式不够准确。
2. 可能有些文件是在秒级以内修改的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；
3. 有些服务器不能精确获取文件的最后修改时间。

### 整体流程

当使用 ETag 字段实现的协商缓存的过程：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 ETag 唯一标识，这个唯一标识的值是根据当前请求的资源生成的；

- 当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期：

  - 如果没有过期，则直接使用本地缓存；
  - 如果缓存过期了，会在 Request 头部加上 If-None-Match / If-Modified-Since字段，该字段的值就是 ETag /  Last-Modified唯一标识；

- 服务器再次收到请求后，

  会根据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较

  - **如果值相等，则返回 304 Not Modified，不会返回资源**；
  - 如果不相等，则返回 200 状态码和返回资源，并在 Response 头部加上新的 ETag 唯一标识；

- 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

## HTTP特性

### HTTP 1.1优缺点

- 简单：HTTP 基本的报文格式就是 `header + body`，易于理解，降低了学习和使用的门槛
- 灵活和易于扩展：请求字段和结构没有固定死，可以灵活设置
- 应用广泛和跨平台
- 无状态：服务器不会记忆HTTP的状态，进行关联性操作时要反复判断，但也节省了存储信息的负担，解决办法：Cooki技术
- 明文传输：方便阅读，便于抓包调试，但是信息容易被窃取
- 不安全：明文传输，不验证通信方的身份，无法证明报文的完整新，主要通过HTTPS解决

## HTTP与HTTPS

### 区别

|        HTTP        |                     HTTPS                      |
| :----------------: | :--------------------------------------------: |
|   超文本传输协议   |                 超文本传输协议                 |
|      明文传输      | 加密传输（TCP和HTTP之间加入了SSL/TLS安全协议） |
| 三次握手后开始传输 |             增加SSL/TLS的握手过程              |
|   默认端口号：80   |                默认端口号：443                 |
|     不需要证书     |       需要CA（证书权威机构）申请数字证书       |

### HTTPS如何解决了HTTP问题

在TCP/HTTP之间增加了SSL/TLS协议，解决了明文传输过程中的窃听风险、篡改风险、冒充风险问题。

#### 混合加密

为了解决信息被窃听的问题，HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式，使得未经的解密的其他用户只能看到密文。

一般将加密算法分为：

- **对称加密**加密和解密使用同一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。
- **非对称加密**使用两个不同的密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

> 使用对称加密前提是通信双方商量出一个密钥，在这个过程中是传输明文，容易被窃取。
>
> 所以有了非对称加密，公钥被窃取时，通过公钥加密的报文，只能被私钥解密。

综合考虑到可靠性和速度，HTTPS采用混合加密方式。

也就是说，**用非对称加密算法传输密钥，用对称加密算法传输实际数据。** 此密钥一般称为`『会话密钥』`。

> 黑客窃取到会话密钥，但是没有私钥解密，以至于在后续无法解密对称加密的数据。

#### 摘要算法

为了保证传输的内容不被更改，计算出要发送内容的一个摘要，接受报文后再计算一遍，对比前后的值是否发生改变来判断内容是否被篡改。

在计算机里会用摘要算法（**哈希函数**）来计算出内容的哈希值，也就是内容的「指纹」，这个哈希值是唯一的，且无法通过哈希值推导出内容。

> 计算机网络中常用的摘要算法有：MD5、SHA-1、SHA-256 等。

但是在这个过程中不能保证整个内容和哈希值都被篡改，需要确保内容 + 哈希值都是原始发送的内容。

增加了一个**鉴别密钥**，获取方式等同于会话密钥，摘要算法的输入变为数据+鉴别密钥，在经过篡改后的数据，另一端收到后会发现解密后鉴别密钥变更，被篡改了。

> 为了进一步提升安全性，实际上客户端和服务器将使用不同的`会话密钥`和`鉴别密钥`，也就是一共需要四个密钥：
>
> 1. 用于从客户端发送到服务器的数据的`会话密钥`；
> 2. 用于从服务器发送到客户端的数据的`会话密钥`；
> 3. 用于从客户端发送到服务器的数据的`鉴别密钥`；
> 4. 用于从服务器发送到客户端的数据的`鉴别密钥`。

#### 数字证书

万一服务器的公钥是被黑客伪造的呢？比如经典的『中间人攻击』问题，这里有点复杂具体可以看[原文](https://www.cnblogs.com/yifeng-coding/p/17031677.html)。

为了避免客户端收到了非正规的网站（中间人），需要一个数字证书。

通过数字证书解决中间人攻击的具体过程为：

- 服务器（正规网站）首先生成一对公钥和私钥，然后将域名、申请者、公钥（注意不是私钥，私钥是无论如何也不能泄露的）等信息整合在一起，生成 .csr 文件，并将此文件发给认证中心 CA。
- CA 收到申请后，会通过各种手段验证申请者的信息，如无异常，则使用摘要算法得到 .csr 中明文信息的一个摘要，再用 CA 自己的`私钥`对这个摘要进行加密，生成一串密文，密文也称为数字签名。数字证书即包含此数字签名和 .csr 中明文信息。CA 把这个证书返回给申请人。
- 为了防止中间人攻击，客户端要求服务器发送其证书，并进行验证。
- 客户端在验证证书时，把证书里的签名与及明文信息分别取出来，然后会用自身携带的 CA 机构的`公钥`去解密签名，得到摘要 1，再利用摘要算法得到明文信息的摘要 2，对比摘要 1 和摘要 2，如果一样，说明证书是合法的，也就是证书里的公钥是正确的，否则说明证书不合法。

> 这里明文信息的摘要2，是可能被篡改的部分，而通过CA公钥解密得到的信息摘要是明确的。
>
> 此外认证中心的公钥，一般在操作系统中会内置这些，避免公钥被伪造。
>
> Chrome 浏览器一旦发现一个网站数字证书无效，就会生成如下界面进行提示，如果用户强制访问，则存在一定的风险。（那我经常点开...

## HTTPS连接建立

根据前面所述，进行一下小结：

- HTTPS 通过混合加密算法解决 HTTP 传输数据容易被窃听的问题，此过程需要协商`会话密钥`。
- HTTPS 通过摘要算法解决 HTTP 传输数据容易被篡改的问题，此过程需要协商`鉴别密钥`。
- HTTPS 通过数字证书解决 HTTP 协议中身份容易被伪造的问题，此过程需要客户端验证服务器的`证书`。

通信双方在SSL / TLS协议握手的时候，来协商会话密钥和鉴别密钥，以及验证证书的合法性。

![HTTPS 连接建立过程](../../img/23-HTTPS工作流程.png)

- 为什么第三、第四次握手要发送所有握手报文的摘要呢？

  > 主要原因是**防止握手信息被篡改**。比如客户端支持的密码套件列表中，有些加密算法较弱，有些加密算法较强，而此密码套件是明文传输的，万一黑客将此密码套件列表进行了修改，只留下一些安全性较低的加密算法，那么服务器就只能从这些安全性较低的加密算法中选择，安全性大大降低。因此需要通过发送摘要的形式防止握手信息被篡改。

- 为什么不直接发送一个主密钥，而是用两个随机数加一个前主密钥重新生成一个主密钥呢？

  > 主要原因是**防止连接重放**。如果没有前面两个随机数，仅仅由客户端生成一个主密钥，并通过服务器`公钥`加密发送给服务器。那么黑客在嗅探了服务器与客户端之间的所有报文后，可以再次冒充客户端向服务器发送相同的报文（虽然黑客不知道内容是什么），因为报文信息都是之前客户端和服务器验证过的，因此服务器会认为是客户端与其通信，导致又一次连接。

整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

### 客户端校验数字证书的流程是怎样的？

> 小林coding

## HTTPS 的应用数据是如何保证完整性的？



## HTTPS 一定安全可靠吗？





## HTTP/1.1、HTTP/2、HTTP/3 演变

### HTTP/1.1

- 对比1.0 增加了长连接方式，改善了性能开销
- 支持管道传输（但是一般浏览器并不支持

### HTTP/2

- 头部压缩（1.1只能压缩body）：如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**。
- 二进制格式：头信息和数据体都是二进制，并且统称为帧（frame），计算机可以解析和传输报文信息，并不需要转码操作。
- 并发传输：在1.1中基于请求-响应报文，完成一个请求与响应，才能处理响应下一个，但是如果中途有一个阻塞，那么会造成后续的断发。在2.0当中引入Stream概念，多个Stream复用在一条TCP连接当中。
- 服务器主动推送资源：客户端和服务器**双方都可以建立 Stream**，传输消息。比如在1.1当中html和css分别作请求和响应，在2.0服务端可以主动推送需要的css进行渲染。

> 但是2.0虽然通过Stream的并发解决了1.0的队头阻塞问题，但是基于TCP实现的面向字节流，当一个报文的前1个字节延迟到达时，其他字节存放在缓冲区，全部到达后应用层才能从内核当中拿到数据。

### HTTP/3

- 1.1通过stream解决了请求的队头阻塞，但是没有解决响应的队头阻塞。
- 2通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是一旦发生丢包，就会阻塞住所有的 HTTP 请求，这属于 TCP 层队头阻塞。

HTTP/3把下层的TCP协议改成了UDP。

UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输。

QUIC 有以下 3 个特点。

- 无队头阻塞：某个流发生丢包时，只会阻塞这个流，不会影响其他的。
- 更快的连接建立：需要 QUIC 协议握手，但是这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。
- 连接迁移

