## 运输层概述

运输层作为OSI体系结构自下而上的第四层，其主要任务是为相互通信的应用进程提供逻辑通信服务，为运行在不同主机上的应用进程提供直接的逻辑通信服务。

> 上一层网络层提供主机之间的逻辑通信，实现主机到主机。
>
> 然而在计算机网络中实际进行通信的真正实体是位于通信两端主机的进程。

运输层的协议又称为端到端的协议，因为运输层的作用范围是应用进程到应用进程。

运输层向应用层实体屏蔽了下面网络核心的细节（例如网络拓扑、所采用的路由选择协议等），它使应用进程看见的就**好像是在两个运输层实体之间有一条端到端的逻辑通信信道。**

根据应用需求的不同，因特网的运输层为应用层提供了两种不同的运输层协议，即面向连接的TCP和无连接的UDP。

> 在网络层，网络层为主机提供逻辑通信服务，是一种尽最大努力的数据报服务，可能会出现各种错误，但是对于实时性要求高的服务，这是可以忽略的。
>
> 而对于电子邮件、文件传输等需要可靠传输通信的服务，需要使用TCP/ IP体系结构的运输层太提供可靠服务。

### 用户数据报协议 UDP

用户数据报协议(User Datagram Protocol,UDP)为其上层提供的是**无连接**的**不可靠**的数据传输服务。

使用UDP通信的双方，在传送数据之前不需要建立连接。

UDP不需要实现可靠传输，因此不需要使用实现可靠传输的各种机制。

UDP的实现简单，UDP用户数据报的首部比较小。

### 传输控制协议 TCP

传输控制协议(Transmission Control Protocol,,TCP)为其上层提供的是**面向连接**的**可靠**的数据传输服务。

使用TCP通信的双方，在传送数据之前必须首先**建立TCP连接**(逻辑连接，而非物理连接)。数据传输结束后必须要**释放TCP连接**。

TCP为了实现可靠传输，就必须使用很多措施，例如TCP连接管理、确认机制、超时重传、流量控制以及拥塞控制等。

TCP的实现复杂，TCP报文段的首部比较大，占用处理机资源比较多。

### 运输层端口号

运行在计算机上的进程是使用进程标识符（Process Identification，PID）来标识的。

TCP/IP体系结构的运输层使用端口号来标识和区分应用层的不同应用进程。端口号的长度为16比特，取值范围是0~65535。

**熟知端口号**

![image-20221106161553455](http://pic.shixiaocaia.fun/202301301045869.png)

> 端口号只具有本地意义，即端口号只是为了标识本计算机网络协议栈应用层中的各应用进程。在因特网中，不同计算机中的相同端口号是没有关系的，即相互独立。另外，TCP和UDP端口号之间也是没有关系的。

**发送方的复用和接收方的分用**

发送方的某些应用进程所发送的不同应用报文，在运输层使用UDP协议进行封装，称为UDP复用，在运输层使用TCP协议进行封装，称为TCP复用。

到网际层都需要使用IP协议封装成IP数据报，称为IP复用。在IP数据报中协议字段来表示封装的是何种协议数据单元。

---

接收端的网际层收到IP数据报进行IP分用。协议字段是17（UDP用户数据报），交给运输层的UDP，同样是TCP交给TCP处理。

运输层堆UDP用户数据报进行UDP分用，对TCP报文段进行TCP分用。根据其中的目的端口号，向上交付给应用层的相应进程。

## UDP和TCP的对比

**连接**

UDP不需要建立连接，可以随时进行通信。

TCP需要三次报文握手建立TCP连接，基础TCP连接进行数据传输，结束再通过四报文挥手释放TCP连接。

**单播、多播、组播**

显然UDP可以支持三种传播方式，而TCP需要建立连接，只能单播。

**对应用层报文处理**

UDP是面向应用报文的，对应用层发下来的报文加一个UDP首部后，使之成为UDP用户数据报，进行发送。

接受方收到后去除UDP首部，然后向上发给应用层。

---

TCP处理应用层报文，是看作一连串的、无结构的字节流，当发送缓存到一定数量的字节，构建TCP报文段进行发送。

TCP面向字节流，有利于实现可靠传输、流量控制和拥塞控制。

并且TCP连接是全双工通信的。

**对数据可靠性的支持**

UDP用户数据报出现的误码和丢失问题，接收端只是丢弃，不做任何处理，UDP适合用于实时应用。

TCP提供面向连接的可靠服务，尽管在一起使用的IP提供是无连接不可靠的，但是运输层使用TCP协议会保证这个。

**首部对比**

<img src="http://pic.shixiaocaia.fun/202301301045856.png" alt="image-20221107164751294" style="zoom:50%;" />

UDP首部十分简单，只加了用于区分应用进程的端口。

UDP在计算校验和时需要增加12字节的伪首部。

## TCP

### TCP报文

<img src="http://pic.shixiaocaia.fun/202301301045118.png" alt="image-20221107170614878" style="zoom:50%;" />                                                                                                                                                                                                                                                                                                                                                                                                       

**序号、确认号、确认标志位ACK**

> 序号seq: 
>
> 用来指出本TCP报文段数据载荷的第一个字节的序号。
>
> 确认号ack:
>
> 用来指出期望收到对方下一个TCP报文段的数据载荷的第一个字节的序号，同时也是对之前收到的所有数据的确认。
>
> ACK:
>
> 只有当ACK取值为1时，确认号字段才有效。ACK取值为0时，确认号字段无效。
> TCP规定：在TCP连接建立后，所有传送的TCP报文段都必须把ACK置1。

**数字偏移字段(头部长度）**

> 指出TCP报文段的数据载荷部分的起始处距离TCP报文段的起始处有多远，这实际上指出了TCP报文段的首部长度。

**保留**

>  保留为今后使用，目前应置为0。

**窗口**

> 指出发送本报文段的一方的接收窗口的大小，即接收缓存的可用空间大小，这用来表征接收方的接收能力。
>
> 在计算机网络中，经常用**接收方的接收能力**的大小来控制发送方的数据发送量，这就是所谓的流量控制。

**校验和**

> 用来检查整个TCP报文段在传输过程中是否出现了误码。
>
> 与UDP相似的是，在计算校验和时，要在TCP报文段的前面加上12字节的伪首部。

**同步标志位SYN**

> 用于TCP“三报文握手”建立连接。
>
> 当SYN=1且ACK=0时，表明这是一个TCP连接请求报文段。
> 对方若同意建立连接，则应在响应的TCP报文段的首部中使SYN=1且ACK=1。
>
> 综上所述，SYN为1的TCP报文段要么是一个连接请求报文段，要么是一个连接响应报文段。

**终止标志位FIN**

> 用于TCP“四报文挥手”释放连接。
>
> 当FIN=1时，表明此TCP报文段的发送方已经将全部数据发送完毕，现在要求释放TCP连接。

**复位标志位RST**

> 用于复位TCP连接。
>
> 当RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。
>
> RST置1还用来拒绝一个非法的TCP报文段或拒绝打开一个TCP连接。

**推送标志位PSH**

> 处于效率发送方会延迟发送，接收方会延迟向应用进程交付数据，来一次性处理数据。但有时候又要即可发送和处理。

> 发送方TCP把PSH置1，并立即创建一个TCP报文段发送出去，而不需要积累到足够多的数据再发送。
>
> 接收方TCP收到PSH为1的TCP报文段，就尽快地交付给应用进程，而不再等到接收到足够多的数据才向上交付。

**紧急指针**

> 当URG=1时，紧急指针字段有效，当URG=0时，紧急指针字段无效。
>
> 用来指明紧急数据的长度。
>
> 当**发送方有紧急数据**时，可将紧急数据“插队”到发送缓存的最前面，并立刻封装到一个TCP报文段中进行发送。紧急指针会指出本报文段数据载荷部分包含了多长的紧急数据，**紧急数据之后是普通数据**。
>
> 接收方收到紧急标志位为1的TCP报文段，会按照紧急指针字段的值从报文段数据载荷中取出紧急数据并直接上交应用进程，而不必在接收缓存中排队。

**选项**

> 扩充功能部分：
>
> 最大报文段长度MSS选项：指出TCP报文段数据载荷部分的最大长度，而不是整个TCP报文段的长度。
> 窗口扩大选项：用来扩大窗口，提高吞吐率。
>
> 选择确认选项：用来实现选择确认功能。
>
> 时间戳选项：
>
> - 用于计算往返时间RTT
> - 用于处理序号超范围的情况，又称为防止序号绕回PAWS。

**填充**

> 由于选项字段的长度是可变的，若选项字段的长度加上20字节固定首部的长度不能被4字节整除时，需要填充相应数量的比特0，以确保首部长度能被4字节整除。

![image-20221109114523471](http://pic.shixiaocaia.fun/202301301045082.png)

### 三次握手

<img src="http://pic.shixiaocaia.fun/202301301045614.png" alt="image-20221111120351977" style="zoom:50%;" />

> 1. TCP服务器进程首先创建传输控制模块，用来存储TCP连接的重要信息。TCP服务器进入鉴定状态，等待客户端的响应请求。
> 2. TCP客户端创建传输控制快，之后打算建立TCP连接时向服务端发送TCP连接请求报文段。状态信息变化见图。
> 3. TCP服务端收到TCP连接请求报文段后，如果同意建立连接，回应TCP连接请求确认报文端。状态信息变化见图。
> 4. TCP客户端收到后，还要发送一个普通的TCP确认报文段。
> 5. TCP服务端进程收到普通确认报文段后，也进入已建立状态。

通过三次握手后，双方都进入了已建立的状态。

**为什么是三次握手而不是两次握手**

> 1. 第一次握手，SYN = 1，确认客户端能发送数据。此时服务端能确认自己接受和客户端的发送
> 2. 第二次握手，服务端 ACK = 1，SYN = 1， 客户端确认了服务端发送和接受能力，客户端确认自己的发送和接受没问题
> 3. 第三次握手，客户端 ACK = 1，服务端接收后确认了自己 的发送没问题

**TCP是面向字节流，怎么确认发送数据的完整、顺序正确**

> 1. 发送端发送seq = x, SYN = 1
> 2. 接收端收到后，对上面的seq确认，回复ACK = 1，ack = x + 1。同时也发送了SYN = 1， seq = y
> 3. 发送端收到后回复ACK = 1， ack = y + 1表示对server端报文的确认，seq = x + 1

### 滑动窗口

![image-20221221094649438](http://pic.shixiaocaia.fun/202301301045568.png)

> 发送方的缓冲区：
>
> - 白色格子：空用的空间
> - 灰色格子：数据已经被发送出去了，但是还没有被接受
> - 紫色格子：还没有发送出去的据
>
>  接收方的缓冲区：
>
> - 白色格子：空闲的空间
> - 紫色格子：已经接收到的数据

![image-20221221095319037](http://pic.shixiaocaia.fun/202301301045979.png)

> mss： Max1mum Segment Size（一条数据的最大的数据量）
> win： 滑动窗口
>
> 1. 客户端向服务器发起连接，客户单的滑动窗口是4096，一次发送的最大数据量是1460
> 2. 服务器接收连接情况，告诉客户端服务器的窗口大小是6144，一次发送的最大数据量是1024
> 3. 第三次握手
> 4.  4-9发送6K数据，每次发送1K
> 5. 第10次，服务器告诉客户端，发送的6K数据已经接收到，缓冲区数据已经处理了2K，窗口大小是2K。
> 6. 第11次，服务器告诉客户端，发送的6K数据已经接收到，缓冲区数据已经处理了2K，窗口大小是4K。
> 7. 后面重复。
> 8. 第13次，客户端主动请求和服务器断开连接，并且给服务器发送了1K的数据
> 9. 第14次，服务器回复ACK 8194（多了1的FIN位），统一断开连接的请求，告诉客户端已经接收到方才发的2K的数据，窗口还剩2K的大小
> 10. 第15，16是通知客户端滑动窗口的大小，其中也进行了挥手。（发送端FIN后不能发送数据，但是服务端还能携带数据）
> 11. 第17次是进行第三次挥手，发送FIN，请求断开连接
> 12. 第18次，第四次挥手。

### 四次挥手

四次回收发生在断开连接的时候，当程序中调用close()会使用TCP协议进行四次挥手。

客户端和服务端都可以主动发起断开连接。

> 1. 客户端应用进程通知其主动关闭TCP连接，TCP客户进程发送TCP连接释放报文段，状态变化如图。
> 2. 服务端收到后，发送一个普通的TCP确认报文段。此时TCP客户端到服务端的连接断开，处于半关闭状态。
> 3. 客户端收到TCP确认报文后进入等待2，等待服务端发送TCP连接释放报文段。
> 4. 服务端发送完数据后，向客户端发送TCP连接释放报文段，，进入最后确认状态。
> 5. 客户端收到后，又发送普通的确认报文，之后进入时间等待状态。
> 6. 服务端收到后进入关闭状态，客户端要等待2MSL后才能进入**“真正”**关闭状态。

> 必须等待2MSL时间，是保证服务端收到确认报文，当丢弃时要进行重发，否则服务端无法正常的关闭。

> 1. 客户端（主动发起方），FIN = 1
> 2. 服务端发送 ACK = 1
> 3. 服务端发送 FIN = 1
> 4. 客户端发送 ACK = 1

**为什么要四次挥手**

> 

### TCP保活计时器

TCP服务器进程每收到一次TCP客户进程的数据时，就重置保活计时器（通常为两小时）

若保活计时器周期内没有收TCP客户端发送的数据，TCP保活计时器到后，TCP服务端就向客户端发送一个探测报文段，以后每隔75s发送一次，发送十次，没反应后就认识客户端主机出现故障，就关闭连接，避免无效的等待响应。

### TCP流量控制

接收方根据自己的接受能力(接受缓存的可用空间大小)控制发送方的发送速率，避免接收方的应用程序因忙于其他任务没有及时取走数组，造成**接受缓存溢出**。

根据接收方的接受窗口大小来修改发送方的窗口大小，这是个动态的对丢失的报文会进行超时重发。

有时候接收方发送了**0窗口报文**，但是过了一会又有了接受窗口大小，但是前面发送方收到了0窗口报文确认报文，不会发送报文。

这时候就有了**零窗口探测报文段**，定期检查接收方的接受窗口大小。

收到零窗口通知时，就启动一个持续计时器，当计时器为0时发送零窗口探测报文，这是一个持续反复的过程。

零窗口探测报文也有**重传计时器**，避免丢失，陷入死锁状态。

> 实际上TCP规定：即使接收窗口值为0，也必须接受零窗口探测报文段、确认报文段以及携带有紧急数据的报文段。

### 拥塞控制

在某段时间内，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变化。计算机网络中的链路容量（带宽）、交换节点中的缓存和处理机等都是网络的资源。

<img src="http://pic.shixiaocaia.fun/202301301045636.png" alt="image-20221117191922673" style="zoom:50%;" />

TCP 中采用**滑动窗口**来进行传输控制，滑动窗口的大小意味着接收方还有多大的**缓冲区**可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0
时，发送方一般不能再发送数据报。

**拥塞控制的基本方法**

**开环控制方法**：试图用良好的设计来解决问题。从一开始就保证问题不会发生。一旦系统启动并运行起来，就不需要中途修正。

当网络的流量特征可以准确规定且性能要求可以事先获得时，适合使用开环控制。

**闭环控制方法**：

基于反馈的控制方法，包括以下三个部分：
1. 监测网络拥塞在何时、何地发生。
2. 把拥塞发生的相关信息传送到可以采取行动的地方。
3. 调整网络的运行以解决拥塞问题。

当网络的流量特征不能准确描述或者当网络不提供资源预留时，适合使用闭环控制。因特网采用的就是闭环控制方法。

根据**拥塞信息的反馈形式**，可将闭环拥塞控制算法分为：

1. 显示反馈算法，从拥塞点向源点提供关于网络中拥塞状态的显示反馈信息。
2. 隐式反馈算法，源点自身通过对网络行为的观察（例如超时重传或往返时间RTT）来推断网络是否发生了拥塞。TCP采用的就是隐式反馈算法。

**慢开始和拥塞避免**

![image-20221117200050436](http://pic.shixiaocaia.fun/202301301045123.png)

> 发送方要维护一个拥塞窗口cwnd（Congestion Window)，其值取决于网络的拥塞程度和所采用的TCP拥塞控制网算法。
>
> 只要网络没有出现拥塞，拥塞窗口就再增大一些，但只要网络出现拥塞，拥塞窗口就减少一些。
> 判断网络出现拥塞的依据：没有按时收到应当到达的TCP确认报文段而产生了超时重传。
>
> ---
>
> 发送法还要维护一个发送窗口swnd（sender Window)，swnd = min(cwnd，rwnd)。
>
> 接收窗口为Receiver Window。
>
> 1. 当cwnd<ssthresh时，使用慢开始算法。
>
> 2. 当cwnd>ssthresh时，停止使用慢开始算法而改用拥塞避免算法，cwnd值只能线性增加1。
>
> 3. 当cwnd=ssthresh时，既可使用慢开始算法，也可使用拥塞避免算法。
>
> ---
>
> 发送方判断网络拥塞时，调整cwnd值和ssthresh值。

**快重传和快恢复**

采用快重传算法可以让发送方尽早知道发生了个别TCP报文段的丢失。

“快重传”是指使发送方尽快（尽早）进行重传，而不是等重传计时器超时再重传。

- 这就要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。
- 发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的重传计时器超时再重传。

> 在发送每个报文的时候，未收到确认报文时就发送了下一个报文，但收到不是按需到达报文段时，接收方发送上一个接受的重复确认报文，发送方继续发送报文，并收到重复确认报文，当连续收到三次时重发这个丢失的报文。

与快重传算法配合使用的是快恢复算法，发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段，于是不启动慢开始算法，而是执行快恢复算法。

- 发送方将慢开始门限ssthresh的值和拥塞窗口cwnd的值都调整为当前cwnd值的一半，并开始执行拥塞避免算法。

- 也有的快恢复实现是把快恢复开始时的cwmd值再增大一些，即cwnd=新ssthresh+-3.
  - 既然发送方收到了3个重复的确认，就表明有3个数据报文段已经离开了网络。
  - 这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中。
  - 可见现在网络中不是堆积了报文段而是减少了3个报文段，因此可以适当把cw值增大一些。

<img src="http://pic.shixiaocaia.fun/202301301045225.png" alt="image-20221117205444446" style="zoom:50%;" />

> 整体描述这个过程就是，一开始使用慢开始算法，从1开始指数规律增大。增大到满开始门限时使用拥塞避免算法，按1线性增加。
>
> 当发生超时重传拥塞情况时，一方面将门限将为当前cwnd的一半，一方面将cwnd降为1。
>
> 当如果只是个别丢失，收到3个重复确认时，执行快重传和快恢复。

### 可靠传输的实现

### 超时重传时间

每次测量RTT样本计算加权的平均往返时间RTTs，不断更新时间。

> RTO：超时重传时间。
>
> RTT：往返时间。

### 选择确认

告知发送方收到的连续的字节流，缺失的字节流边界，通过增加TCP首部选项字段来表示信息。

增加SACK选项。

