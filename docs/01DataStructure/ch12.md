力扣Hot 100
===

[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

> LRU 算法（Least Recently Used）就是一种缓存淘汰策略。也就是说我们认为最近使用过的数据应该是是「有用的」，很久都没用过的数据应该是无用的，内存满了就优先删那些很久没用过的数据。
>
> 比如手机后台使用程序，最近使用的app放在前面，之前的程序排在后面会被优先清理。

> 可以把cache理解成一个队列，最近使用的排在左边（队头），久未使用的放在右边（队尾）。
>
> put的操作，如果之前队列没有会插入到队头，有的话会更新value，并放置到队头。如果内存满了，就要删除队尾的元素（久未使用），再插入到队头。
>
> get的操作，如果队列中有，就返回值，并放置到前列，如果没有返回-1。

> 1. 因此本体需要考虑，cache中元素必须是有序的，以区分最近使用的和长久未使用的，当容量满了方便删除。
> 2. 要在cache中快速找某个key，每次返回cache中的某个key，变更为最近使用的，所以cache要支持任意位置的快速插入和删除元素。
>
> 3. 哈希表查找快，但是元素没有固定无法区分使用事件。链表有顺序之分，插入删除块，查找慢。

[2. 两数相加](https://leetcode.cn/problems/add-two-numbers)

> 我以为的两数相加，直接相加，链表反转。实际的两数相加，如果位数不统一怎么办，还有进位。

> 给长度不足的一方补0，同时记录进位。
>
> 最高位如果还有进位再补1。