## 链表


**单链表**

![image-20230201203454660](http://pic.shixiaocaia.fun/202302012034430.png)

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，一个是数据域，一个是指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null。

单链表也是我们泛称为的链表。

链表得入口节点称为head（头节点）。

**双链表**

![image-20230201203525572](http://pic.shixiaocaia.fun/202302012035982.png)

单链表中的指针域只能指向节点的下一个节点。而双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表既可以向前查询也可以向后查询。

**循环链表**

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

**链表的存储**

数组在内存中是连续分布，在内存中不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。

分配机制取决于操作系统的内存管理。

## 存储方式

数组是在内存中是连续分布的，但是链表在内存中不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于**操作系统的内存管理**。

## 基本用法

**链表的定义**

```cpp
struct ListNode{
    int val; //element
    ListNode *next; //next ptr
    ListNode(int x) : val(x), next(NULL) {} // 节点的构造函数
}

ListNod* head = new ListNode(5);
```

注意后续面试时不像力扣，链表的定义可能需要自己来定义。

**删除节点**

- 只要将C节点的next指针指向E节点就可以了。
- 最好释放中间D节点的内存，对于其他语言可能有垃圾回收机制来处理。

**添加节点**

- C节点的next指针指向新的节点F。

- F节点的next指针指向原来的C指向的下一节点D。

**新建节点**
- 初始化一个新的空节点，值为0，指向该节点的指针为Node。
  ```cpp
  ListNode* Node = new ListNode(0);

## 数组链表对比

- 数组在插入和删除是O(n)，查询是O(1)。链表与之相反。
- 对应数组适合频繁查询，少量删减增加的，而链表适合频繁变化的。
- 数组在定义时，长度固定，不可变。
- 链表长度不固定，可以动态增删。

## 例题

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

模板题。

**[LC203.移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)**

> 使用C++，注意释放删除的内存空间。
>
> 通过增加一个哑节点，这样如果删除头结点的话，不会影响，因为最终返回的是哑节点的下一个节点。
>
> 如果没有哑节点，无法进行这样的直接替换操作。而是需要单独移动头结点的位置，最好再释放。
>
> 必须用一个中间变量来保存要删除的节点，否则`cur->next`指向的就不是要删除的点了。

**[LC707.设计链表](https://leetcode.cn/problems/design-linked-list/)**

> 思路简单，但是全是细节的题。
>
> 模拟了链表的各种操作。

**[LC206.反转链表](https://leetcode.cn/problems/reverse-linked-list/)**

> 方法1：递归
>
> 递归的方法与双指针的方法相同，简洁一些。
>
> 方法2：双指针

**[🆙LC24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)**

> 通过循环判断后两个节点是否为空
>
> 1. 保存后两个节点
>2. cur 指向 2 这个节点
> 3. 再指向1这个节点
> 4. 最后指向下一组的3

**[LC19.删除链表的倒数第N个节点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)**

> 处理数组、链表中的某部分——双指针
>
> 将fast指针指向删除节点的前一个节点，然后fast指针遍历到NULL时，刚好slow指针遍历到要删除的节点。
>
> 同样用哑节点，规避了分类头节点问题。
>
> 二刷没想到双指针用法。
>
> **实现了单次遍历链表**

**[面试题 02.07. 链表相交](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)**

> 先计算两个链表的长度，计算他们长度差，将指针移动到统一起点。
>
> 开始遍历较长的链表（默认A，比较后交换），当二者指针相同相等时，找到了相交节点返回，否则返回NULL。
>
> 注意判断交点是**指针相等**，不是数值相等。
>
> 同样可以窗帘两个链表，直到相交点，否则返回时NULL。
>
> ---
>
> 数学知识：
>
> pA走过的路径为A链+B链
>
> pB走过的路径为B链+A链
>
> pA和pB走过的长度都相同，都是A链和B链的长度之和，相当于将两条链从尾端对齐，如果相交，则会提前在相交点相遇，如果没有相交点，则会在最后相遇。

**[🆙LC142.环形链表II](https://leetcode.cn/problems/linked-list-cycle-ii/)**

> 主要是涉及到的数学问题。
>
> 1. 判断是否有环形：快慢指针，如果最终相遇就是有环形。
> 2. 判断环形的入口：数学公式推导。

### 双指针的应用

[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/description/)

> 简单的双指针问题，比较大小插入。

[86. 分隔链表](https://leetcode.cn/problems/partition-list/description/)

> 建立两个单链表，分别存放大于等于和小于的节点值，然后合并两个节点。

[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/description/)

> 如果链表长度为n，那么中间点为n/2位置，可以联想到LC 19题，实现单次遍历，不用先计算长度再取中间值的情况。

## 总结

- 链表的例题第一遍都是参考的思路，涉及指针的操作，是过去不熟悉的，需要多次复习。
- 增加**哑节点**可以使得处理头节点像其他非头节点情况下。
- 节点的大小，和数组一样从0开始。
