排序
===

冒泡排序

使得相邻两个元素比较大小，大的元素慢慢下沉，下次循环到len - 1 - i，因为底部有一部分已经排序完成了

```cpp
void bubbleSort(vector<int>& a){
    for (int i = 0; i < a.size(); i++){
        for (int j = 0; j < a.size() - i - 1; j++){
            if(a[j] > a[j + 1])
                swap(a[j], a[j + 1]);
        }
        print(a, i);
    }
}
```

优化方式时，当某一次循环，没有发生交换，说明当前的部分已经有序，可以跳出循环。

```cpp
void bubbleSort(vector<int>& nums) {
    int n = nums.size();
    bool flag = false;
    for (int i = 0; i < n - 1; ++i) {//i = 0 起，循环了n - 1趟，更符合规范理解
    //for (int i = 0; i < n; ++i) {//i = 0 起，循环了n 趟，不影响结果
        flag = false;
        for (int j = 0; j < n - 1 - i; ++j) {
            if (nums[j] > nums[j + 1]) {
                //某一趟排序中，只要发生一次元素交换，flag就从false变为了true
                //也即表示这一趟排序还不能确定所剩待排序列是否已经有序，应继续下一趟循环
                swap(nums[j], nums[j + 1]);
                flag = true;
            }
        }
        //但若某一趟中一次元素交换都没有，即依然为flag = false
        //那么表明所剩待排序列已经有序
        //不必再进行趟数比较，外层循环应该结束，即此时if (!flag) break; 跳出循环
        /* if (flag) { break; } */
        if (!flag) { break; }
    }
}
```

## 选择排序

**选择排序就是将找打数组中最小的元素，将它和数组的第一个元素交换位置，然后再剩下的元素中找最小的元素，和第二元素的位置交换，如此反复。**

```cpp
void selectSort(vector<int>& nums) {
	int len = nums.size();
	int minIndex = 0;
	for (int i = 0; i < len; ++i) {
		minIndex = i;
		for (int j = i + 1; j < len; ++j) {
			if (nums[j] < nums[minIndex]) minIndex = j;
		}
		swap(nums[i], nums[minIndex]);
	}
}
```

## 插入排序

在保证左边有序的情况下，当第i个元素数值小于i-1时，将之插入到左边有序序列当中。

找到左边有序序列中小于a[i]的位置j，将之插入到j + 1这个位置，如果j这个位置元素数值大于a[i]，向后移动a[j]这个位置元素。

```cpp
void print(vector<int>& a, int n, int i) {
	cout << "step"<< i << ": ";
	for (int j = 0; j < n; j++) {
		cout << a[j] << " ";
	}
	cout << endl;
}
void insertionSort(vector<int>& a, int n) {//{ 9,1,5,6,2,3 }
	for (int i = 1; i < n; ++i) {
		if (a[i] < a[i - 1]) {   //若第i个元素大于i-1元素，直接插入。小于的话，移动有序表后插入
			int j = i - 1;
			int x = a[i];     //因为后续将i - 1的值后移，找到合适的位置插入，所以需要存储数 = x;值
			while (j >= 0 && x < a[j]) {   //查找在有序表的插入位置,还必须要保证j是>=0的 因为a[j]要合法
				a[j + 1] = a[j];
				j--;     //元素后移
			}
			a[j + 1] = x;     //插入到正确位置
		}
		print(a, n, i);      //打印每趟排序的结果
	}
}
```

## 希尔排序

略略略。

## 快速排序

<h3>思路</h3>


```cpp
void sort(int[] nums, int lo, int hi) {
    if (lo >= hi) {
        return;
    }
    // 对 nums[lo..hi] 进行切分
    // 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]
    int p = partition(nums, lo, hi);
    // 去左右子数组进行切分
    sort(nums, lo, p - 1);
    sort(nums, p + 1, hi);
}
```

**快速排序是先将一个元素排好序，然后再将剩下的元素排好序**。

`partition` 函数的作用是在 `nums[lo..hi]` 中寻找一个分界点 `p`，通过交换元素使得 `nums[lo..p-1]` 都小于等于 `nums[p]`，且 `nums[p+1..hi]` 都大于 `nums[p]`

> 实际上相当于构造一个BST。

**为了避免构造二叉树过程不平衡情况，引入随机性**

```cpp
class Quick {

    public static void sort(int[] nums) {
        // 为了避免出现耗时的极端情况，先随机打乱
        shuffle(nums);
        // 排序整个数组（原地修改）
        sort(nums, 0, nums.length - 1);
    }

    private static void sort(int[] nums, int lo, int hi) {
        if (lo >= hi) {
            return;
        }
        // 对 nums[lo..hi] 进行切分
        // 使得 nums[lo..p-1] <= nums[p] < nums[p+1..hi]
        int p = partition(nums, lo, hi);

        sort(nums, lo, p - 1);
        sort(nums, p + 1, hi);
    }

    // 对 nums[lo..hi] 进行切分
    private static int partition(int[] nums, int lo, int hi) {
        int pivot = nums[lo];
        // 关于区间的边界控制需格外小心，稍有不慎就会出错
        // 我这里把 i, j 定义为开区间，同时定义：
        // [lo, i) <= pivot；(j, hi] > pivot
        // 之后都要正确维护这个边界区间的定义
        int i = lo + 1, j = hi;
        // 当 i > j 时结束循环，以保证区间 [lo, hi] 都被覆盖
        while (i <= j) {
            while (i < hi && nums[i] <= pivot) {
                i++;
                // 此 while 结束时恰好 nums[i] > pivot
            }
            while (j > lo && nums[j] > pivot) {
                j--;
                // 此 while 结束时恰好 nums[j] <= pivot
            }
            // 此时 [lo, i) <= pivot && (j, hi] > pivot

            if (i >= j) {
                break;
            }
            swap(nums, i, j);
        }
        // 将 pivot 放到合适的位置，即 pivot 左边元素较小，右边元素较大
        swap(nums, lo, j);
        return j;
    }

    // 洗牌算法，将输入的数组随机打乱
    private static void shuffle(int[] nums) {
        Random rand = new Random();
        int n = nums.length;
        for (int i = 0 ; i < n; i++) {
            // 生成 [i, n - 1] 的随机数
            int r = i + rand.nextInt(n - i);
            swap(nums, i, r);
        }
    }

    // 原地交换数组中的两个元素
    private static void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

<h3>时间复杂度</h3>

假设数组元素个数为 `N`，那么二叉树每一层的元素个数之和就是 `O(N)`；分界点分布均匀的理想情况下，树的层数为 `O(logN)`，所以理想的总时间复杂度为 `O(NlogN)`。

由于快速排序没有使用任何辅助数组，所以空间复杂度就是递归堆栈的深度，也就是树高 `O(logN)`。

所以我们说，快速排序理想情况的时间复杂度是 `O(NlogN)`，空间复杂度 `O(logN)`，极端情况下的最坏时间复杂度是 `O(N^2)`，空间复杂度是 `O(N)`。

快速排序是不稳定排序。

> 如果排序之后它们的相对位置没有发生改变，则称该排序算法为「稳定排序」，反之则为「不稳定排序」。

<h3>例题</h3>

[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/description/)

## 快速选择算法

当知道所需要的第k个大的元素时，可以转换为升序后的排名为n - k的元素，记为K。

那么我们可以把 `p` 和 `K` 进行比较，如果 `p < K` 说明第 `K` 大的元素在 `nums[p+1..hi]` 中，如果 `p > K` 说明第 `K` 大的元素在 `nums[lo..p-1]` 中。

进一步，去 `nums[p+1..hi]` 或者 `nums[lo..p-1]` 这两个子数组中执行 `partition` 函数，就可以进一步缩小排在第 `k'` 的元素的范围，最终找到目标元素。

## 归并排序

[31. 下一个排列](https://leetcode.cn/problems/next-permutation)

