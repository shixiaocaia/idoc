单调栈
===

### 何时使用

通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。

本质是空间换时间，时间复杂度为O(n)。

### 如何使用

在使用单调栈的时候首先要明确如下几点：

1. 单调栈里存放的元素是什么？

单调栈里只需要存放元素的下标i就可以了，如果需要使用对应的元素，直接T[i]就可以获取。

2. 单调栈里元素是递增呢？ 还是递减呢？

**注意一下顺序为 从栈头到栈底的顺序**。

```cpp
stack<int> st;
//此处一般需要给数组最后添加结束标志符，具体下面例题会有详细讲解
for (遍历这个数组)
{
	if (栈空 || 栈顶元素大于等于当前比较元素)
	{
		入栈;
	}
	else
	{
		while (栈不为空 && 栈顶元素小于当前元素)
		{
			栈顶元素出栈;
			更新结果;
		}
		当前数据入栈;
	}
}

```

## 例题

**[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/description/)**

> 维护一个单调递减的栈，当出现温度大于栈顶元素值时，记录答案。

**[496. 下一个更大元素 I](https://leetcode.cn/problems/next-greater-element-i/description/)**

> 基本可以同上处理。
>
> 不过加了一个映射。对nums2单调栈，result[i] 表示 i 这个数字在nums2中第一个比他大的数的下标。
>
> 再遍历nums1, result[nums1[i]] == -1说明没有比他大的数，否则就是找到了下标，再把下标对在nums2的值放入，否则就是放入-1。

**[503. 下一个更大元素 II](https://leetcode.cn/problems/next-greater-element-ii/description/)**

> 对比上一题，这题变成了循环数组，一种方法是拼接，这种达到延续前半部分的作用，再对后半部分答案取余。
>
> 实际上可以直接利用取余这个操作实现，double的作用。

**[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/description/)**

> 方法一：双指针法。
>
> 按照列方向统计每一列的储水量。
>
> 左右指针分别指向该列的左右边的最大值，其中的最小值 - 当前列的高度就得到了这一列的雨水，这是一个O(n^2)，超时。
>
> 方法二：DP
>
> 对上面的方法优化，待做。
>
> 方法三：单调栈
>
> 关键是底部，左侧、右侧高度。
>
> 这里在例题中，3高度时，会把前面的11都弹出，因为底和最高相等。

**[🆙84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/description/)**

> 右边界计算的非常巧妙啊！比我大的都弹走了，你就是比我小的第一个元素，这就是高度。
