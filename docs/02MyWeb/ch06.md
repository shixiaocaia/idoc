定时器的设计
===

## 整体思路

`定时器设计`，将连接资源和定时事件等封装起来，具体包括连接资源、超时时间和回调函数，这里的回调函数指向定时事件。

`定时器容器设计`，将多个定时器串联组织起来统一处理，具体包括升序链表设计。

`定时任务处理函数`，该函数封装在容器类中，具体的，函数遍历升序链表容器，根据超时时间，处理对应的定时器。

`代码分析-使用定时器`，通过代码分析，如何在项目中使用定时器。

## 定时器设计

项目中将连接资源、定时事件和超时时间封装为定时器类，具体的，

- 连接资源包括客户端套接字地址、文件描述符和定时器

- 定时事件为回调函数，将其封装起来由用户自定义，这里是删除非活动socket上的注册事件，并关闭

- 定时器超时时间 = 浏览器和服务器连接时刻 + 固定时间(TIMESLOT)，可以看出，定时器使用绝对时间作为超时值，这里alarm设置为5秒，连接超时为15秒。

- 定时事件，具体的，从内核事件表删除事件，关闭文件描述符，释放连接资源。

## 定时器容器设计

项目中的定时器容器为带头尾结点的升序双向链表，具体的为每个连接创建一个定时器，将其添加到链表中，并按照超时时间升序排列。执行定时任务时，将到期的定时器从链表中删除。

从实现上看，主要涉及双向链表的插入，删除操作，其中添加定时器的事件复杂度是O(n),删除定时器的事件复杂度是O(1)。

升序双向链表主要逻辑如下，具体的，

- 创建头尾节点，其中头尾节点没有意义，仅仅统一方便调整

- add_timer函数，将目标定时器添加到链表中，添加时按照升序添加

- - 若当前链表中只有头尾节点，直接插入
  - 否则，将定时器按升序插入

- adjust_timer函数，当定时任务发生变化,调整对应定时器在链表中的位置

- - 客户端在设定时间内有数据收发,则当前时刻对该定时器重新设定时间，这里只是往后延长超时时间
  - 被调整的目标定时器在尾部，或定时器新的超时值仍然小于下一个定时器的超时，不用调整
  - 否则先将定时器从链表取出，重新插入链表

- del_timer函数将超时的定时器从链表中删除

- - 常规双向链表删除结点

