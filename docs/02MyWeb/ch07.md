日志系统
===

## 整体思路

本项目中，使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分类功能，可以根据实际情况分别使用同步和异步写入两种方式。

> `单例模式`，保证一个类只创建一个实例，同时提供全局访问的方法。
>
> `日志`，由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。在本项目中记录了HTTP报文的解析信息，定时器等相关信息

其中异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。

> `异步日志`，将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。
>
> `生产者-消费者模型`，并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。
>
> `阻塞队列`，将生产者-消费者模型进行封装，使用**循环数组**实现队列，作为两者共享的缓冲区。
>
> `串行、并行部分`，见OS部分进程、线程问题整理。

日志系统大致可以分成两部分，其一是单例模式与阻塞队列的定义，其二是日志类的定义与使用。

## 问题

1. 日志系统同步和异步写入的区别

> 同步日志，日志写入函数与工作线程串行执行，由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。

## 单例模式

单例模式作为最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的**私有静态指针变量**指向类的唯一实例，并用一个公有的静态方法获取该实例。

实现方法，分别是懒汉和饿汉模式。

- 懒汉模式，即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；

- 饿汉模式，即迫不及待，在程序运行时立即初始化。

> 构造函数私有化后，不能在外部实例化这个对象的类。在类内实例化一个对象，然后返回一个对于该对象的引用。
>
> 这样做的优点是，在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）；避免对资源的多重占用。

### 懒汉模式

1. 为什么需要静态锁

> 对于单线程不需要使用，当引入多线程时，需要保护`getinstance()`方法，如果不保护` getInstance() `方法，则可能返回Single对象的两个不同的实例。

2. 为什么要用双检测，只检测一次不行吗？


双检测的含义是，在两个线程并发进入if语句时，一个线程进入静态锁，创建一个实例，另一个线程等待。

当第一个线程退出静态锁时，第二个线程进入静态锁，但是没有对instance实例进行检查，所以需要再判断一次`if(instance == NULL)`，由此双检测得名。

> 如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合`NULL == p`的情况，直接返回已创建好的实例。
>
> 避免了在第一次以外的调用实行同步加锁的代价。

C++0X以后，要求编译器保证内部静态变量的线程安全性，故C++0x之后该实现是线程安全的，C++0x之前仍需加锁，其中C++0x是C++11标准成为正式标准之前的草案临时名字。

```c++
 class single{
 private:
     single(){}
     ~single(){}
 
 public:
     static single* getinstance();

 };

single* single::getinstance(){
    static single obj;
    return &obj;
}
```

### 饿汉模式

饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。

饿汉模式虽好，但其存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。

## 互斥锁



## 条件变量

条件变量提供了一种线程间的通知机制，当某个共享数据达到某个值时,唤醒等待这个共享数据的线程。

### 基础API

- pthread_cond_init函数，用于初始化条件变量
- pthread_cond_destory函数，销毁条件变量
- pthread_cond_broadcast函数，以广播的方式唤醒**所有**等待目标条件变量的线程
- pthread_cond_wait函数，用于等待目标条件变量。该函数调用时需要传入 **mutex参数(加锁的互斥锁)** ，函数执行时，先把调用线程放入条件变量的请求队列，然后将互斥锁mutex解锁，当函数成功返回为0时，表示重新抢到了互斥锁，互斥锁会再次被锁上， **也就是说函数内部会有一次解锁和加锁操作**

使用pthread_cond_wait方式如下：

```c++
pthread _mutex_lock(&mutex)

while(线程执行的条件是否成立){
    pthread_cond_wait(&cond, &mutex);
}

pthread_mutex_unlock(&mutex);
```

pthread_cond_wait执行后的内部操作分为以下几步：

- 将线程放在条件变量的请求队列后，内部解锁
- 线程等待被pthread_cond_broadcast信号唤醒或者pthread_cond_signal信号唤醒，唤醒后去竞争锁
- 若竞争到互斥锁，内部再次加锁

###  陷阱一

**使用前要加锁，为什么要加锁？**

多线程访问，为了避免资源竞争，所以要加锁，使得每个线程互斥的访问公有资源。

**pthread_cond_wait内部为什么要解锁？**

如果while或者if判断的时候，满足执行条件，线程便会调用pthread_cond_wait阻塞自己，此时它还在持有锁，如果他不解锁，那么其他线程将会无法访问公有资源。

具体到pthread_cond_wait的内部实现，当pthread_cond_wait被调用线程阻塞的时候，pthread_cond_wait会自动释放互斥锁。

**为什么要把调用线程放入条件变量的请求队列后再解锁？**

线程是并发执行的，如果在把调用线程A放在等待队列之前，就释放了互斥锁，这就意味着其他线程比如线程B可以获得互斥锁去访问公有资源，这时候线程A所等待的条件改变了，但是它没有被放在等待队列上，导致A忽略了等待条件被满足的信号。

倘若在线程A调用pthread_cond_wait开始，到把A放在等待队列的过程中，都持有互斥锁，其他线程无法得到互斥锁，就不能改变公有资源。

**为什么最后还要加锁？**

将线程放在条件变量的请求队列后，将其解锁，此时等待被唤醒，若成功竞争到互斥锁，再次加锁。

### 陷阱二

**为什么判断线程执行的条件用while而不是if？**

一般来说，在多线程资源竞争的时候，在一个使用资源的线程里面（消费者）判断资源是否可用，不可用，便调用pthread_cond_wait，在另一个线程里面（生产者）如果判断资源可用的话，则调用pthread_cond_signal发送一个资源可用信号。

在wait成功之后，资源就一定可以被使用么？答案是否定的，如果同时有两个或者两个以上的线程正在等待此资源，wait返回后，资源可能已经被使用了。

再具体点，有可能多个线程都在等待这个资源可用的信号，信号发出后只有一个资源可用，但是有A，B两个线程都在等待，B比较速度快，获得互斥锁，然后加锁，消耗资源，然后解锁，之后A获得互斥锁，但A回去发现资源已经被使用了，它便有两个选择，一个是去访问不存在的资源，另一个就是继续等待，那么继续等待下去的条件就是使用while，要不然使用if的话pthread_cond_wait返回后，就会顺序执行下去。

所以，在这种情况下，应该使用while而不是if:

```
1while(resource == FALSE)
2    pthread_cond_wait(&cond, &mutex);
```

如果只有一个消费者，那么使用if是可以的。

## 生产者-消费者模型

生产者和消费者是互斥关系，两者对缓冲区访问互斥，同时生产者和消费者又是一个相互协作与同步的关系，只有生产者生产之后，消费者才能消费。

