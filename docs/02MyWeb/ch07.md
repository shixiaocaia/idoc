日志系统
===

## 整体思路

本项目中，使用单例模式创建日志系统，对服务器运行状态、错误信息和访问数据进行记录，该系统可以实现按天分类，超行分类功能，可以根据实际情况分别使用同步和异步写入两种方式。

> `单例模式`，保证一个类只创建一个实例，同时提供全局访问的方法。
>
> `日志`，由服务器自动创建，并记录运行状态，错误信息，访问数据的文件。在本项目中记录了HTTP报文的解析信息，定时器等相关信息

其中异步写入方式，将生产者-消费者模型封装为阻塞队列，创建一个写线程，工作线程将要写的内容push进队列，写线程从队列中取出内容，写入日志文件。

> `异步日志`，将所写的日志内容先存入阻塞队列，写线程从阻塞队列中取出内容，写入日志。
>
> `生产者-消费者模型`，并发编程中的经典模型。以多线程为例，为了实现线程间数据同步，生产者线程与消费者线程共享一个缓冲区，其中生产者线程往缓冲区中push消息，消费者线程从缓冲区中pop消息。
>
> `阻塞队列`，将生产者-消费者模型进行封装，使用**循环数组**实现队列，作为两者共享的缓冲区。
>
> `串行、并行部分`，见OS部分进程、线程问题整理。

日志系统大致可以分成两部分，其一是单例模式与阻塞队列的定义，其二是日志类的定义与使用。

## 问题

1. 日志系统同步和异步写入的区别

> 同步日志，日志写入函数与工作线程串行执行，由于涉及到I/O操作，当单条日志比较大的时候，同步模式会阻塞整个处理流程，服务器所能处理的并发能力将有所下降，尤其是在峰值的时候，写日志可能成为系统的瓶颈。

## 单例模式

单例模式作为最常用的设计模式之一，保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

实现思路：私有化它的构造函数，以防止外界创建单例类的对象；使用类的**私有静态指针变量**指向类的唯一实例，并用一个公有的静态方法获取该实例。

> static保证全局只有一个实例。

实现方法，分别是懒汉和饿汉模式。

- 懒汉模式，即非常懒，不用的时候不去初始化，所以在第一次被使用时才进行初始化；

- 饿汉模式，即迫不及待，在程序运行时立即初始化。

> 构造函数私有化后，不能在外部实例化这个对象的类。在类内实例化一个对象，然后返回一个对于该对象的引用。
>
> 这样做的优点是，在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）；避免对资源的多重占用。

> 我的理解是通过单例模式，避免了重复的创建和构造，只需要一个实例完成日志文件的读写操作。

### 懒汉模式

1. 为什么需要静态锁

> 对于单线程不需要使用，当引入多线程时，需要保护`getinstance()`方法，如果不保护` getInstance() `方法，则可能返回Single对象的两个不同的实例。

2. 为什么要用双检测，只检测一次不行吗？


双检测的含义是，在两个线程并发进入if语句时，一个线程进入静态锁，创建一个实例，另一个线程等待。

当第一个线程退出静态锁时，第二个线程进入静态锁，但是没有对instance实例进行检查，所以需要再判断一次`if(instance == NULL)`，由此双检测得名。

> 如果只检测一次，在每次调用获取实例的方法时，都需要加锁，这将严重影响程序性能。双层检测可以有效避免这种情况，仅在第一次创建单例的时候加锁，其他时候都不再符合`NULL == p`的情况，直接返回已创建好的实例。
>
> 避免了在第一次以外的调用实行同步加锁的代价。

C++0X以后，要求编译器保证内部静态变量的线程安全性，故C++0x之后该实现是线程安全的，C++0x之前仍需加锁，其中C++0x是C++11标准成为正式标准之前的草案临时名字。

```c++
 class single{
 private:
     single(){}
     ~single(){}
 
 public:
     static single* getinstance();

 };

single* single::getinstance(){
    static single obj;
    return &obj;
}
```

### 饿汉模式

饿汉模式不需要用锁，就可以实现线程安全。原因在于，在程序运行时就定义了对象，并对其初始化。之后，不管哪个线程调用成员函数getinstance()，都只不过是返回一个对象的指针而已。所以是线程安全的，不需要在获取实例的成员函数中加锁。

饿汉模式虽好，但其存在隐藏的问题，在于非静态对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。如果在初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。

## 条件变量

条件变量提供了一种线程间的通知机制，当某个共享数据达到某个值时，唤醒等待这个共享数据的线程。

### 基础API

- pthread_cond_init函数，用于初始化条件变量
- pthread_cond_destory函数，销毁条件变量
- pthread_cond_broadcast函数，以广播的方式唤醒**所有**等待目标条件变量的线程
- int pthread_cond_signal 唤醒一个或者多个等待的线程
- pthread_cond_wait函数，用于等待目标条件变量。该函数调用时需要传入 **mutex参数(加锁的互斥锁)** ，函数执行时，先把调用线程放入条件变量的请求队列，然后将互斥锁mutex解锁，当函数成功返回为0时，表示重新抢到了互斥锁，互斥锁会再次被锁上， **也就是说函数内部会有一次解锁和加锁操作**

使用pthread_cond_wait方式如下：

```c++
pthread _mutex_lock(&mutex)

while(线程执行的条件是否成立){
    pthread_cond_wait(&cond, &mutex);
}

pthread_mutex_unlock(&mutex);
```

pthread_cond_wait执行后的内部操作分为以下几步：

- 将线程放在条件变量的请求队列后，内部解锁
- 线程等待被`pthread_cond_broadcast`信号唤醒或者`pthread_cond_signal`信号唤醒，唤醒后去竞争锁
- 若竞争到互斥锁，内部再次加锁

###  陷阱一

**使用前要加锁，为什么要加锁？**

多线程访问，为了避免资源竞争，所以要加锁，使得每个线程互斥的访问公有资源。

**pthread_cond_wait内部为什么要解锁？**

如果while或者if判断的时候，满足执行条件，线程便会调用pthread_cond_wait阻塞自己，此时它还在持有锁，如果他不解锁，那么其他线程将会无法访问公有资源，**生产者无法拿到锁去生产，因此这里需要解锁**。

具体到pthread_cond_wait的内部实现，当pthread_cond_wait被调用线程阻塞的时候，pthread_cond_wait会自动释放互斥锁，**当不阻塞时，对mutex又会重新加锁**。

**为什么要把调用线程放入条件变量的请求队列后再解锁？**

线程是并发执行的，如果在把调用线程A放在等待队列之前，就释放了互斥锁，这就意味着其他线程比如线程B可以获得互斥锁去访问公有资源，这时候线程A所等待的条件改变了，但是它没有被放在等待队列上，导致A忽略了等待条件被满足的信号。

倘若在线程A调用pthread_cond_wait开始，到把A放在等待队列的过程中，都持有互斥锁，其他线程无法得到互斥锁，就不能改变公有资源。

**为什么最后还要加锁？**

将线程放在条件变量的请求队列后，将其解锁，此时等待被唤醒，若成功竞争到互斥锁，再次加锁。

### 陷阱二

**为什么判断线程执行的条件用while而不是if？**

一般来说，在多线程资源竞争的时候，在一个使用资源的线程里面（消费者）判断资源是否可用，不可用，便调用pthread_cond_wait，在另一个线程里面（生产者）如果判断资源可用的话，则调用pthread_cond_signal发送一个资源可用信号。

在wait成功之后，资源就一定可以被使用么？答案是否定的，如果同时有两个或者两个以上的线程正在等待此资源，wait返回后，资源可能已经被使用了。

再具体点，有可能多个线程都在等待这个资源可用的信号，信号发出后只有一个资源可用，但是有A，B两个线程都在等待，B比较速度快，获得互斥锁，然后加锁，消耗资源，然后解锁，之后A获得互斥锁，但A回去发现资源已经被使用了，它便有两个选择，一个是去访问不存在的资源，另一个就是继续等待，那么继续等待下去的条件就是使用while，要不然使用if的话pthread_cond_wait返回后，就会顺序执行下去。

所以，在这种情况下，应该使用while而不是if:

```
while(resource == FALSE)
    pthread_cond_wait(&cond, &mutex);
```

如果只有一个消费者，那么使用if是可以的。

## 生产者-消费者模型

生产者和消费者是互斥关系，两者对缓冲区访问互斥，同时生产者和消费者又是一个相互协作与同步的关系，只有生产者生产之后，消费者才能消费。

process_msg相当于消费者，enqueue_msg相当于生产者，struct msg* workq作为缓冲队列。

### 为什么使用生产者-消费者模型

在多线程开发中，如果生产者生产数据的速度很快，而消费者消费数据的速度很慢，那么生产者就必须等待消费者消费完数据才能够继续生产数据，因为生产过多的数据可能会导致存储不足；同理如果消费者的速度大于生产者那么消费者就会经常处理等待状态，所以为了达到生产者和消费者生产数据和消费数据之间的平衡，那么就需要一个缓冲区用来存储生产者生产的数据，所以就引入了生产者-消费者模式。

简单来说，这里缓冲区的作用就是为了平衡生产者和消费者的数据处理能力，一方面起到缓存作用，另一方面达到解耦合作用。

多个线程对于共享的数据处理，需要考虑线程同步问题，使用互斥锁

## 阻塞队列

阻塞队列类中封装了生产者-消费者模型，其中push成员是生产者，pop成员是消费者。

阻塞队列中，使用了循环数组实现了队列，作为两者共享缓冲区，当然了，队列也可以使用STL中的queue。

### 自定义队列

当队列为空时，从队列中获取元素的线程将会被挂起；当队列是满时，往队列里添加元素的线程将会挂起。

阻塞队列类中，有些代码比较简单，这里仅对push和pop成员进行详解。

> 消费时如果没有产品消费，那么就需要等待条件变量通知，同时多个消费者还需要竞争，如果没有竞争到那么就是解除当前的互斥锁，返回错误。

### 功能实现

**阻塞队列**

- block_queue(int max_size = 1000)
  - 初始化阻塞队列
- clear()
  - 重置阻塞队列
- ~block_queue()
  - 清空队列，内存管理
- 获取private信息
  - full()
  - empty()
  - front()
  - back()
  - size()
  - max_size()
- push()
- pop()
  - 消费者
  - 如果当前队列没有元素，将会等待条件变量
  - 如果有元素，取出队首的元素，使用循环数组模拟的队列
- pop2()
  - 超时处理
  - 在本项目中没有使用到
  - 在pthread_cond_wait基础上增加了等待的时间，只指定时间内能抢到互斥锁即可

