线程池
===

## 前置知识

### 多进程模型

基于最原始的阻塞网络 I/O， 如果服务器要支持多个客户端，其中比较传统的方式，就是使用**多进程模型**，也就是为每个客户端分配一个进程来处理请求。

服务器的主进程负责监听客户的连接，一旦与客户端连接完成，`accept() 函数`就会返回一个「已连接 Socket」，这时就通过 `fork()` 函数创建一个子进程，实际上就把父进程所有相关的东西都**复制**一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。

这两个进程刚复制完的时候，几乎一模一样。不过，会根据**返回值**来区分是父进程还是子进程，如果返回值是 0，则是子进程；如果返回值是其他的整数，就是父进程。

正因为子进程会**复制父进程的文件描述符**，于是就可以直接使用「已连接 Socket 」和客户端通信了，

可以发现，子进程不需要关心「监听 Socket」，只需要关心「已连接 Socket」；父进程则相反，将客户服务交给子进程来处理，因此父进程不需要关心「已连接 Socket」，只需要关心「监听 Socket」。

下面这张图描述了从连接请求到连接建立，父进程创建生子进程为客户服务。

![img](http://pic.shixiaocaia.fun/202301241830108.png)

另外，当「子进程」退出时，实际上内核里还会保留该进程的一些信息，也是会占用内存的，如果不做好“回收”工作，就会变成**僵尸进程**，随着僵尸进程越多，会慢慢耗尽我们的系统资源。

因此，父进程要“善后”好自己的孩子，怎么善后呢？那么有两种方式可以在子进程退出后回收资源，分别是调用 `wait()` 和 `waitpid()` 函数。

这种用多个进程来应付多个客户端的方式，在应对 100 个客户端还是可行的，但是当客户端数量高达一万时，肯定扛不住的，因为每产生一个进程，必会占据一定的系统资源，而且进程间上下文切换的“包袱”是很重的，性能会大打折扣。

> 进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。

### 多线程模型

线程是运行在进程中的一个“逻辑流”，单进程中可以运行多个线程，同进程里的线程可以共享进程的部分资源，比如文件描述符列表、进程空间、代码、全局数据、堆、共享库等，这些共享些资源在上下文切换时不需要切换，只需要切换线程的私有数据、寄存器等不共享的数据，因此同一个进程下的线程上下文切换的开销要比进程小得多。

当服务器与客户端 TCP 完成连接后，通过 `pthread_create()` 函数创建线程，然后将「已连接 Socket」的文件描述符传递给线程函数，接着在线程里和客户端进行通信，从而达到并发处理的目的。

![img](http://pic.shixiaocaia.fun/202301241830456.png)

### 线程池

我们每次接受一个HTTP连接，就创建一个线程来执行任务，这十分浪费效率。我们创建线程会涉及系统调用，开销比较大，不如一次性生成多个线程供我们所用。有新连接到达时，就从线程池中抽取一个线程来执行任务，其他线程没有任务时阻塞。

当新连接到来，我们调用线程池的函数插入任务到队列中，然后通过算法选出一个线程，该线程从任务队列中取出任务，然后执行处理函数。

那我们既然使用了多线程，就一定会涉及到线程的互斥，同步问题。

- 任务队列是公共资源，访问它必须保证互斥。
- 任务队列不为空时，线程才能从中取出任务，必须保证线程同步（生产者消费者模型）

所以，我们会需要用到互斥锁，条件变量，信号量。我们将这些操作封装成`Locker`类，在单独的文件中实现。

> 线程和进程的区别？

## 线程池类的定义

**考虑到实现，我们需要设置以下属性**

- 需要指定线程数量
- 需要指定任务队列的最大任务数
- 描述线程池的数组
- 请求队列
- 保护请求队列的互斥锁
- 对于读写事件的标志

```cpp
// 线程池类，将它定义为模板类是为了代码复用，模板参数T是任务类
template<typename T>
class ThreadPool {
public:
    /*thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/
    ThreadPool(int thread_number, int max_requests);
    ~ThreadPool();
    //插入任务函数
    bool Append(T* request, int event_flag);

private:
    /*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/
    //线程被创建的时候被指明执行该函数,我们会将this指针传递进去,因为静态函数无法访问成员变量
    static void* ThreadWorkFunc(void* arg);
    void ThreadRun();

private:    
    int thread_number_;            // 线程的数量    
    int max_requests_;             // 请求队列中最多允许的、等待处理的请求的数量 
    pthread_t * threads_;          // 描述线程池的数组，大小为thread_number_    
    std::list< T* > workqueue_;    // 请求队列
    Locker queuelocker_;           // 保护请求队列的互斥锁
    Sem queuestat_;                // 是否有任务需要处理
    bool stop_;                    // 是否结束线程   
    int event_flag_;               // 0:读事件  1:写事件               
};
```

> `ThreadWorkFunc`如果是一个普通的类成员函数，那么自带的默认参数this指针，和函数原型的`void *`冲突了。

## 函数分析



设置线程分离，从而让操作系统在该线程结束时来回收它所占的资源，不需要手动回收。
