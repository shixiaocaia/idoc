数据结构
===

## 关键点

常见的有五种：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。

支持了四种数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。

- 每种数据对象都各自的应用场景，说出它们各自的应用场景
- 针对具体的应用场景，使用哪种Redis数据类型来实现
- 掌握特性、实现、时间复杂度、各种操作
- 超热点：跳表、字典

## 对象

Redis是key-value存储，key和value在Redis中都被抽象为对象，key**只能是String对象**，而Value支持丰富的对象种类。

Object在内存当中包括：

- type：是哪种Redis)对象
- encoding：表示用哪种底层编码，用OB]ECT ENCODING[key]可以看到对应的编码方式
- lu：记录对象访问信息，用于内存淘汰，这个可以先忽略，后续章节会详细介绍。
- refcount：引用计数，用来描述有多少个指针，指向该对象
- ptr：内容指针，指向实际内容

## String

String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 `512M`。

### 适用场景

一般用来存字节数据、文本数据、序列化后的对象数据等。

### 使用



### 编码方式

采用不同编码方式来应对不同的场景，以达到高性能。

包含了三种编码方式：

- INT：存放可以用long表示的整数
- EMBSTR：字符串小于等于阈值字节
- RAW：字符串大于阈值字节

其中EMBSTR和RAW由redisObject和SDS（Simple Dynamic String）构成，EMBSTR下的redisObject和SDS是连续的内存，而RAW是离散的。

- EMBSTR有点在于可以一次性分配空间，毕竟是连续分布的，缺点是在修改后需要**整体重新分配空间**。
- 因此EMBSTR在发生写操作后，会变成RAW，默认当作发生过修改的字符串通常是易变的。
- 编码可能会发生转换
  - INT->RAW：当存的内容不再是整数，或者大小超过了long的时候。
  - EMBSTR->RAW：任何写操作之后EMBSTR都会变成RAW,原因前面有解释。

### 为什么使用SDS

- SDS 不仅可以保存文本数据，还可以保存二进制数据。不再以`\'0'`作为判断标准，二进制安全
- SDS 获取字符串长度的时间复杂度是 O(1)：增加了len长度字段，原生C是O(n)
- Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出：增加了空余空间（alloc - len)，有了预留空间，节约性能

## List









