数据结构
===

## 关键点

常见的有五种：String（字符串），Hash（哈希），List（列表），Set（集合）、Zset（有序集合）。

支持了四种数据类型： BitMap（2.2 版新增）、HyperLogLog（2.8 版新增）、GEO（3.2 版新增）、Stream（5.0 版新增）。

- 每种数据对象都各自的应用场景，说出它们各自的应用场景
- 针对具体的应用场景，使用哪种Redis数据类型来实现
- 掌握特性、实现、时间复杂度、各种操作
- 超热点：跳表、字典

---

- 采用多种底层实现编码的角度
  - 数据量小的情况，节省内存
  - 数据量大的情况，提高查找性能
  - 不同编码方式，查找的效率，对应到应用场景问题

## 对象

Redis是key-value存储，key和value在Redis中都被抽象为对象，key**只能是String对象**，而Value支持丰富的对象种类。

Object在内存当中包括：

- type：是哪种Redis对象
- encoding：表示用哪种底层编码，用OB]ECT ENCODING[key]可以看到对应的编码方式
- lu：记录对象访问信息，用于内存淘汰，这个可以先忽略，后续章节会详细介绍
- refcount：引用计数，用来描述有多少个指针，指向该对象
- ptr：内容指针，指向实际内容

## String

### 是什么

String 是最基本的 key-value 结构，key 是唯一标识，value 是具体的值，value其实不仅是字符串， 也可以是数字（整数或浮点数），value 最多可以容纳的数据长度是 `512M`。

适用场景：一般用来存字节数据、文本数据、序列化后的对象数据等。

### 使用

- 常用操作聚焦于创建、查询、更新和删除
- 创建，即产生一个字符串对象数据，可以用SET、SETNX
- 查询操作可以用GET,如果想一次获取多个，可以用MGET
- 而更新的话，其实也是用SET来更新的
- 删除就是针对String对象本身的销毁，用DEL命令

### 内部实现

采用不同编码方式来应对不同的场景，以达到高性能。

包含了三种编码方式：

- INT：存放可以用long表示的整数
- EMBSTR：字符串小于等于阈值字节
- RAW：字符串大于阈值字节

其中EMBSTR和RAW由**redisObject**和**SDS（Simple Dynamic String）**构成，EMBSTR下的redisObject和SDS是连续的内存，而RAW是离散的。

- EMBSTR有点在于可以一次性分配空间，毕竟是连续分布的，缺点是在修改后需要**整体重新分配空间**。
- 因此EMBSTR在发生写操作后，会变成RAW，默认当作发生过修改的字符串通常是易变的。
- 编码可能会发生转换
  - INT->RAW：当存的内容不再是整数，或者大小超过了long的时候。
  - EMBSTR->RAW：任何写操作之后EMBSTR都会变成RAW,原因前面有解释。

### 为什么使用SDS

- SDS 不仅可以保存文本数据，还可以保存二进制数据。不再以`\'0'`作为判断标准，二进制安全
- SDS 获取字符串长度的时间复杂度是 O(1)：增加了len长度字段，原生C是O(n)
- Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出：增加了空余空间（alloc - len)，有了预留空间，节约性能

## List

### 是什么

- Redis List是一组连接起来的**字符串集合**，按照插入顺序排序，可以从**头部和尾部**向List列表添加元素。
- List的最大元素个数是2^64 - 1。
- 作为一个列表存储，属于比较底层的数据结构，可以用于存储一批任务数据、存储一批消息等。

### 使用

- 常用操作还是聚焦于创建、查询、更新和删除。
- 创建即产生一个List对象，一般用**LPUSH、RPUSH**，分别对应从左侧进队列和右侧进队列。
- 对于查询，可以用**LRANGE**来进行范围查询，可以用**LLEN**查询元素个数。
- 更新的话，对列表对象而言就是追加元素、删除元素等操作，涉及**LPUSH，LPOP，RPUSH，RPOP**等操作。
- 删除就是针对List对象本身的生成和销毁，用**DEL**、**UNLINK**（4.0引入）命令。

### 内部实现

主要包括两种编码方式，ZIPLIST和LINKEDLIST。

当满足如下条件时，用ZIPLIST（**压缩列表**）编码

- 列表对象保存的所有字符串对象长度都小于64字节（默认值，可由 `list-max-ziplist-value` 配置）
- 列表对象元素个数少于512个，注意，这是LIST的限制，而不是ZIPLIST的限制

ZIPLIST底层用压缩列表实现，相邻元素紧凑压缩在一起，可以有效节约内存空间。

当不满足ZIPLIST编码条件，则使用LINKEDLIST（**双向链表**）编码，是几个STRING对象的链接结构。

- 通过链表形式，便于删除和插入
- 列表个数或者节点数据长度比较大的时候，使用LINKEDLIST编码可以加快处理（增长，删除）

**ZIPLIST是为了在数据较少情况时节约内存，LINKEDLIST是为了数据多时提高更新效率。**

为了优化解决上述问题，引入了**QUICKLIST**，二者的结合体，在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表。

- LINKEDLIST原来是单个节点，只能存一个数据，现在单个节点存的是一个ZIPLIST，存放了多个数据。

- 当数据较少，QUICKLIST节点只有一个时，此时相当于就是一个ZIPLIST。

 **ZIPLIST优化**：

Redis7.0使用LISTPACK（**紧凑列表**）的编码模式取代了ZIPLIST，本质上都是一种压缩列表。同时在LINKEDLIST中也用LISTPACK替代了ZIPLIST。

> LISTPACK是为了解决ZIPLIST连锁更新问题
>
> - ZIPLIST连锁更新是什么，如何造成的
>   - 当前一个节点大小超过254，会导致后面一个节点中prev值变化膨胀，接连后续变化，发生连锁更新
> - LISTPACK是如何解决的
>   - 引入一个不记录prevlen的变量，element-tot-len存储整个节点除它自身以外的长度，从这个节点的末尾再遍历element-tot-len长度，就能找到这个节点的开始位置。

### 消息队列

消息队列在存储消息时，必须要满足三个需求，分别是**消息保序、处理重复的消息和保证消息可靠性**。

- 消息保序：使用 LPUSH + RPOP；
- 阻塞读取：使用 BRPOP；
- 重复消息处理：生产者自行实现全局唯一 ID；
- 消息的可靠性：使用 BRPOPLPUSH

## Set

### 是什么

Redis的Set是一个不重复、无序的字符串集合。

适用于无序集合场景，比如某个用户关注了哪些公众号，这些信息可以放进一个集合当中。Set也提供了查交集、并集的功能，可以很方便地实现共同关注的能力。

### 使用

- 我们还是从创建、查询、更新、删除这几个基本操作来了解Set
- 创建即产生一个Set对象，可以使用SADD创建
- Set的查询非常丰富，SISMEMBR可以查询元素是否存在的；SCARD、SMEMBERS、SSCAN可以查询集合元素数据；SINTER、SUNION、SDIFF可以对多个集合查交集并集和差异。
- 更新的话，可以使用SADD增加元素，SREM删除元素
- 至于删除，和其它对象一样，DEL可以删除一个Set对象

### 内部实现

如果集群元素都是整数，且元素数量不超过512个，就可以用INTSET编码（**整数集合**），因为INTSET编码比较紧凑，内存占用少，但是查询时使用**二分查找**（有序集合）。

> Set是无序的，IntSet编码是有序的。

如果不满足INTSET的条件，就需要用HASHTABLE（**字典**），能O(1)时间就能找到一个元素是否存在。

> 数据指针部分，用的字典存储，能够O(1)查询，适合快速定位的场景。

**Set是有序的吗**

> Set的底层实现是整数集合或字典，前者是有序的，后者是无序的。整体来看，建议不依赖SET的顺序。

## HSet

### 是什么

Redis Hash是一个field、value都为string的hash表，存储在Redis的内存当中。

适用于O(1)时间字典查找某个field对应数据的场景，比如任务信息的配置，就可以将任务类型设置为filed，任务配置参数为value。

### 使用

- 我们还是从创建、查询、更新、删除这几个基本操作来了解HSet
- 创建即产生一个HSet对象，可以使用HSET、HSETNX创建
- 查询支持HGET查询单个元素；HGETALL查询所有数据；HLEN查询数据总数；HSCAN进行游标迭代查询
- 更新的话，HSET可以用于增加新元素，HDEL删除元素
- 至于删除，和其它对象一样，DEL可以删除一个HSet对象

### 内部实现

如果满足以下条件使用ZIPLIST（压缩列表)：

-  HSet对象保存的所有值和键的长度都小于64字节
- HSet对象元素少于512个

否则使用HASHTABLE。

## ZSet

### 是什么

ZSet就是有序集合，也叫Sorted Set，是一组按关联积分有序的字符串集合。

这里的分数是个抽象概念，任何指标都可以抽象为分数，以满足不同场景。积分相同的情况下，按字典序排序。

用于需要排序集合的场景，最为典型的就是游戏排行榜。

### 使用

- ZADD增加或者更新已存在数据，返回新增的数据
- ZREM删除ZSet中的元素
- ZCARD查看成员总数
- ZRANGE查询从start到stop范围的数据
- ZREVRANGE从大到小遍历
- ZCOUNT计算min-max积分范围内的成员个数
- ZRANK查看member的排名索引，索引从0开始
- ZSCORE查看ZSet中成员分数

### 内部实现

底层编码包括两种，ZIPLIST和SKIPLIST（**跳表**）+ HT。

同样在数据量比较小的时候，使用ZIPLIST

- 列表对象保存的所有字符串对象长度都小于64字节；
- 列表对象元素个数少于128个。

两个条件任何一条不满足，编码机构就用SKIPLIST + HT。

> SKIPLIST是一种可以快速查找的多级链表结构，可以当作是一个具有高级索引的链表

## Stream

### 是什么

对比List是一个拥有持久化能力的轻量级消息队列。

可以作为轻量级队列，可以支持发布订阅场景。

> 流ID：唯一表示一个Stream。

### 使用

- XADD，添加流数据
- XLEN，返回流数目
- XRANGE，范围查询流信息



## 过期时间

### 是什么

给定一个时间点key，到达时间，数据被认为是过期的，由Redis进行回收。

如果不是常驻的数据，设置过期时间，可以有效节约内存。

缓存设置过期时间，保证数据有效性。

### 使用

- SET key value EX seconds：设置多少秒后过期
- SET key value PX seconds：设置多少毫秒后过期
- TTL key：查询还有多久过期
- EXPIRE key seconds：对所有对象设置一个key的过期时间，单位秒
- PEXPIRE key milliseconds：设置一个key的过期时间，单位毫秒

设置过期时间之后会有个字典，专门记录这些Ky和过期时间的关系。

### 过期删除策略

过期后删除策略包括

- 定时删除：设置一个定时器，到期后全部删除，可能会短期删除过多
- 定期删除：定期检查，每次删除部分过期
- 惰性删除：待到再次访问使用时，判断过期后删除

实际中通过惰性删除 + 定期删除二者结合方式进行删除。

定期删除需要注意：

- 定期删除的频率：取决于Redis周期任务的执行频率
- 每次删除的数量：固定

## 对象引用计数

有点类似C++里面智能指针了，在redisObject结构有一个refcount字段，减少到0时，就会触发对象的释放。

注意这里目前是只有encoding为整数，并且在0-9999时才会有用，因为

- 0 - 9999这样的对象池，被使用的概率大，复用有场景
- 整数存储空间比较小，而分配这样的redisObject内部结构至少16字节，比本身还大，频繁分配占用过多的空间。
- 要复用对象，包含数值比较过程，整数对象进行比较，成本最低。

最大的作用，在内部场景中用refcount进行引用计数，传递参数参数时，避免拷贝。
