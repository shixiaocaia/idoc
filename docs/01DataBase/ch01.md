SQL
===
## SELECT

- 查询列表可以是：表中的字段、常量值、表达式、函数
- 查询结果是一个虚拟的表格

```bash
select name from student;     //检索单个列
select * from student;        //检索整个表格
select name, id from student; //选择多行

select distinct city from student; //只返回city中不同的行
select name from student limit 5;  //返回从头开始的5行
select name from student limit 5,3;//返回从第5行开始的3行

select student.name from student;  //使用完全限定的表名
```

## ORDER

```bash
select name from student order by name;   //以name列的字母排序
select id, name from student order by name, id desc; //选择多列，首先按照name，再按照id排序

select name from student order by name desc;   //以name列的字母降序排列
select id, name from student order by name desc, id; // 对name列降序，id升序

select id, name from student order by name desc, id
limit 1;//配合limit筛选最大值和最小值
```

> 降序 desc，升序asc。
>
> order by一般是最后的，除了limit

## WHERE

```bash
select * from student where city = "杭州"; //注意杭州是字符串需要加引号

select * from student where id > 5; //检测多个值

select * from student where city != '杭州';

select * from student where city is NULL;
```

> Where子句的位置应该在order之前，否则会出错。
>

```bash
select * from student where city != '河南' and city != '安徽';

select * from student where city = '河南' or city = '安徽';

select * from student where city in ('河南','安徽'); # 列表的值统一或者兼容

select * from student where city not in ('河南','安徽');

select * from student where id between 100 and 200;
```

> - and or同时使用时，加括号突出优先级。
>
> - 列表的值统一或者兼容

```bash
select * from student where city like '杭%'; #匹配前面

select * from student where address like '%隔壁'; #匹配后面

select * from student where address like '___隔壁';

select * from student where address like '_\__隔壁';
```

> - 通过`%`匹配不限字符数，通过`_`匹配，限定单个字符数。
> - 为了避免尾空格，应该在末尾加一个%，避免其影响。
> - `escape $`或者`\$`转义符号。
> - like不能和`NULL`匹配。
>
> - 通配符的效率低，能使用其他的就不要使用通配符，尽量不要从搜索模式的开头使用，（我猜从头开始搜索，所以效率低）。

```sql
select last_name from employee where commission_pct IS / IS NOT NULL;
```

> - = > < 不能判断NULL值
> - `IS`只能判断`NULL`
> - `IFNULL(commission, 0)`如果奖金为NULL，用0替代

## AND OR IN NOT IN



## IS NULL



## EXISTS



## CONCAT

```sql
 select concat(city,' ',address) from student;         
```

`RTrim`和`LTrim`处理所选列的左右空格。

- mysql中的+号
  - 两个操作数都为数值型，则做加法运算
  - 其中一个为字符型，试图将字符型转换为数值型，转换失败的话，字符型数值变成0进行运算
- **有一方为null，结果就是null**，所以实际拼接要进行判断，`ISNULL(exp1,exp2)`。

## AS

```sql
select concat(city,' ',RTrim(address)) as newtitle from student;
```

`as`给拼接字段的列起一个新的名字。

## LIMIT

```sql
LIMIT row_count OFFSET offset;
```

- 一般放在最后
- 一般结合orderby，输出指定行数的数据

## DISTINCT

```sql
SELECT DISTINCT department_id FROM employees;
```

- 可以针对多个字段
- 当 `DISTINCT` 遇到 `NULL` 值时，只保留一个 `NULL` 值。因为 `DISTINCT` 认为所有的 `NULL` 值都是相同的，这与字段的类型无关。

## LIKE

正则表达式是用来匹配文本的特殊的串（字符集合） ，用正则表达式语言来建立。

所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。

> MySQL仅支持多数正则表达式实现的一个很小的子集。

```bash
select * from student where city regexp '州';
select * from student where city like '州';
# 对比like和正则表达式，regexp匹配的是包含关系
```

```bash
select * from student where city regexp '10|20';
select * from student where city regexp '河|安|州';
select * from student where city regexp [123]; # '1|2|3'

select * from student where city regexp '[1-5] Ton'; # 匹配 1 Ton, 2 Ton,3 Ton...
select * from student where city regexp '[a-c] Ton'; # 匹配 a Ton, b Ton,c Ton...
```

### 匹配特殊字符

```cpp
select * from student where city regexp '\\.'
select * from student where city regexp '\\f'
\\f 换页
\\n 换行
\\r 回车
\\t 制表
\\v 纵向制表
\\ 转义符号
```

### 匹配字符类

```cpp
[:alnum:] 任意字母和数字（同[a-zA-Z0-9]）
[:alpha:] 任意字符（同[a-zA-Z]）
[:blank:] 空格和制表（同[\\t]）
[:cntr1:] ASCII控制字符（ASCII到31和127）
[:digit:] 任意数字（同[0-9]）
[:graph:] 与[：print:]相同，但不包括空格
[:lower:  任意小写字母（同[a-z]）
[:print:] 任意可打印字符
[:punct:] 既不在[：alnum:]又不在[：cntr1:]中的任意字符
[:space:] 包括空格在内的任意空白字符（同[\\fl\nl\rlltllv]）
[:upper:] 任意大写字母（同[A-Z]）
[:xdigit:] 任意十六进制数字（同[a-fA-F0-9]）
```

## USING

等值查询

## JOIN

用于将数据库中的两个表或者多个表组合起来。

- 交叉连接：全匹配，m * n
- 内连接：有条件的，不满足连接条件的不会显示
- 左连接：左表匹配右表，如果匹配成功则将左表和右表的行组合成新的数据行返回；如果匹配不成功则将左表的行和 NULL 值组合成新的数据行返回
- 右连接：与左连接相反

## 处理函数

### 文本处理函数

```sql
select concat(city,' ',RTrim(address)) as newtitle from student;
# RTrim() /  LTrim() 去除左边右边空格
select trim('a' from 'aaabbaa') as out put;
# 去除前后的字符

select city, upper(address) as newaddress from student;
# Upper() / Lower()文本大小写转换

Left() /  Right()
# 返回串左边 / 右边的字符

Length()
# 返回串的字节个数,需要考虑不同的字符集
 
Locate()
# 找出串的一个字串

Soundex()
# 返回串的SOUNDEX值
# 将任何文本串转换为描述其语音表示的字母数字模式的算法

SubString() / substr()
# 返回子串的字符

concat(str1, str2,str3)
# 拼接字符串

instr()
# 返回子串第一次出现的位置

lpad() / rpad()
# 用指定的字符，左填充到指定数量的字符数
 
replace()
# 字符串替换
```

### 日期和时间处理函数

```sql
AddDate()     增加一个日期（天、周等）
AddTime()     增加一个时间（时、分等）
CurDate()     返回当前日期
CurTime()     返回当前时间
Date()        返回日期时间的日期部分
DateDiff()    计算两个日期之差
Date_Add()    高度灵活的日期运算函数
Date_Format() 返回一个格式化的日期或时间串
Day()         返回一个日期的天数部分
Dayofweek()   对于一个日期，返回对应的星期几
Hour()        返回一个时间的小时部分
Minute()      返回一个时间的分钟部分
Month()       返回一个日期的月份部分
NowC()        返回当前日期和时间
Second()      返回一个时间的秒部分
Time()        返回一个日期时间的时间部分
Year()        返回一个日期的年份部分

str_to_date   将日期格式的字符转换成指定格式的日期
str_to_date('9-13-1999','%m-%d-%Y')

date_format  将日期转换为字符
date_format(now(), '%y年%m月%d日') as out_put


```

> 对于datatime的数据类型存储日期以及时间值，样例表中的值全具有时间值`00::00::00`，当我们直接使用`where order_date = '2005-09-01';`，与实际存储的`where order_data = '2005-09-01 11::30::14`冲突，应该用`where date(order_date) = '2005-09-01'`。

```sql
where date(order_date) between '2005-09-01' and '2005-10-01';
```

### 数值处理函数

```sql
round(X,2) 四舍五入
ceil() 向上取整
floor()向下取整
truncate() 截断
mod()  取余 a -a/b*b
Abs()  返回一个数的绝对值
Cos()  返回一个角度的余弦
Exp()  返回一个数的指数值
Mod()  返回除操作的余数
Pi()   返回圆周率
Rand() 返回一个随机数
Sin()  返回一个角度的正弦
Sqrt() 返回一个数的平方根
Tan()  返回一个角度的正切
```


### 流程控制函数

```sql
# IF
select if(10 < 5,'大','小')

# CASE
SELECT salary AS 原始工资, department_id,
CASE department_id
WHEN 30 THEN salary*1.1
WHEN 40 THEN salary*1.1
WHEN 50 THEN salary*1.1
ELSE salary
END AS 新工资
FROM employees;

SELECT salary,
CASE
WHEN salary > 20000 THEN 'A'
WHEN salary > 15000 THEN 'B'
WHEN salary > 10000 THEN 'C'
ELSE 'D'
END AS 工资级别
FROM employees;
```


### 聚集函数

运行在行组上，计算和返回单个值得函数。

```sql
select AVG(id) as avg_id from student;
select AVG(id) as avg_id from student where city = '杭州';
```

```sql
select count(*) as count_id from student;
select count(city) from student;
```

```sql
select max(id) from student;
select min(id) from student;
```

> 如果有多行结果时，MAX返回最后一行的，MIN返回最前面的行。
>

```sql
select sum(id) from student;
```

> - sum、avg一般用于处理数值型
> - max、min、count可以处理任何类型
> - 都会忽略值为NULL的行，如果没有忽略NULL值，与NULL值计算会全部变成NULL。

### 其他函数

```sql
select version();
select datebase();
select user();
```





