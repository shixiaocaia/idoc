SQL
===
## 查询列表

- 查询列表可以是：表中的字段、常量值、表达式、函数
- 查询结果是一个虚拟的表格

```bash
select name from student;     //检索单个列
select * from student;        //检索整个表格
select name, id from student; //选择多行

select distinct city from student; //只返回city中不同的行
select name from student limit 5;  //返回从头开始的5行
select name from student limit 5,3;//返回从第5行开始的3行

select student.name from student;  //使用完全限定的表名
```

## 排序查询

```bash
select name from student order by name;   //以name列的字母排序
select id, name from student order by name, id desc; //选择多列，首先按照name，再按照id排序

select name from student order by name desc;   //以name列的字母降序排列
select id, name from student order by name desc, id; // 对name列降序，id升序

select id, name from student order by name desc, id
limit 1;//配合limit筛选最大值和最小值
```

> 降序 desc，升序asc。
>
> order by一般是最后的，除了limit

## 条件查询

```bash
select * from student where city = "杭州"; //注意杭州是字符串需要加引号

select * from student where id > 5; //检测多个值

select * from student where city != '杭州';

select * from student where city is NULL;
```

> Where子句的位置应该在order之前，否则会出错。
>

```bash
select * from student where city != '河南' and city != '安徽';

select * from student where city = '河南' or city = '安徽';

select * from student where city in ('河南','安徽'); # 列表的值统一或者兼容

select * from student where city not in ('河南','安徽');

select * from student where id between 100 and 200;
```

> - and or同时使用时，加括号突出优先级。
>
> - 列表的值统一或者兼容

```bash
select * from student where city like '杭%'; #匹配前面

select * from student where address like '%隔壁'; #匹配后面

select * from student where address like '___隔壁';

select * from student where address like '_\__隔壁';
```

> - 通过`%`匹配不限字符数，通过`_`匹配，限定单个字符数。
> - 为了避免尾空格，应该在末尾加一个%，避免其影响。
> - `escape $`或者`\$`转义符号。
> - like不能和`NULL`匹配。
>
> - 通配符的效率低，能使用其他的就不要使用通配符，尽量不要从搜索模式的开头使用，（我猜从头开始搜索，所以效率低）。

```sql
select last_name from employee where commission_pct IS / IS NOT NULL;
```

> - = > < 不能判断NULL值
> - `IS`只能判断`NULL`
> - `IFNULL(commission, 0)`如果奖金为NULL，用0替代

## 正则表达式

正则表达式是用来匹配文本的特殊的串（字符集合） ，用正则表达式语言来建立。

所有种类的程序设计语言、文本编辑器、操作系统等都支持正则表达式。

> MySQL仅支持多数正则表达式实现的一个很小的子集。

```bash
select * from student where city regexp '州';
select * from student where city like '州';
# 对比like和正则表达式，regexp匹配的是包含关系
```

```bash
select * from student where city regexp '10|20';
select * from student where city regexp '河|安|州';
select * from student where city regexp [123]; # '1|2|3'

select * from student where city regexp '[1-5] Ton'; # 匹配 1 Ton, 2 Ton,3 Ton...
select * from student where city regexp '[a-c] Ton'; # 匹配 a Ton, b Ton,c Ton...
```

### 匹配特殊字符

```cpp
select * from student where city regexp '\\.'
select * from student where city regexp '\\f'
\\f 换页
\\n 换行
\\r 回车
\\t 制表
\\v 纵向制表
\\ 转义符号
```

### 匹配字符类

```cpp
[:alnum:] 任意字母和数字（同[a-zA-Z0-9]）
[:alpha:] 任意字符（同[a-zA-Z]）
[:blank:] 空格和制表（同[\\t]）
[:cntr1:] ASCII控制字符（ASCII到31和127）
[:digit:] 任意数字（同[0-9]）
[:graph:] 与[：print:]相同，但不包括空格
[:lower:  任意小写字母（同[a-z]）
[:print:] 任意可打印字符
[:punct:] 既不在[：alnum:]又不在[：cntr1:]中的任意字符
[:space:] 包括空格在内的任意空白字符（同[\\fl\nl\rlltllv]）
[:upper:] 任意大写字母（同[A-Z]）
[:xdigit:] 任意十六进制数字（同[a-fA-F0-9]）
```

## 创建计算字段

字段（field）基本上与列（column）的意思相同，字段通常用在计算字段的连接上。

> 只有数据库知道SELECT语句中哪些列是实际的 表列，哪些列是计算字段。从客户机（如应用程序）的角度来看，计算字段的数据是以与其他列的数据相同的方式返回的。

### 拼接字段

```sql
 select concat(city,' ',address) from student;         
```

`RTrim`和`LTrim`处理所选列的左右空格。

- mysql中的+号
  - 两个操作数都为数值型，则做加法运算
  - 其中一个为字符型，试图将字符型转换为数值型，转换失败的话，字符型数值变成0进行运算
- **有一方为null，结果就是null**，所以实际拼接要进行判断，`ISNULL(exp1,exp2)`。

### 使用别名

```sql
select concat(city,' ',RTrim(address)) as newtitle from student;
```

`as`给拼接字段的列起一个新的名字。

### 去重

```sql
SELECT DISTINCT department_id FROM employees;
```

### 算数运算

```sql
select name,price*nums as sum from fruits;
```

MySQL支持基本的加减乘除运算。

## 处理函数

### 文本处理函数

```sql
select concat(city,' ',RTrim(address)) as newtitle from student;
# RTrim() /  LTrim() 去除左边右边空格
select trim('a' from 'aaabbaa') as out put;
# 去除前后的字符

select city, upper(address) as newaddress from student;
# Upper() / Lower()文本大小写转换

Left() /  Right()
# 返回串左边 / 右边的字符

Length()
# 返回串的字节个数,需要考虑不同的字符集
 
Locate()
# 找出串的一个字串

Soundex()
# 返回串的SOUNDEX值
# 将任何文本串转换为描述其语音表示的字母数字模式的算法

SubString() / substr()
# 返回子串的字符

concat(str1, str2,str3)
# 拼接字符串

instr()
# 返回子串第一次出现的位置

lpad() / rpad()
# 用指定的字符，左填充到指定数量的字符数
 
replace()
# 字符串替换
```

### 日期和时间处理函数

```sql
AddDate()     增加一个日期（天、周等）
AddTime()     增加一个时间（时、分等）
CurDate()     返回当前日期
CurTime()     返回当前时间
Date()        返回日期时间的日期部分
DateDiff()    计算两个日期之差
Date_Add()    高度灵活的日期运算函数
Date_Format() 返回一个格式化的日期或时间串
Day()         返回一个日期的天数部分
Dayofweek()   对于一个日期，返回对应的星期几
Hour()        返回一个时间的小时部分
Minute()      返回一个时间的分钟部分
Month()       返回一个日期的月份部分
NowC()        返回当前日期和时间
Second()      返回一个时间的秒部分
Time()        返回一个日期时间的时间部分
Year()        返回一个日期的年份部分

str_to_date   将日期格式的字符转换成指定格式的日期
str_to_date('9-13-1999','%m-%d-%Y')

date_format  将日期转换为字符
date_format(now(), '%y年%m月%d日') as out_put


```

> 对于datatime的数据类型存储日期以及时间值，样例表中的值全具有时间值`00::00::00`，当我们直接使用`where order_date = '2005-09-01';`，与实际存储的`where order_data = '2005-09-01 11::30::14`冲突，应该用`where date(order_date) = '2005-09-01'`。

```sql
where date(order_date) between '2005-09-01' and '2005-10-01';
```

### 数值处理函数

```sql
round(X,2) 四舍五入
ceil() 向上取整
floor()向下取整
truncate() 截断
mod()  取余 a -a/b*b
Abs()  返回一个数的绝对值
Cos()  返回一个角度的余弦
Exp()  返回一个数的指数值
Mod()  返回除操作的余数
Pi()   返回圆周率
Rand() 返回一个随机数
Sin()  返回一个角度的正弦
Sqrt() 返回一个数的平方根
Tan()  返回一个角度的正切
```


### 流程控制函数

```sql
# IF
select if(10 < 5,'大','小')

# CASE
SELECT salary AS 原始工资, department_id,
CASE department_id
WHEN 30 THEN salary*1.1
WHEN 40 THEN salary*1.1
WHEN 50 THEN salary*1.1
ELSE salary
END AS 新工资
FROM employees;

SELECT salary,
CASE
WHEN salary > 20000 THEN 'A'
WHEN salary > 15000 THEN 'B'
WHEN salary > 10000 THEN 'C'
ELSE 'D'
END AS 工资级别
FROM employees;
```
### 其他函数

```sql
select version();
select datebase();
select user();
```

## 汇总数据

### 聚集函数

运行在行组上，计算和返回单个值得函数。

```sql
select AVG(id) as avg_id from student;
select AVG(id) as avg_id from student where city = '杭州';
```

```sql
select count(*) as count_id from student;
select count(city) from student;
```

```sql
select max(id) from student;
select min(id) from student;
```

> 如果有多行结果时，MAX返回最后一行的，MIN返回最前面的行。
>

```sql
select sum(id) from student;
```

> - sum、avg一般用于处理数值型
> - max、min、count可以处理任何类型
> - 都会忽略值为NULL的行，如果没有忽略NULL值，与NULL值计算会全部变成NULL。

### 聚合不同的值

```sql
select AVG(distinct id) as id_avg from student;
```

> 默认是ALL，不需要指定。
>
> 使用DISTINCT参数，会考虑不同的数值大小。

### 组合聚集函数

```sql
select AVG(id) as id_avg,count(id) as num from student;
```

> 注意逗号分割。

## 分组数据

### 创建分组

```sql
select city, count(*) as num_city from student
group by city;
```

### 过滤分组

```sql
select city, count(*) as num_city from student
group by city
having count(*) >= 2;
```

> where和having在大部分情况下都是等价的。
>
> 区别在于where在数据分组前进行过滤，having在数组分组后进行过滤。
>
> 在分组前加一个where可以过滤更多信息内容。

### 加排序

```sql
select city, count(*) as num_city from student
group by city
having count(*) >= 2
order by num_city;
```

## 使用子查询

### 子查询过滤

通过子查询把一条select的结果用于另一条select语句的where子句。

```sql
select cust_id
from orders
where order_num IN (select order num
                    from orderitems
                    where prod_id = 'TNT2');
```

> 使用子循环不限制规模，但是一般考虑到性能，不会嵌套太多。此外嵌套太多，难以阅读和调试。

### 作为计算字段使用子查询

```sql
select cust_name,
	   cust_state,
	   (select count(*)
       from orders
       where orders.cust_id = customers.cust_id) as orders
from customers
ordered by cust_name;
```

> 注意这里的orders.cust_id和customers.cust_id，否则默认是对比orders这个表中的id值，造成错误。

## 联结表

### 关系表

关系表的实际是保证把信息分解成多个表，一类数据一个表。各个表通过某些常用的值（即关系设计中的关系）互相关联。

例如构建一个vendors表包含所有供应商的信息，每个供应商占一行，每个供应商具有唯一的表示id，作为主键。

products中存放产品信息，它除了存储供应商ID外不存储其他供应商信息，vendors表的主键ID作为products的**外键**，它讲vendors表和products表关联，利用供应商ID能从vendors表中找出相应供应商的详细信息。

### 联结

使用特殊语法，可以联结多个表返回一组输出，联结在运行时关联表中的正确行。

> 应该保证所有的联结都有WHERE子句，否则MySQL将返回比想要的数据更多，出现笛卡尔积数量的数据。
>
> 联结表的数量没有限制，但是为了性能考虑，减少非必要的联结。

### 使用表别名

```sql
select cust_name, cutst_contact
from customers as c, orders as o, orderitems as oi
where c.cust_id = o.cust_id
	and oi.order_num = o.order_num
	and prod_id = 'TNT2';
```

> 表别名可以用于WHERE子句，还可以用于SELECT的列表，ORDER BY子句等。

### 自联结

自联结是通过使用两个相同的表，进行查询，在实际中可以**对比和子查询**的效率，择优选择。

