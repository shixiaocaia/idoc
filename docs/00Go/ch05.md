Gin
===

[第三方中文文档](https://www.kancloud.cn/shuangdeyu/gin_book/949411)



## 是什么

Gin 是 Go 语言写的一个 web 框架，它具有运行速度快，分组的路由器，良好的崩溃捕获和错误处理，非常好的支持中间件和 json。总之在 Go 语言开发领域是一款值得好好研究的 Web 框架，开源网址：github.com/gin-gonic/gin

gin有如下特点：

- 接入成本非常低，作为一个组件，这是最重要的一点
- 拥有强大的中间件功能，用户可以自主定制需要的功能
- 由于使用了radix树，路由的性能很高。
- 数据绑定，让用户可以非常方便地从请求中获取想要的结构体。

## Run

```go
go get -u github.com/gin-gonic/gin
```

## GET POST PUT DELETE

### GET + POST获取参数

```go
func main() {
	router := gin.Default()

	router.POST("/post", func(c *gin.Context) {

		id := c.Query("id")
		page := c.DefaultQuery("page", "0")
		name := c.PostForm("name")
		message := c.PostForm("message")

		fmt.Printf("id: %s; page: %s; name: %s; message: %s", id, page, name, message)
	})
	router.Run(":8080")
}
```

- GET在后缀中`/post?id=1234&page=1 HTTP/1.1`，通过`Query`获取

- POST在BODY中的form_data中设置，通过`postman`获取   

## 模型绑定和验证

- 若要将请求主体绑定到结构体中，请使用模型绑定，目前支持JSON、XML、YAML和标准表单值(foo=bar&boo=baz)的绑定
- 需要在绑定的字段上设置tag，比如，绑定格式为json，需要这样设置 `json:"fieldname"`
  - 常使用json，uri
  - 如果一个字段用`binding:"required"`修饰，并且在绑定时该字段的值为空，那么将返回一个错误。
- 一般使用ShouldBind
- 可以自定义验证器

```go
func mustBig(f1 validator.FieldLevel) bool {
	fmt.Println(f1.Field().Interface().(int))
	return true
}

if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
    v.RegisterValidation("mustBig", mustBig)
}
```

- `ShouldBindQuery` 函数只绑定Get参数，不绑定post数据
- `ShouldBind`如果是GET请求会绑定查询字符串中的参数，
  - 如果是POST请求，优先绑定form表单或Json字符串中的数据，如果没有也可以绑定查询字符串中的数据

## 文件接受和返回

- gin中的saveupFile实际是本地先读取，再拷贝到创建的文件当中

```go
func main() {
	r := gin.Default() //携带中间件启动

	r.POST("/testUpload", func(c *gin.Context) {
		file, _ := c.FormFile("file")
		//c.SaveUploadedFile(file, "./"+file.Filename)
		in, _ := file.Open()
		defer in.Close()
		out, _ := os.Create("./" + file.Filename)
		defer out.Close()
		io.Copy(out, in)
		c.JSON(200, gin.H{
			"msg": file,
		})
	})

	r.Run(":8080") // listen and serve on 0.0.0.0:8080
}
```

- 不论是多文件上传还是单文件上传，获取`form.File["file"]`中的`file`名称只需要与前端HTML表单中的文件上传字段名称保持一致。

```go
func main() {
	router := gin.Default()
	// 给表单限制上传大小 (默认 32 MiB)
	// router.MaxMultipartMemory = 8 << 20  // 8 MiB
	router.POST("/testUpload", func(c *gin.Context) {
		// 多文件
		form, _ := c.MultipartForm()
		files := form.File["upload"]

		for _, file := range files {
			log.Println(file.Filename)

			// 上传文件到指定的路径
			// c.SaveUploadedFile(file, file.Filename)
		}
		c.String(http.StatusOK, fmt.Sprintf("%d files uploaded!", len(files)))
	})
	router.Run(":8080")
}

```

## 中间件和路由分组

对router创建group就是分组，同一分组就会有同一前缀和中间件。

```go
func main() {
	r := gin.Default() //携带中间件启动, 基础路由器
	//v1 := r.Group("v1")
	r.GET("test", func(c *gin.Context) {
		fmt.Println("我在分组方法内")
		c.JSON(200, gin.H{
			"success": true,
		})
	})

	r.Run(":8080") // listen and serve on 0.0.0.0:8080
}

```

- 区别加了分组v1和直接对r发起GET请求

### 为什么分组

- 结构更加清晰
- 方便管理路由
  - 专属的中间件

> **什么是中间件**
>
> 在请求到达路由方法**前后**的一些列操作

- 执行的顺序是一种洋葱中间件的形式
  - 1-1
  - 2-1
  - 3
  - 2-2
  - 1-2

```go
func middle() gin.HandlerFunc {
	return func(c *gin.Context) {
		fmt.Println("我在方法1前")
		c.Next() // 是否往下走, 洋葱中间件
		fmt.Println("我在方法1后")
	}
}

func middle2() gin.HandlerFunc {
	return func(c *gin.Context) {
		fmt.Println("我在方法2前")
		c.Next() // 是否往下走, 洋葱中间件
		fmt.Println("我在方法2后")
	}
}

func main() {
	r := gin.Default() //携带中间件启动, 基础路由器
	v1 := r.Group("v1").Use(middle(), middle2())
	v1.GET("test", func(c *gin.Context) {
		fmt.Println("我在分组方法内")
		c.JSON(200, gin.H{
			"success": true,
		})
	})

	r.Run(":8080") // listen and serve on 0.0.0.0:8080
}
```

### 中间件

```go
func main() {
    r := gin.Default() // 默认启动方式，包含了Logger、 Recovery中间件
    
    
    // 新建一个没有任何默认中间件的路由
    r := gin.New()

    // 全局中间件
    // Logger 中间件将日志写入 gin.DefaultWriter，即使你将 GIN_MODE 设置为 release。
    // By default gin.DefaultWriter = os.Stdout
    r.Use(gin.Logger())

    // Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500。
    r.Use(gin.Recovery())

    // 你可以为每个路由添加任意数量的中间件。
    r.GET("/benchmark", MyBenchLogger(), benchEndpoint)

    // 认证路由组
    // authorized := r.Group("/", AuthRequired())
    // 和使用以下两行代码的效果完全一样:
    authorized := r.Group("/")
    // 路由组中间件! 在此例中，我们在 "authorized" 路由组中使用自定义创建的 
    // AuthRequired() 中间件
    authorized.Use(AuthRequired())
    {
        authorized.POST("/login", loginEndpoint)
        authorized.POST("/submit", submitEndpoint)
        authorized.POST("/read", readEndpoint)

        // 嵌套路由组
        testing := authorized.Group("testing")
        testing.GET("/analytics", analyticsEndpoint)
    }

    // 监听并在 0.0.0.0:8080 上启动服务
    r.Run(":8080")
}
```

## 日志以及日志格式

### 有什么用

- 记录参数信息
- 猜测用户行为
- 复现系统bug并修复

### 怎么用

- 默认日志文件打印在控制台
- 建议自定义日志格式
- 第三方日志中工具
  - logrus
  - go-logging
- 日志切割
  - 自行根据时间在写入时判断进行切割日志
  - 借助成品的日志包：go-file-rotatelogs  / file-rotatelogs
- 一般在中间件当中使用

## 使用GORM操作数据库

