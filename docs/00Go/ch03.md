Gorm框架
===

[GORM README](https://gorm.io/zh_CN/docs/index.html)

[1010class基础使用](https://github.com/piexlmax/1010class)

[李文周博客](https://www.liwenzhou.com/)

## 原生的DataBase

### DataBase

- 原生的driver和sql库使用连接池，来提高查询效率
- 原生的sql查询需要用scan绑定，其中包含了close，不调用scan绑定参数，会导致数据库连接没有正确的释放

### MySQL预处理

- 普通SQL语句执行过程：

> 1. 客户端对SQL语句进行占位符替换得到完整的SQL语句。
> 2. 客户端发送完整SQL语句到MySQL服务端
> 3. MySQL服务端执行完整的SQL语句并将结果返回给客户端。

- 预处理执行过程：

> 1. 把SQL语句分成两部分，命令部分与数据部分。
> 2. 先把命令部分发送给MySQL服务端，MySQL服务端进行SQL预处理。
> 3. 然后把数据部分发送给MySQL服务端，MySQL服务端对SQL语句进行占位符替换。
> 4. MySQL服务端执行完整的SQL语句并将结果返回给客户端。

- 什么时候使用预处理
  - 重复执行SQL，只是占位符不同，提高执行的效率
- 为什么使用预处理
  - 优化MySQL服务器重复执行SQL的方法，可以提升服务器性能，提前让服务器编译，一次编译多次执行，节省后续编译的成本。
  - 避免SQL注入问题。

### SQL注入

直接使用用户输入的语句，进行拼接使用，可能出现问题，非法窃取数据。

> 我们任何时候都不应该自己拼接SQL语句，不应该轻易相信别人，避免数据库被破坏。

### 事务操作

MySQL中Innodb数据库引擎才支持事务。事务处理来维护数据库的完整性，保证成批的SQL语句要么全部执行，要么全部不执行

事物的ACID：

- 原子性
- 一致性
- 隔离性
- 持久性



## 什么是gorm

GORM让你的数据库里面的**表结构**变成你**代码定义的数据结构**（golang里面的结构体），代码结构即为数据库结构，代码行为即为数据库行为。

### 安装GORM

```go
go get -u gorm.io/gorm
go get -u gorm.io/driver/sqlite
```

### 链接MySQL

```go
db, _ := gorm.Open(mysql.New(mysql.Config{
    DSN: "root:1127@tcp(127.0.0.1:3306)/gorm_class?charset=utf8mb4&parseTime=True&loc=Local",
    DefaultStringSize: 256,
}), &gorm.Config{
    SkipDefaultTransaction: true,
    NamingStrategy: schema.NamingStrategy{
        TablePrefix:   "gva_", 
        SingularTable: false,  		// skip the snake_casing of names
    },
    DisableForeignKeyConstraintWhenMigrating: true, // 主张逻辑外键
})
```

- 学习gorm.Config设置，有一些设置需要提前设置好
  - DefaultStringSize
  - 跳过默认事务：SkipDefaultTransaction
  - 命名规则：NamingStrategy
  - 主张逻辑外键：DisableForeignKeyConstraintWhenMigrating

```go
sqlDB, _ := db.DB()
sqlDB.SetConnMaxIdleTime(10)
sqlDB.SetMaxOpenConns(100)
sqlDB.SetConnMaxLifetime(time.Hour)
```

- 配置连接池

### 建表以及关键api

```go
type User struct {
    Name string
}

type UserTwo struct {
    Name string
}

M := db.Migrator()
//M.CreateTable(&User{})
if M.HasTable(&User{}) {
    //M.DropTable(&User{})
    M.RenameTable(&User{}, &UserTwo{})
} else {
    M.RenameTable(&UserTwo{}, &User{})
}
```

- db.AutoMigrate(User)自动迁移（自动建表）
- Migrator接口一个统一的api接口
  - CreateTable(&结构体)创建表
  - HasTable是否存在表
  - DropTable删除表
  - RenameTable重命名表

## 模型创建和关键标签

### 模型

- 一个结构体，携带gorm规定的标签或者实现了gorm的接口
- 是gorm进行各种操作的基础

### 约定

- 默认情况下，GORM使用ID作为主键，使用结构体名的蛇形复数作为表名
- 字段名的蛇形作为列名，并使用CreatedAt、UpdatedAt字段追踪创建、更新时间

### 字段标签

```go
type Model struct {
	UUID uint      `gorm:"primaryKey"`
	Time time.Time `gorm:"column:my_time"`
}

type TestUser struct {
	Model        Model   `gorm:"embedded;embeddedPrefix:qm_"`
	Name         string  `gorm:"default:qm"`
	Email        *string `gorm:"not null"`
	Age          uint8   `gorm:"comment:年龄"`
	Birthday     *time.Time
	MemberNumber sql.NullString
	ActivatedAt  sql.NullTime
}
```

- 嵌入结构体，以匿名方式放入，它将会自动继承所有字段。如果不想用匿名结构，可以加入`embedded`标签。
- 关键标签`embeddedPrefix:qm_`通过这个来区分是不是匿名结构进入的。

## 增删改查

- 增删查改基本都需要先进行查询，再做更新、删除等操作。

### 创建

```go
func CreatedTest() {
	dbres := GLOBAL_DB.Create(&[]TestUser{
		{Name: "Mikke", Age: 18},
		{Name: "kk", Age: 18},
		{Name: "Mikke", Age: 18},
		{Name: "Mkkike", Age: 18},
	})
	fmt.Println(dbres.Error, dbres.RowsAffected)
	if dbres.Error != nil {
		fmt.Println("build error")
	} else {
		fmt.Println("build success")
	}
}


db.Select("Name", "Age").Create(&user)
```

- 使用select关键词，为指定字段分配值，忽略其他值
- 使用omit跳过某些字段
- 使用了切片形式创建多个记录值`db.Create(&[]一个模型)`

### 查询

```go
func TestFind() {
	result := map[string]interface{}{}
	//用map来接受

	var User []TestUser
	dbRes := GLOBAL_DB.Model(&TestUser{}).Last(&User, 14)
	fmt.Println(errors.Is(dbRes.Error, gorm.ErrRecordNotFound))
	.Where("name = ? AND age = ?", "Mike", 18).First(&User)

	//内联条件
	GLOBAL_DB.First(&User, "name = ?", "qm")
	GLOBAL_DB.First(&User, map[string]interface{}{
		"name": "qm",
	})
	GLOBAL_DB.First(&User, TestUser{Name: "qm"})

	GLOBAL_DB.Omit("name").Where("name <> ?", "Mike").Find(&User)
	fmt.Println(User)

	//智能选择字段
	var u UserInfo
	// Model主动告知结果
	GLOBAL_DB.Model(&TestUser{}).Where("name LIKE ?", "%e%").Find(&u)
	fmt.Println(u)

}
```

- 接受返回值的形式
  - map
    - map[string]interface{}
    - []Map[string]interface{}
  - 结构体
- 查询主键排序后的第一条 / 最后一条：`db.First(&model)` / `db.Last(&model)`
- 查询第一条（不排序）：`db.Take`
- 条件
  - 主键检索
  - string条件 where
  - struct & map
    - 可以加入一个有内容的结构体作为条件
    - 也可以使用一个key为数据库表字段的Map作为条件
  - 内联条件
    - 省略Where，直接在得到结果后面的Find First后面书写条件
- Select指定字段

### 更新

- update 只更新你选择的字段
- updates 更新所有字段，此时有两种方式，一种为Map，一种为结构体，结构体零值不参与更新
- save 无论如何都更新，所有的内容，包括零值
  - 如果不存在，会执行创建

### 删除

- 用法同Find First等
- 使用deletedat，字端存在则会**软删除**
  - 使用Unscoped()强制删除，忽略软删除进行查询

### SQL

使用Raw字段，再用SQL直接进行CRUD

## Belongs To 

`belongs to` 会与另一个模型建立了一对一的连接。

一个用户属于一家公司，用户是查询的主体。

**知道谁是主体，后序查询针对主题查询，再加以预加载**

> 舔狗属于女神，女神不知道舔狗的存在。  

```go
// `User` 属于 `Company`，`CompanyID` 是外键
type User struct {
  gorm.Model
  Name      string
  CompanyID int		// 外键
  Company   Company
}

type Company struct {
  ID   int
  Name string
}
```

- 在 `User` 对象中，有一个和 `Company` 一样的 `CompanyID`。 默认情况下， `CompanyID` 被隐含地用来在 `User` 和 `Company` 之间创建一个外键关系。
- 当我们创建了User表，也会连带出现Company表，因为User属于Company。（舔狗心里有着女神
- 当我们查询User时，如果要显示挂着的公司信息，需要使用预加载

### 重写外键

```
type User struct {
  gorm.Model
  Name         string
  CompanyRefer int
  Company      Company `gorm:"foreignKey:CompanyRefer"`
  // 使用 CompanyRefer 作为外键
}
```

定义一个belongs to 关系，必须存在外键，默认情况是**拥有者的类型名（Company）**加上**表的主键**名字字段。

同时也支持，使用关键标签自定义外键。

> 外键值变量是哪个，默认CompanyID，这里改成了CompanyRefer。

### 重写引用

在一般情况下，把主表（拥有者）的主键值ID作为外键CompanyID的参考值，通过使用`references`改变引用，使用code作为外键的参考值

```go
type User struct {
  gorm.Model
  Name      string
  CompanyID string
  Company   Company `gorm:"references:Code"` // 使用 Code 作为引用
}

type Company struct {
  ID   int
  Code string
  Name string
}
```

> 默认我们把主键值给User的外键，这里我们把Code字段给外键值变量CompanyID

> **NOTE** 如果外键名恰好在拥有者类型中存在，GORM 通常会错误的认为它是 `has one` 关系。我们需要在 `belongs to` 关系中指定 `references`

## Has One

表明一个模型的每个实例都包含或拥有另一个模型的一个实例。

用户拥有信用卡，用户是查询的主体。

> 舔狗把链子UserID给了女神

### 声明

```go
// User 有一张 CreditCard，UserID 是外键
type User struct {
  gorm.Model
  CreditCard CreditCard
}

type CreditCard struct {
  gorm.Model
  Number string
  UserID uint
}
```

- 当我们创建User表时，不会连带着CreditCard，因为User不依赖信用卡（女神不依存舔狗
- 添加一个User时，也不会增加信用卡记录
- 当我们创建一个User，并且带卡的，信用卡中会自动关联User的主键ID（UserID外键）
- 当我们查询User时，需要预加载才能出现信用卡信息
- 添加、删除、更换注意加载模型主体是User，预加载是信用卡

### 检索

```go
// 检索用户列表并预加载信用卡
func GetAll(db *gorm.DB) ([]User, error) {
    var users []User
    err := db.Model(&User{}).Preload("CreditCard").Find(&users).Error
    return users, err
}
```

> 预加载可以知道身上挂着的关系具体结构是什么

### 重写外键

对于`has one`同样必须存在外键字段，拥有者将把属于它的模型的主键保存到这个字段。

例如上述的`UserID`，为 user 添加 credit card 时，它会将 user 的 `ID` 保存到自己的 `UserID` 字段。

```go
type User struct {
  gorm.Model
  CreditCard CreditCard `gorm:"foreignKey:UserName"` // 使用 UserName 作为外键
}

type CreditCard struct {
  gorm.Model
  Number   string
  UserName string
}
```

这里指定放到UserName当中。

### 重写引用

```go
type User struct {
  gorm.Model
  Name       string     `gorm:"index"`
  CreditCard CreditCard `gorm:"foreignKey:UserName;references:name"`
}

type CreditCard struct {
  gorm.Model
  Number   string
  UserName string
}
```

把User中name的值放到UserName当中，而不是使用主键值ID。

## Has Many

### 声明

```go
type Dog struct {
	ID   int
	Name string
	Toys []Toy `gorm:"polymorphic:Owner;"`
}

type Toy struct {
	ID        int
	Name      string
	OwnerID   int
	OwnerType string
}
```

一条狗具有多个玩具。

### 检索

```go
var dog Dog
GLOBAL_DB.Preload("Toys", "name = ?", "toy2").First(&dog)
fmt.Println(dog)
```

- 使用内敛条件筛选

```go
var dog Dog
GLOBAL_DB.Preload("Toys", func(db *gorm.DB) *gorm.DB {
    return db.Where("name = ?", "toy1")
}).First(&dog)
fmt.Println(dog)
```

- 使用自定义预加载SQL

```go
var dog Dog
GLOBAL_DB.Preload("Toys.Info").Preload("Toys", "Name = ?", "toy1").First(&dog)
fmt.Println(dog)
```

- 预加载信息，并筛选关联信息

- 查询条件，只适用于当前预加载的层，**视频[13:49]问题**

```go
var dog Dog
GLOBAL_DB.Preload("Toys", func(db *gorm.DB) *gorm.DB {
    return db.Joins("Info").Where("price > 200")
}).First(&dog)
fmt.Println(dog)
```

- 在预加载的关系模型是一对一关系时，比如toy和他的Info是hasone关系，想拿到关系中某个参数作为条件，作为最外层需要带出来的信息的查询条件，就用Joins
- 可以使用join

## Many To many

Many to Many 会在两个 model 中添加一张连接表。

例如，您的应用包含了 user 和 language，且一个 user 可以说多种 language，多个 user 也可以说一种 language。

```sql
// User 拥有并属于多种 language，`user_languages` 是连接表
type User struct {
  gorm.Model
  Languages []Language `gorm:"many2many:user_languages;"`
}

type Language struct {
  gorm.Model
  Name string
}
```

当使用 GORM 的 `AutoMigrate` 为 `User` 创建表时，GORM 会自动创建连接表。

### 多态

- 夹子和御姐同时拥有小风车，使用多态，省去小风车中的重复的外键

- 使用两个字段，确定到不同表中去，OwnerType相当于起别名

  ```go
  OwnerID   int
  OwnerType string
  ```

- 多态不可以被同时拥有，但是可以同时拥有多个多态

### 关系标签

- foreignKey
- references

关于多对多中连接表的设置foreignKey和references，没有太理解起

```go
type User struct {
    gorm.Model
    Profiles []Profile `gorm:"many2many:user_profiles;foreignKey:Refer;joinForeignKey:UserReferID;References:UserRefer;joinReferences:ProfileRefer"`
    Refer    uint      `gorm:"index:,unique"`
}

type Profile struct {
    gorm.Model
    Name      string
    UserRefer uint `gorm:"index:,unique"`
}

// 会创建连接表：user_profiles
//   foreign key: user_refer_id, reference: users.refer
//   foreign key: profile_refer, reference: profiles.user_refer
```

## 事务

想做什么提前规划好，遇到计划以外的情况就全盘放弃或者根据条件选择性放弃。

为了确保数据一致性，GORM 会在事务里执行写入操作（创建、更新、删除）。如果没有这方面的要求，您可以在初始化时禁用它，这将获得大约 30%+ 性能提升。

```go
func TestTransaction() {
	//GLOBAL_DB.AutoMigrate(&TMG{})
	GLOBAL_DB.Transaction(func(tx *gorm.DB) error {
		tx.Create(&TMG{Name: "Mike"})
		tx.Create(&TMG{Name: "Mikk"})
		tx.Create(&TMG{Name: "Mikkkkk"})
		tx.Transaction(func(tx *gorm.DB) error {
			tx.Create(&TMG{Name: "CCCCCCC"})
			return errors.New("X")
		})
		fmt.Println("Finish transaction")
		return nil
	})
}
```

- 事务是以区域划分，嵌套内的事务检测到错误，CCC就不会被创建（回滚），外层的事务正常运行

```go
tx := GLOBAL_DB.Begin()
tx.Create(&TMG{Name: "Mik"})
tx.Create(&TMG{Name: "Mikkk"})
tx.Create(&TMG{Name: "Mikkkkkkkkk"})
tx.Commit() //手动事务commit生效
```

- 所做的事务应该在Commit之前

```go
//GLOBAL_DB.AutoMigrate(&TMG{})
tx := GLOBAL_DB.Begin()
tx.Create(&TMG{Name: "KKKK"})
tx.SavePoint("duo")
tx.Create(&TMG{Name: "XXXX"})
tx.RollbackTo("duo")
tx.Commit() //手动事务commit生效
```

- Rollback，回滚后事务并不会生效
- SavePoint记录点，然后可以回滚到记录点duo

## 自定义数据类型

自定义类型，在需要输入和输出时，需要实现对应的类型接口函数

- Value函数
- Scan函数

```go
package main

import (
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
)

type Args []string
type CInfo struct {
	Name string
	Age  int
}

func (a Args) Value() (driver.Value, error) {
	if len(a) > 0 {
		var str string = a[0]
		for _, v := range a[1:] {
			str += "," + v
		}
		return str, nil
	} else {
		return "", nil
	}
}

func (a *Args) Scan(value interface{}) error {
	str, ok := value.([]byte)
	if !ok {
		return errors.New("不匹配的数据类型")
	}
	*a = strings.Split(string(str), ",")

	return nil
}

func (c CInfo) Value() (driver.Value, error) {
	str, err := json.Marshal(c)
	if err != nil {
		return nil, err
	}
	return string(str), nil
}

func (c *CInfo) Scan(value interface{}) error {
	str, ok := value.([]byte)
	if !ok {
		return errors.New("不匹配的数据类型")
	}
	json.Unmarshal(str, c)
	return nil
}

type CUser struct {
	ID   uint
	Info CInfo
	Args Args
}

func TestTransaction() {
	GLOBAL_DB.AutoMigrate(&CUser{})
	//GLOBAL_DB.Create(&CUser{Info: CInfo{Name: "xiaocai", Age: 23}, Args: Args{"1", "2", "3"}})
	var u CUser
	GLOBAL_DB.First(&u)
	fmt.Println(u)
	// 没有写scan，无法渲染json文件内容
	// 调用scan，反解析

}
```

