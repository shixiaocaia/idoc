原理分析
===

## 程序初始化顺序

- 包之间的init函数，会从导入最深层包开始初始化，层层递归最后到mian包
- 每个包内部的初始化程序，从包变量初始化，再执行init函数
- 多个init函数按照文件名顺序逐个初始化
- 不管包被导入多少次，包内的init函数只会执行一次
- 所有初始化操作完成后，才会执行main函数

## 逃逸分析

### 前情提要

- 堆内存采用的是对一段连续内存的线性分配
- Go语言源代码对「栈内存」和「堆内存」的分配、释放等操作，都是对虚拟内存的操作，最终中央处理器CPU会统一通过MMU(管理单元内存Memory Management Unit)转化为实际的物理内存。

### 什么是逃逸

- 函数运行在栈上，栈上声明临时变量分配内存，在函数运行完毕后，回收内存（栈自动回收），每个函数的栈空间都是独立空间，其他函数无法进行访问。
- 但是在某些情况下，需要栈上面的数据在函数结束后仍然可以被访问，这就涉及到了逃逸。
- 数据从栈上逃逸，会跑到堆上面。栈上分配内存，需要找到一块大小合适的内存，之后通过GC（Garbage Collection）回收才能释放。

- o实现了gc垃圾回收机制，但gc会影响程序运行性能，所以要尽量减少程序的gc操作

### 逃逸分析过程

逃逸分析原则：如果一个函数返回一个对变量的引用，就会发生逃逸。

编译器会分析代码的特征和生命周期。Go中的变量只有在编译器证明函数返回不会被再引用，才会分配到栈上，否则其他情况都是分配到堆上。

简单来说，编译器会根据变量是否被外部引用来决定是否逃逸：

- 如果函数外部没有引用，则优先放到栈中：
- 如果函数外部存在引用，则必定放到堆中；

### 指针逃逸

传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，
由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一
定是高效的。

```go
package main

type Student struct{
    Name string
    Age int
}

func StudentRegister(name string, age int) *Student{
    s := new(Student)
    s.Name = name
    s.Age = age
    return s
}

func main(){
    StudentRegister("jim", 18)
}
```

- s本身为一个指针，作为函数返回值返回，会发生逃逸。

### 动态类型逃逸

很多函数都是interface类型，编译期间很难确定参数的具体类型，也能产生逃逸。

### 常见情况

- 在方法内把局部变量指针返回，被外部引用，其生命周期大于栈，则溢出。
- 发送指针或带有指针的值到channel，因为编译时候无法知道那个goroutine会在channel接受数据，编译器无法知道什么时候释放。
- 在一个切片上存储指针或带指针的值。比如[]*string，导致切片内容逃逸，其引用值一直在堆上。
- 因为切片的append导致超出容量，切片重新分配地址，切片背后的存储基于运行时的数据进行扩充，就会在堆上分配。
- 在interface类型上调用方法，在Interface调用方法是动态调度的，只有在运行时才知道。

### 如何避免

- go语言的接口类型方法调用是动态，因此不能在编译阶段确定，所有类型结构转换成接口的过程会涉及到内存逃逸发生，在频次访问较高的函数尽量避免调用接口。
- 不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销更大。
- 设定合理的slice长度，避免频繁超出容量，重新分配。
- 如果切片在编译期间的大小不能够确认或者大小超出栈的限制，多数情况下都会分配到堆上。

### 总结

- 堆上动态分配内存比栈上静态分配内存，开销大很多。
- 变量分配在栈上需要能在编译期确定它的作用域，否则会分配到堆上。
- Go编译器会在编译期对考察变量的作用域，并作一系列检查，如果它的作用域在运行期间对编译器一直是可知的，那么就会分配到栈上。简单来说，编译器会根据变量是否被外部引用来决定是否逃逸。
- 对于Go程序员来说，编译器的这些逃逸分析规则不需要掌握，我们只需通过`go build-gcflags'-m'`命令来观察变量逃逸情况就行了
- 不要盲目使用变量的指针作为函数参数，虽然它会减少复制操作。但其实当参数为变
  量自身的时候，复制是在栈上完成的操作，开销远比变量逃逸后动态地在堆上分配内
  存少的多。

## String

- 字符串可以为empty，不可以为nil。
- 字符串是不可以修改的，值不可变。
- 字符串的本质是字符数组，每个字符在存储时对应一个或者多个整数（根据编码方式决定）

```go
type stringStruct struct{
    str unsafe.Pointer
    len int
}
```

- string类型的底层是一个指向byte类型的切片。
- 这里的len是字符串中字节的个数，而不是字符的个数。
- 从这里可以看出string类型定义没有容量Cap，所以字符串类型**不能被扩容**，实际上的拼接、追加是通过**拷贝**实现的。

```go
str := "hello"
str = "Goland"

str[0] = "I" // error
```

- 实际中我们使用的是重新赋值，而不是修改。
- 每个字符在存储时对应一个整数，我们将一个字符赋值给byte类型是不允许的。

```go
str = "Hello world"
strbyte = [72 101 108 108 111 32 119 111 114 108 100]
string(strbyte) = "Hello world"
```

- 实际中我们可以将string类型转换为[]byte，但是注意转换后是一个拷贝，对源字符串没有影响。

---

[]byte转string：

- 新申请内存空间，构建内存地址为addr，长度为len
- 构建string对象，指针地址为addr，len字段为len
- 将切片数值内容拷贝到string所指的内存空间当中

> []byte转string，在某个场景下，临时转换时，不会发生内存拷贝。

string转[]byte：

- 新申请切片内存空间
- 将string中指针执行内存区域的内容拷贝到新切片当中

---

```go
str1 := "goland"

json := `{"hello", "goland", "name": ["zhangsan"]}`
```

- 使用双引号时，遇到部分特殊符号需要使用转移字符
- 使用反引号，可以在复杂场景当中保证原始内容

---

由于Go中string不能拷贝，发生拼接时会发生内存的拷贝，存在性能损耗。

常见的拼接包括了：

- +操作符
- fmt.Sprintf（一般用于字符串的格式化）
- bytes.Buffer
- strings.Builder
- append(性能较好，一般用这个)

## Slice

Q：Slice和数组的区别，Slice的扩容方式

Slice可以理解动态数组，数据扩容，是一种引用类型（值拷贝，是拷贝整个指针结构体的内容）

支持自动扩容，长度可变，申明时不需要指针大小。

---

```go
type stringStruct struct{
    str unsafe.Pointer // 指针变量，指向一块连续的内存空间
    len int
    cap int
}
```

可以类比到上面的string的底层，多了一个cap，支持扩容。

在初始化时，如果没有指定cap，那么cap和len相等。

---

在截取切片时，指向同一个底层数据，所以注意更新切片时，可能改变原切片的值。

在对切片进行复制时，复制后的切片和原来的切片指向同一块内存区域。但是数组赋值是创建新的内存区域。

> 这里的复制是复制了上述的结构体（重要的是其中的指针）。

---

追加元素不足时，slice会自动扩容

1.17之前：

1. 如果新的容量 >= 原容量的两倍，就使用新的容量大小
1. 否则，看切片容量小于1024，就扩展为原容量的两倍
1. 若大于1024，就会反复在原切片容量上增加1/4，直到新容量大于等于需要的容量。
1. 进行一个内存对其

1.17以后：

1. 如果新的容量 >= 原容量的两倍，就使用新的容量大小
2. 否则，看切片容量小于256，就扩展为原容量的两倍
3. 若大于等于256，就会根据公式扩容，直到新容量大于等于需要的容量。
4. 进行一个内存对其

---

为了使得赋值后的数组互不干扰，应该使用copy函数。

```go
temp := make([]int, len(cur)) // 注意len
copy(temp, cur)
```

## Map

map中key不允许重复且要能够比较。

在go当中，map的底层是hash表，用变种拉链法来解决hash冲突问题。

### 哈希冲突

将多个k-v键值对散列的存储在buckets中，buckets可以理解为一个连续的数组。

给定一个key/value键值对，存储到合适位置，需要经过两步骤：

- 计算hash值：将key转化为一个hash值
- 计算索引位置：用hash值对所有桶数取模得到一个索引值，得到了要插入的键值对位置

> 哈希冲突指的是当两个key计算出的hash值相等时，那后续的索引也是相同的，会冲突。

**拉链法：**

是很多语言使用的方法。主要实现是底层不直接使用连续数据来存储数据元素，而是通过数组和链表组合使用，数据里存储一个指针，指向一个链表。

当哈希值相同时，链接到同一个链表当中，如果没有冲突显然一个链表当中只有一个元素。

当冲突严重，链表长度过长时候，可以用红黑树代替链表。

> 保证数组中的指针是唯一不重复的，链表中节点存放冲突的节点，或者是单一的。

**开放地址法**：

将具体数据元素存储在数组桶中，在要插入新元素时，先根据哈希函数计算出hash值，根据hash值计算索引，如果发现冲突了，发现索引位置已经有数据了，就继续向后探测，直到找到未使用的数据槽位置。

### 底层结构

底层是一个指向hmap的指针，占用8个字节。

- buckets中包含了多个bmap的bucket数组，bucket底层采用链式结构将bmap连接起来。
- 处理冲突使用优化的拉链法，链表中每个节点存储的不是一个键值对，而是8个。

### 访问原理

1. 判断map是否为空或者无数据，返回无数据或者nil
2. map写检测，如果正处于写状态，此时不能读取，panic
3. 计算hash值和掩码
4. 判断当前map是否处于扩容状态
   1. 根据状态位判断当前桶是否被迁移
   2. 被迁移在新桶中找，否则根据掩码找到位置
5. 依次遍历桶以及溢出桶来查找key
   1. 遍历桶内的八个槽位
   2. 比较该槽位的tophash和当前的key的tophash是否相等
      1. 相等，继续比较key是否相同，相同返回value
      2. 不相等，查找该槽位后继是否为空状态
         1. 是，key在以后的槽中也没有，这个key不存在，直接返回零值
         2. 否，遍历下一个槽位
6. 当前桶没有找到，则遍历溢出桶，用同样的方式查找

### 赋值原理

原map中存在key就更新对应的value，若map不存在key，则插入键值对key/value。

> map在赋值操作前要初始化，使用make，而不是var声明。

> map是非线程安全的，不支持并发读写操作，当其他进程正在读写map时，执行map赋值会报读写并发错误。

1. map写检测，若正处于写状态，表示此时不能进行读取，报pannic
2. 计算出hash值，将map置为写状态
3. 判断桶数据是否为空，为空初始化桶数组
4. 目标桶查找
   1. 根据hash值找到桶的位置
   2. 判断是否在扩容：若正在扩容，迁移这个桶，并且还另外帮忙多迁移一个桶以及它的溢出桶
   3. 获取目标桶的指针，计算出tophash，开始后面的key查找过程
5. key查找
   1. 遍历桶和它的溢出桶的每个槽位
   2. 判断槽位的tophash和目标tophash
      1. 不相等
         1. 槽位tophash为空，标记这个位置为候选位置
         2. 槽位tophash的标志位后继为空，说明这个keyvalue之前没有被插入过，插入key/value
         3. tophash标志位不为空，说明存储着其他key，说明当前槽的tophash不符合，继续遍历下一个槽
      2. 相等
         1. 判断当前的槽位和目标key是否相等
            1. 不相等，继续遍历下一个槽位
            2. 相等，找到了目标key，原来已经存在键值对，则修改key1对应的value
6. key插入
   1. 若map中既没有找到key,且根据这个key找到的桶及其这个桶的溢出桶中没有空
      的槽位了，要申请一个新的溢出桶，在新申请的桶里插入
   2. 否则在找到的位置插入
7. 收尾程序
   1. 再次判断map的写状态
   2. 清除map的写状态

### 删除原理



### 扩容原理

在上面介绍map的写入操作的时候，其实忽略了一个点，那就是随着不断地往map里写入元素，会导致map的数据量变得很大，hash性能会逐渐变差，而且溢出桶会越来越多，导致查找的性能变得很差。所以，需要更多的桶和更大的内存保证哈希的读写性能。

当map遇到以下两种情况会触发扩容：

- map负载因子已经超过6.5——双倍扩容
- 溢出桶数量过多——等量扩容（溢出桶数量接数组桶数量时）

> map不是一个原子操作，不是一次性完成的，在扩容前要判断当前是否正在扩容，避免二次扩容混论。

> 负载因子 = 哈希表中元素数量 / 桶的数量

**为什么负载因子是6.5？**

负载因子是定义是6.5，经过测试后取出的一个比较合理的值。

每个bucket有8个空位，假设map里所有的数组桶都装满元素，没有一个数组桶有溢出桶，这时负载因子刚好是8。

负载因子是6.5的时候，说明数组桶快要用完了，存在溢出的情况，查找一个key可能要去遍历溢出桶，会造成查找性能下降，所以有必要扩容。

**溢出桶数量过多？**

负载因子小，map中元素总数少，但是bucket数量多，包含了大量的溢出桶。

**扩容过程**

go对map扩容，不是一次性将所有数据从旧的桶搬到新的桶。如果map数据量过大，会影响性能，因此采用是一种**渐进式**的数据转移技术，遵循**写时赋值**规则，对**用到的数据迁移**。

**迁移时机**

数据迁移一般发生在插入或者修改、删除key的时候，在扩容完毕后（预分配内存）后，不会立马进行迁移，而是采取写时复制方式，当访问到具体bucket时，才会逐渐从旧桶迁移到新桶。

### 遍历

每次遍历的数据顺序是不同的，因为每次开始遍历时，随机一个桶下标，桶内遍历的起点槽下边，遍历时候从这个桶开始，在遍历每个桶时，都从这个槽下标开始。

> 为什么随机开始
>
> 1. go扩容是渐进式的，遍历map时可能发生扩容，key位置会发生改变，下次遍历不是原来位置
> 2. hash表插入数据每次插入位置也是变化的，数据删除和添加位置也会变化，因为同一个桶以及溢出链表中数据位置不分先后。
>
> 防止用户错误的依赖于每次迭代的顺序，索性随机每次遍历位置。

遍历的流程大致是以下几个步骤：

1. map的并发写检测，判断map是否处于并发写状态，是则panic
2. 判断是否已经遍历完了，遍历完了直接退出
3. 开始遍历
4. 首选确定一个随机开始遍历的起始桶下标作为startBucket,然后确定一个随机的槽位下标作为offset
5. 根据startBucket和offset?开始遍历当前桶和当前桶的溢出桶，如果当前桶正在扩容，则进行步骤6，否则进行步骤7
6. 在遍历处于扩容状态的bucket的时候，因为当前bucket正在扩容，我们并不会遍历这个桶，而是会找到这个桶的l旧桶old_bucket,遍历l旧桶中的一部分key,这些key重新hash计算后能够散列到bucket中，对那些key经过重新hash计算不散列到bucket中的key,则跳过
7. 根据遍历初始化的时候选定的随机槽位开始遍历桶内的各个key/value
8. 继续遍历oucket溢出指针指向的溢出链表中的溢出桶
9. 假如遍历到了起始桶startBucket,则说明遍历完了，结束遍历
