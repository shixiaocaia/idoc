 Gin
===

[第三方中文文档](https://www.kancloud.cn/shuangdeyu/gin_book/949411)

[Go语言标准库之http/template](https://www.liwenzhou.com/posts/Go/template/#autoid-1-3-10)

## 是什么

Gin 是 Go 语言写的一个 web 框架，它具有运行速度快，分组的路由器，良好的崩溃捕获和错误处理，非常好的支持中间件和 json。总之在 Go 语言开发领域是一款值得好好研究的 Web 框架，开源网址：github.com/gin-gonic/gin

gin有如下特点：

- 接入成本非常低，作为一个组件，这是最重要的一点
- 拥有强大的中间件功能，用户可以自主定制需要的功能
- 由于使用了radix树，路由的性能很高。
- 数据绑定，让用户可以非常方便地从请求中获取想要的结构体。

### 下载

```go
go get -u github.com/gin-gonic/gin
```

### 运行模式

Gin框架提供了两种运行模式：`debug`（调试模式）和`release`（发布模式），用于控制框架的行为和日志输出级别。

1. **调试模式（debug）**：
   - 在调试模式下，Gin框架将提供更详细的日志输出，方便开发人员进行调试和开发。
   - 在请求发生错误时，Gin框架将返回详细的错误信息和堆栈跟踪。
   - Gin框架会自动重新编译和加载模板文件，以便在修改模板时无需重启应用程序。
   - 调试模式下，Gin框架会输出更多的调试信息，如请求和响应的详细信息、路由匹配信息等。
2. **发布模式（release）**：
   - 在发布模式下，Gin框架将提供更高的性能和更少的日志输出，适用于生产环境。
   - 发布模式下，Gin框架会限制详细的错误信息和堆栈跟踪的输出，以防止敏感信息泄露。
   - Gin框架不会自动重新加载模板文件，以提高性能和减少IO操作。
   - 发布模式下，Gin框架会输出更简洁的日志信息，如请求和响应的基本信息，以减少日志输出量。

## 模板与渲染

### 定义模板

### 解析模板

```go
r.GET("/posts/index", func(c *gin.Context) {
    c.HTML(200, "posts/index.html", gin.H{
        "title": "123",
    })
})
```

### 渲染模板

Gin框架中使用`LoadHTMLGlob()`或者`LoadHTMLFiles()`方法进行HTML模板渲染

- LoadHTMLGlob()去匹配文件夹
- LoadHTMLFiles()去匹配具体文件

### 自定义模板函数

```go
r.setFuncMap(template.FuncMap{
    "safe": func(str string) template.HTML{
        return template.HTML(str)
    },
})
```

### 静态文件

静态文件常包括：html页面上用到的样式文件.css，js文件，图片

当我们渲染的HTML文件中引用了静态文件时，我们只需要按照以下方式在渲染页面前调用`gin.Static`方法即可。

```go
router.Static("/static", "./static")
```

## 获取参数

```go
func main() {
	router := gin.Default()

	router.POST("/post", func(c *gin.Context) {

		id := c.Query("id")
		page := c.DefaultQuery("page", "0")
		name := c.PostForm("name")
		message := c.PostForm("message")

		fmt.Printf("id: %s; page: %s; name: %s; message: %s", id, page, name, message)
	})
	router.Run(":8080")
}
```

## 模型绑定和验证

- 当请求中携带了绑定结构体中的参数，会自动绑定，方便获取。
- 要通过反射取到字段，变量的首字母要大写
- 需要在绑定的字段上设置tag，比如，绑定格式为json，需要这样设置 `json:"fieldname"`，告知结构体字段
  - 常使用json，uri
  - 如果一个字段用`binding:"required"`修饰，并且在绑定时该字段的值为空，那么将返回一个错误。
- 一般使用ShouldBind
- 可以自定义验证器

```go
func mustBig(f1 validator.FieldLevel) bool {
	fmt.Println(f1.Field().Interface().(int))
	return true
}

if v, ok := binding.Validator.Engine().(*validator.Validate); ok {
    v.RegisterValidation("mustBig", mustBig)
}
```

- `ShouldBindQuery` 函数只绑定Get参数，不绑定post数据
- `ShouldBind`如果是GET请求会绑定查询字符串中的参数，
  - 如果是POST请求，优先绑定form表单或Json字符串中的数据，如果没有也可以绑定查询字符串中的数据

## 上传文件

- gin中的saveupFile实际是本地先读取，再拷贝到创建的文件当中

```go
func main() {
	r := gin.Default() //携带中间件启动

	r.POST("/testUpload", func(c *gin.Context) {
		file, _ := c.FormFile("file")
		//c.SaveUploadedFile(file, "./"+file.Filename)
		in, _ := file.Open()
		defer in.Close()
		out, _ := os.Create("./" + file.Filename)
		defer out.Close()
		io.Copy(out, in)
		c.JSON(200, gin.H{
			"msg": file,
		})
	})

	r.Run(":8080") // listen and serve on 0.0.0.0:8080
}
```

- 不论是多文件上传还是单文件上传，获取`form.File["file"]`中的`file`名称只需要与前端HTML表单中的文件上传字段名称保持一致。

```go
func main() {
	router := gin.Default()
	// 给表单限制上传大小 (默认 32 MiB)
	// router.MaxMultipartMemory = 8 << 20  // 8 MiB
	router.POST("/testUpload", func(c *gin.Context) {
		// 多文件
		form, _ := c.MultipartForm()
		files := form.File["upload"]

		for _, file := range files {
			log.Println(file.Filename)

			// 上传文件到指定的路径
			// c.SaveUploadedFile(file, file.Filename)
		}
		c.String(http.StatusOK, fmt.Sprintf("%d files uploaded!", len(files)))
	})
	router.Run(":8080")
}

```

## 重定向

```go
r.GET("/index", func(c *gin.Context) {
    c.Redirect(http.StatusMovedPermanently, "https://www.baidu.com")
})
```

## 路由分组

对router创建group就是分组，同一分组就会有同一前缀和中间件。

```go
func main() {
	r := gin.Default()
	userGroup := r.Group("/user")
	{
		userGroup.GET("/index", func(c *gin.Context) {...})
		userGroup.GET("/login", func(c *gin.Context) {...})
		userGroup.POST("/login", func(c *gin.Context) {...})

	}
	shopGroup := r.Group("/shop")
	{
		shopGroup.GET("/index", func(c *gin.Context) {...})
		shopGroup.GET("/cart", func(c *gin.Context) {...})
		shopGroup.POST("/checkout", func(c *gin.Context) {...})
	}
	r.Run()
}
```

## 中间件

中间件适合处理一些公共的业务逻辑，对多个请求做相同的处理，比如登录验证...

- 在每个请求中，都注册了登录验证这个中间件
- 不需要在某个请求中单独写判断

```go
func main() {
    r := gin.Default() // 默认启动方式，包含了Logger、 Recovery中间件
    
    
    // 新建一个没有任何默认中间件的路由
    r := gin.New()

    // 全局中间件
    // Logger 中间件将日志写入 gin.DefaultWriter，即使你将 GIN_MODE 设置为 release。
    // By default gin.DefaultWriter = os.Stdout
    r.Use(gin.Logger())

    // Recovery 中间件会 recover 任何 panic。如果有 panic 的话，会写入 500。
    r.Use(gin.Recovery())

    // 你可以为每个路由添加任意数量的中间件。
    r.GET("/benchmark", MyBenchLogger(), benchEndpoint)

    // 认证路由组
    // authorized := r.Group("/", AuthRequired())
    // 和使用以下两行代码的效果完全一样:
    authorized := r.Group("/")
    // 路由组中间件! 在此例中，我们在 "authorized" 路由组中使用自定义创建的 
    // AuthRequired() 中间件
    authorized.Use(AuthRequired())
    {
        authorized.POST("/login", loginEndpoint)
        authorized.POST("/submit", submitEndpoint)
        authorized.POST("/read", readEndpoint)

        // 嵌套路由组
        testing := authorized.Group("testing")
        testing.GET("/analytics", analyticsEndpoint)
    }

    // 监听并在 0.0.0.0:8080 上启动服务
    r.Run(":8080")
}
```

- 使用
  - c.Next 调用后续的处理函数
  - c.Abort 组织调用后续的处理函数
  - 在路由分组中直接注册，分组内的请求都可以默认带中间件
- 注意执行顺序
- gin中间件中或`handler`中启动新的`goroutine`时，**不能使用**原始的上下文（c *gin.Context），必须使用其只读副本（`c.Copy()`）。
  - 防止在c.Next的后续不一致，造成并发错误

## 日志以及日志格式

### 有什么用

- 记录参数信息
- 猜测用户行为
- 复现系统bug并修复

### 怎么用

- 默认日志文件打印在控制台
- 建议自定义日志格式
- 第三方日志中工具
  - logrus
  - go-logging
- 日志切割
  - 自行根据时间在写入时判断进行切割日志
  - 借助成品的日志包：go-file-rotatelogs  / file-rotatelogs
- 一般在中间件当中使用

