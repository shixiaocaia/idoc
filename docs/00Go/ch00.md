Hello world
===

## 安装

1. 下载[GO语言](https://link.segmentfault.com/?enc=GJ%2Fx51QtfKANYfOQDx%2FZYQ%3D%3D.yWqrklYSk2AczBi9JWI762tgQJX0HeUOlzJNhQgiCVc%3D)
2. 安装msi文件，`go version`检测安装
3. msi安装会默认配置环境变量，修改GOPATH路径
   - 创建GOPATH目录，在目录下创建三个文件夹
   - bin:用来存放编译后生成的可执行文件
   - pkg:用来存放编译后生成的归档文件
   - src:用来存放源码文件
4. 设置代理`go env -w GOPROXY=https://goproxy.cn,direct`
5. 开启go modules`go env -w GO111MODULE=on`

## 导包

对于导入的包，编译器会首先在`GOROOT`中寻找，随后会在项目所对应的`GOPATH`中寻找，最后才是在`全局GOPATH`中寻找，如果都无法找到，编译器将会报错。

### 包管理工具

1. **GOPATH**：把依赖包通过go get命令拉到本地GOPATH目录下，缺点是没法实现依赖包多版本管理。

   - 在工程经过`go build`、`go install`或 `go get`等指令后，会将拉取的第三方xxx依赖包放在`GOPATH/src`目录下
   - 产生的二进制可执行文件放在`GOPATH/bin` 目录下
   - 生成的中间缓存文件会被保存在 `GOPATH/pkg`下。

2. **DEP**：将依赖包通过DEP命令打包到工程下的vendor目录。Shopee金融团队、字节跳动教育团队用的就是DEP

   - 编译 Go 代码会优先从工程目录下的`vendor`目录先寻找依赖包，如果没有找到，然后`GOPATH` 中查找，都没找到最后在 `GOROOT`中查找。

3. **GoMod**：将依赖包拉取到统一的pkg目录下，分版本存储。腾讯云用GoMod的团队会比较多。

   - `GOMODULE`模式下所有依赖的包存放在`GOPATH/pkg/mod`目录下
   - 所有第三方二进制可执行文件放在`GOPATH/bin`目录下
   - 且工程项目可以放在`GOPATH`路径之外，但要求项目中需要有`go.mod`文件（该文件通过`go mod init`命令初始化可以生成）。
   - 注意：所使用的包，还是需要手动`go get`
   

> - go mod init testname后，引用该模块下的package时，作为共同的前缀，同时也是模块的标识。
> - 在项目的根目录中执行 go get 命令的话，go get 会同步更新 go.mod 和 go.sum 文件，go.mod 中记录的是依赖名及其版本，如：go.sum 文件中则会记录依赖包的哈希值（同时还有依赖包中 go.mod 的哈希值）
> - `go mod tidy`拉取缺少的模块，移除不用的模块
> - `go mod vendor`将 GOPATH/src/pkg/mod 中的缓存包，复制到项目的 vendor 目录中，即使用每个项目使用自身包的模式，类似之前的 govendor 管理方式
> - `go mod download`下载依赖包
> - `go mod edit`编辑 go.mod 文件一般直接用 ide 编辑就行
> - `go mod graph`打印模块依赖图
> - `go mod verify`验证依赖是否正确
> - `go mod why`解释为什么需要依赖

### golang环境

设置了Go Modules后，不能与$GOPATH共存,所以把项目从$GOPATH中移出即可，否则会提示go.mod exists but should not

## Hello world

```go
go build main.go // 得到二进制文件
./main 		     // 执行文件
```

## 数据结构

### 变量定义

- 类型声明
  - ```Go
    type FreezingC float64
    type Fahrenheit float64
    ```

  - FreezingC Fahrenheit虽然底层都相同，都是float64，但是仍然不是同一种类型，进行计算时需要显示类型转换
  - **Go中不具有隐式类型转换**
- 全局变量如果要在包外访问，首字母需要大写，golang是**以首字母大小**写来区分对包外是否可见。

### 常量

```Go
const str = "hello"
const(
    e = 1.2323
    p = 2312
)
```

- 常量不能用 `:=`
- 保证在编译阶段就计算出表达式的值，不需要等到运行阶段。
- 常量并不从属于任何具体类型，所以常量在声明时不说类型。

### 字符串

```Go
s := "hello world"
var s string = "hello world"
s2 := s[0:5] // 创建[0,5)的子串
```

- Go中区别`" "` 和 `' '` 前者表示string，后者表示byte类型。
- Go中string类型不可变，需要转换为`[]byte` 字节切片。
  - 两个字符串通过+=语句修改，是将新字符串赋值给变量
  - 两个字符串可以安全共用一段底层内存
  - 当发生+=，实际上是指向了新的内存地址，原来的底层没有发生变更
- string和byte不能直接运算拼接，需要使用显示类型转换。

### 指针

```Go
var a int = 5
p := &a

var a *int
```

- 用`&`取地址，用`*`取地址中的值
- 在打印时，用`&`特殊标记，这是一个指针变量。
- Go中 a++是一个语句，只能单独一行使用。

### 数组

```Go
array := [3]string{"heli,"hello","world"}

array := [...]string{"heli,"hello","world"}

func modify(array [5]string){
    array[0] = "another"
}

modify(array)

a := [2][3]int{
    {1, 1, 1},
    {2, 2, 2}
}
```

- 初始化后长度不可变
- 数组的长度len和空间cap，一定是相等的
- 数组在Go中为值类型
- 长度不同的数组，是不同的类型

### Slice

```Go
slice := []string{"heli,"hello","world"}


newSlice := make([]int, 2）
// len = cap = 2

newSlice := make([]int, 2, 100)
// len = 2, cap = 100

multSlice := make([][]int, 0)

multSlice = append(multSlice, []int{1,2,3})
multSlice = append(multSlice, []int{2,2,3})
multSlice[0][1] = 100
```

- Slice是一个结构体，指向底层的数组
- 区别一般数组，是否指定数组的大小。是一种动态数组，长度可变
  - cap：申请的空间
  - len：实际使用的空间
  - 扩容：cap == len时，对cap进行翻倍扩容，**重新分配内存地址，但是减小大小，不会改变地址**
- make函数只能用来创建`slice、map、channel`三种数据结构
- 传参拷贝引用，区别前面的值拷贝
- `slice[low:high]`还是共享了底层的数组，指针位置指向low，子切片
- 二维slice的初始化，访问

### Byte

- uint8的别名

### Map

```Go
// 创建一个变量
var m map[int]string = make(map[int]string)

m := map[sting]int{
    "ming":10,
    "zhangsan":13,
}

// 二维
var m map[int]map[int]string
m = make(map[int]map[int]string)
// 分布初始化
m[1] = make(map[int]string)
m[1][1] = "OK"

a，ok := m[2][1]
if !ok{
    m[2] = make(map[int]string)
}


score, err := m["ming"]
//访问时返回值和是否存在（true or false)

//注意这边的value知识一个拷贝，不对实际产生影响
for key, value := range m{
    fmt.Println("%s\t %d\t", key, value)
}

// 删除
delete(m, "ming")
```

- 存储一系列无序的键值对，基于键来存储值
- 传参时，还是指针，与切片相等，会改变底层的内容
- 无序访问

### Struct

```Go
type person struct{
    Name string
    Age int
}

func main() {
    //a := person{}
    //a.Name = "joe"
    //a.Age = 19
    a := &person{
        Name: "joe",
        Age: 19
    }
    a.Age = 20
}

// 匿名结构
func main(){
    a := & struct{
        Name string
        Age
    }{
        Name: "joe",
        Age: 19
    }
    
}
```

- 普通传递是值传递，所以开始就加&，取地址，方便后续使用，避免每一次使用取地址

```Go
type human struct{
    Sex int
}

type teacher struct{
    human
    Name string
    Age int
}

a := teacher{Name: "joe", Age: 19, human: human{Sex:0}}
a.Sex = 1
```

- 也支持嵌套
- 对于拥有相同成员变量的struct1，和struct2，对应的变量仍然不可以比较，不属于同一种类型，必须是相同类型值才能比较

### JSON

## 控制语句

```Go
func main(){
    a := 1
    switch a {
    case a >= 0:
         fmt.Println("a")
         fallthrough
    case 1:
    
    }

}
```

- 如果switch不加语句块，希望判断每一个case条件，使用fallthrough
- 默认下一个case满足，会跳出这个sw

## 函数

```Go
// 不定长变参，这是拷贝值
func A(b string, a ...int){
    

}

// 拷贝地址
func A(b string, a []int){


}
```

- Go函数不支持嵌套、重载和默认参数
- 无需声明原型、不定长度变参、多返回值、命名返回值参数

```Go
func main(){
    a := func(){
        fmt.Println("A")
    }
    a()
}
```

- A 是一个函数类型变量，当作函数一样调用

```Go
func main(){
    f := closure(10)
    fmt.Println(f(1))
}
func closure(x int) func(int) int{
    return func(y int) int {
        return x + y
    }
}
```

- 返回值是一个函数，x是声明时给的值，y是后传入的值

### 获取迭代变量

```Go
package main
import "fmt"
var rmdirs []func()
func main() {
   slice := []int{1,2,3,4,5}
   // 错误写法（闭包捕获dir 地址）
   for _, dir := range slice {
      fmt.Println("dir address is: ",&dir)
      rmdirs = append(rmdirs, func() {
         // 闭包捕获dir 地址
         fmt.Println( dir)
      })
   }
   for _, rmdir := range rmdirs {
      rmdir()
   }
   rmdirs = make([]func(), 0)
   // 正确写法(闭包捕获tmpDir，但是tmpDir 是一个临时变量，每次循环都会重新声明，所以每次循环都会有新的地址
   for _, dir := range slice {
      tmpDir := dir
      fmt.Println("tmpDir address is: ",&tmpDir)
      rmdirs = append(rmdirs, func() {
         fmt.Println(tmpDir)
      })
   }
   for _, rmdir := range rmdirs {
      rmdir()
   }
}
```

- dir的地址每次都是不变的，在闭包里捕获的都是同一个地址。所以用临时变量，迫使闭包每次捕获的是新地址
- 每次dir从切片中获取数值，而不是改变dir指向地址

### Defer

`defer`语句会将函数推迟到外层函数返回之后执行。

 推迟调用的函数其**参数会立即求值**，但直到外层函数返回前该函数都不会被调用。

- defer参数在语句出现前已经确定（除了用的地址，否则无法改变）
  - 实际的步骤是：设置的值->执行defer->将结果返回
    - 如果改变的不是返回值变量，defer语句内不造成影响
    - 如果返回值是匿名的，也不受到影响
- 使用场景：文件的关闭，或数据库连接的释放等，这样打开和关闭的代码写在一起，既可以使得代码更加的整洁，也可以防止出现开发者在写了长长的业务代码后，忘记关闭的情况。
- 有多个defer时，按照语句顺序，压栈出栈顺序进行

```Go
package main

import "fmt"

func main() {
    var fs = [4]func(){}

    for i := 0; i < 4; i++ {
       defer fmt.Println("defer i = ", i)
       // 延迟匿名函数，必须加括号
       defer func() {
          fmt.Println("defer_closure i = ", i)
       }()

       fs[i] = func() { fmt.Println("closure i = ", i) }
    }

    for _, f := range fs {
       f()
    }
}
```

### Panic

- 单独panic发生后，后续不会执行，配合defer中包含recover函数进行恢复
  - 因为defer无论如何都会执行，所以发生panic后，把recover放到defer中

## 方法

是某种特定类型的函数。

- 同名方法，不能根据形参的类型进行重载
- 对于type定义，也可以使用附加特定的方法

```Go
var a TZ
//method value
a.Print()
//method expression
(*TZ).Print(&a)

func (a *TZ) Print(){
    fmt.Println("Tz")
}
```

## 接口

```Go
package main

import "fmt"

type USB interface {
    Name() string
    Connect()
}

type PhoneConnecter struct {
    name string
}

func (pc PhoneConnecter) Name() string {
    return pc.name
}

func (pc PhoneConnecter) Connect() {
    fmt.Println("Connect:", pc.name)
}

func main() {
    a := PhoneConnecter{name: "xiaocai"}
    a.Connect()
    Disconnect(a)
}

func Disconnect(usb USB) {
    fmt.Println("Disconnext.")
}
```

- 一般把接口类型名后面加上`er`，接口作为函数参数时，任何满足这个接口的变量类型都可以传入
- 接口是一个或多个方法签名的集合
  - USB这个接口含有name、Connect两个方法
  - 只有方法声明，没有实现，没有数据字段
- 只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显示声明实现了哪个接口，这称为Structural Typing
  - PhoneConnecter实现了USB这个接口中的name，Connect方法，就算实现了该接口

```Go
type USB interface {
    Name() string
    Connecter
}

type Connecter interface {
    Connect()
}
```

- 接口可以匿名嵌入其它接口，或嵌入到结构中
- 也同时满足struct的嵌入，struct中嵌入一个满足接口类型的类型，那么整体新的struct也满足这个接口

```Go
func Disconnect(usb USB) {
    if pc, ok := usb.(PhoneConnecter); ok {
       fmt.Println("Disconnect:", pc.name)
       return
    }
    fmt.Println("Unknown device")
}
```

- 对接口类型的断言

```Go
type empty interface{

}
```

- 空接口，任何类型都实现了

```Go
func Disconnect(usb USB) {
    switch v := usb.(type) {
    case PhoneConnecter:
       fmt.Println("Disconnect:", v.name)
    default:
       fmt.Println("Unknown device")
    }
}
```

- 当接口的类型过多时，使用`type switch`

```Go
type tvConnecter struct{
    name string
}

func (tv  tvConnecter)Connect{
    ...
}

tv := tvConnecter{"1234"}
var a USB
a = USB(tv) //error
```

- 超级接口PhoneConnecter可以转换为下级接口，反之Connecter不可以转换为PhoneConnecter
  - 也就是只能实现**降级转换** 

```Go
a := PhoneConnecter{name: "xiaocai"}

var tmp PhoneConnecter
tmp = a

tmp.Connect()

a.name = "pc"

tmp.Connect()
```

- 将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，既无法修改复制品的状态，也无法获取指针
  - 这里tmp收到的是浅拷贝
  - a的改动，不会影响tmp

```Go

```

- 只有当接口存储的类型和对象都为il时，接口才等于nil
- 接口调用不会做receiver的自动转换
- 接口同样支持匿名字段方法
- 接口也可实现类似OOP中的多态
- 空接口可以作为任何类型数据的容器
