Hello world
===

## 安装

1. 下载[GO语言](https://link.segmentfault.com/?enc=GJ%2Fx51QtfKANYfOQDx%2FZYQ%3D%3D.yWqrklYSk2AczBi9JWI762tgQJX0HeUOlzJNhQgiCVc%3D)
2. 安装msi文件，`go version`检测安装
3. msi安装会默认配置环境变量，修改GOPATH路径
   - 创建GOPATH目录，在目录下创建三个文件夹
   - bin:用来存放编译后生成的可执行文件
   - pkg:用来存放编译后生成的归档文件
   - src:用来存放源码文件
4. 设置代理`go env -w GOPROXY=https://goproxy.cn,direct`
5. 开启go modules`go env -w GO111MODULE=on`

## 导包

对于导入的包，编译器会首先在`GOROOT`中寻找，随后会在项目所对应的`GOPATH`中寻找，最后才是在`全局GOPATH`中寻找，如果都无法找到，编译器将会报错。

### 包管理工具

1. **GOPATH**：把依赖包通过go get命令拉到本地GOPATH目录下，缺点是没法实现依赖包多版本管理。

   - 在工程经过`go build`、`go install`或 `go get`等指令后，会将拉取的第三方xxx依赖包放在`GOPATH/src`目录下
   - 产生的二进制可执行文件放在`GOPATH/bin` 目录下
   - 生成的中间缓存文件会被保存在 `GOPATH/pkg`下。

2. **DEP**：将依赖包通过DEP命令打包到工程下的vendor目录。Shopee金融团队、字节跳动教育团队用的就是DEP

   - 编译 Go 代码会优先从工程目录下的`vendor`目录先寻找依赖包，如果没有找到，然后`GOPATH` 中查找，都没找到最后在 `GOROOT`中查找。

3. **GoMod**：将依赖包拉取到统一的pkg目录下，分版本存储。腾讯云用GoMod的团队会比较多。

   - `GOMODULE`模式下所有依赖的包存放在`GOPATH/pkg/mod`目录下
   - 所有第三方二进制可执行文件放在`GOPATH/bin`目录下
   - 且工程项目可以放在`GOPATH`路径之外，但要求项目中需要有`go.mod`文件（该文件通过`go mod init`命令初始化可以生成）。

   ```go
   export GO111MODULE=on
   
   go mod init
   初始化当前文件夹，创建go.mod文件，事实上，如果你的环境中GO111MODULE=on，使用类似goland的工具创建工程会自动生成go.mod
   go mod tidy
   包整理（多的删去、少的拉取），使用之前自然是import了需要的库了
   go mod download
   下载依赖到本地（默认为 GOPATH/pkg/mod 目录）
   go mod vendor	
   将依赖包复制到工程文件的vendor目录下
   go mod verify
   验证依赖是否正确
   ```

> - go mod init testname后，引用该模块下的package时，作为共同的前缀，同时也是模块的标识。

### golang环境

设置了Go Modules后，不能与$GOPATH共存,所以把项目从$GOPATH中移出即可，否则会提示go.mod exists but should not

## Hello world

```go
go build main.go // 得到二进制文件
./main 		     // 执行文件
```

## 声明

### 变量的定义

```go
var a int
var b float32
var c, d float64
//变量名写在类型的前面
//可以一次性声明多个
//不初始化，默认0


e,f := 9,10
var g = "Hello world"
//:=类型自动推导
//如果初始化了，不需要在声明变量类型

p := new(T) //创建一个未命名的T类型变量，初始化为T类型的处置，并返回其地址

m := make(map[int]int)
//make 只能用于slice，channel，map
```

> 全局变量如果要在包外访问，首字母需要大写，golang是**以首字母大小**写来区分对包外是否可见。
>
> `:=` 推导变量类型，只能在函数体内使用。
>
> 定义在栈上的变量，会被自动回收

### 匿名变量

标识符为`_`（下划线）的变量，是系统保留的匿名变量，在赋值后，会被立即释放，称之为匿名变量。其作用是变量占位符，对其变量赋值结构。通常会在批量赋值时使用。

例如，函数返回多个值，我们仅仅需要**其中部分**，则不需要的使用_来占位

```go
func main(){
    _,v,_ := getData()
    fmt.Println(v)
}

func getData() (int,int,int){
	return 2, 4, 8
}
```

### 常量

```go 
const str = "Hello world"

const (
	e = 2.23234234
    pi = 12.324234234
)

// 常量生成器
type Weekday int
const (
	Sunday Weekday = iota
    Monday
    Tuesday
)
//Sunday = 0,后面 + 1递增
```

- 常量不能用`:=`标识。

- 保证在编译阶段就计算出表达式的值，不需要等到运行阶段。
- 常量并不从属于任何具体类型，所以常量在声明时不说类型。

### 类型声明

```go
type name underlying-type

type FreezingC float64
type Fahrenheit float64

T(x)//在具有相同的底层类型时，c
```

虽然摄氏温度和华氏温度的底层都是float64，但是他们仍然不是一种类型，二者之间计算需要通过显示类型转换，**Go不具有隐式类型转换**。

## IO

### printf print println

- Println输出后换行，Print 没有
- printf是类似C的格式化输出，[占位符](http://docscn.studygolang.com/pkg/fmt/)

```go
fmt.Printf("%d %[1]o %#[1]o\n",o)
//[1]表示重复使用第一个操作数o
//#表示输出相应的前缀0、0x、0X
```

## 数据类型

### 浮点数

- 浮点值可以用`%g`输出，会自动保持足够的精度，也可以用`%e %f`的形式来控制输出宽度和数值精度。
- NaN（Not a Number)
- +Inf
- -Inf

### 复数

- complex64和complex128，分别由float32和float64构成。

```go
var x complex128 = complex(1, 2) //1 + 2i
fmt.Println(real(x))
fmt.Println(imag(x))
```

### 布尔值

布尔值无法转换为数值，需要写一个函数显示转换

### 字符串

```go
s := "hello world"
var s string = "hello world"
s2 := s[0:5] // 创建[0,5)的子串
```

- 支持字符串连接
- 支持字符串比较
- 字符串是不可以改变的，通过+=语句修改，是将新字符串赋值给变量
  - 两个字符串可以安全共用一段底层内存
  - 当发生+=，实际上是指向了新的内存地址，原来的底层没有发生变更
- Unicode（Unicode.org)，包括了世界上所有文书体系的全部字符等，每个字符被赋予一个叫做Unicode码点的标准数字，在Go中称为**文字符号**（rune)，数据类型是int32，因此rune类型作为int32类型的别名
  - 每个文字符号序列可以表示成int32值序列，这种表示方式称作UTF-32或者UCS-4。
- 相关包
  - strings包用于搜索、替换、比较、修正、切分与连接字符串
  - bytes包，用于操作slice
  - strconv包具备函数，主要用于转换布尔值、整数、浮点数与之对应的字符串形式...
  - unicode包具有判别文字符号值特性的函数


## 判断

```go
func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
	    return v
	}
	return lim
}
```

- 条件语句不需要小括号，但是大括号还是必须的
- 判断条件之前可以写一个简单的语句，用分号隔开，作用域就在当前的if-else当中

```go
switch localStr {
case "case1":
  fmt.Println("case1")
case "case2":
  fmt.Println("case2")
case "case3":
  fmt.Println("case3")
default:
  fmt.Println("default")
```

- 当执行其中一条语句后，会有一个默认的`break`，如果希望从某个case顺序往下执行，可以使用fallthrough关键字。

## 循环

```go
func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}


func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
```

- 只有一种循环，同样没有小括号

## 函数

在Golang的函数定义中，所有的函数都以`func`开头，并且Golang命名推荐使用驼峰命名法。

> 注意，在Golang的函数中，如果首字母是小写，则只能在包内使用；如果首字母是大写，则可以在包外被引入使用。可以理解为，使用小写的函数，是`private`的，使用大写的函数，是`public`的。

```go
func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
```

- 返回值可以返回多个值
- `func` + 函数名 + 参数 + 返回类型

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```

- 默认会返回所有已经定义的变量值（x，y)
- 传入的sum值是**值传递**

## defer

`defer`语句会将函数推迟到外层函数返回之后执行。 推迟调用的函数其**参数会立即求值**，但直到外层函数返回前该函数都不会被调用。

- defer参数在语句出现前已经确定（除了用的地址，否则无法改变）
- 实际的步骤是：设置的值->执行defer->将结果返回
  - 如果改变的不是返回值变量，defer语句内不造成影响
  - 如果返回值是匿名的，也不受到影响
- 使用场景：文件的关闭，或数据库连接的释放等，这样打开和关闭的代码写在一起，既可以使得代码更加的整洁，也可以防止出现开发者在写了长长的业务代码后，忘记关闭的情况。
- 有多个defer时，按照语句顺序，压栈出栈顺序进行

```go
func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
```

## 指针

用`&`取地址，用`*`取地址中的值，但是没有指针运算。

在打印时，用`&`特殊标记，这是一个指针变量。

```go
var a *int
s := new(string)
```

- 前者是不分配内存地址的，是一个`<nil>`
- new出来的会分配一个内存地址

## 数组

常见的数组定义，长度不允许改变的，数组的空余位置用缺省表示。

```go
var a [10]int
arr := [10]int
//不能用make创建
```

###  切片

- 每个数组的大小是固定的，通过切片的方式实现**动态数组**，因此更加常用。

- Golang中的切片，不是拷贝，而是定义了新的指针，指向原来数组位置，所以会修改原来的值。
- 切片可以用append增加元素。但是，如果此时底层数组容量不够，此时切片将会指向一个重新分配空间后进行拷贝的数组。

```go
slice struct {
  array unsafe.Pointer
  len int
  cap int
}

a[low: high : max] // low到high，不包括hign位置变量，没有low和high默认截取全部
```

slice是一个特殊的引用类型,但是它自身也是个结构体

- 属性len表示可用元素数量，`len = hign - low`，读写操作不能超过这个限制,不然就会panic
- 属性cap表示最大扩张容量，`cap = max - low`，当然这个扩张容量也不是无限的扩张,它是受到了底层数组array的长度限制,超出了底层array的长度就会panic

### make

切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。

> 在此之前需要解释两个定义，len（长度）和cap（容量）。 len是数组的长度，指的是这个数组在定义的时候，所约定的长度。   cap是数组的容量，指的是底层数组的长度，也可以说是原数组在内存中的长度。 在前文中所提到的切片，如果我定义了一个str[0,0]的切片，此时的长度为0，但是容量依旧还是5。

```go
a := make([]int, 5)
// len(a) = cap(a) = 5

b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
```

> `arr[:]`没有参数时，默认截取全部
>
> len，cap的区别

### Append

```go
slice = append(slice, []int{7, 8, 9})
```

向切片中追加后，由于slice进行追加的元素超出了原来数组的大小，slice指向的底层数组更换为一个新的，后续针对这个数组进行改变。

当没有超过原底层的数组大小时，引用地址没有改变。

### Range

当使用 `for` 循环遍历切片时，每次迭代都会返回两个值。第一个值为当前元素的下标，第二个值为该下标所对应元素的一份副本。

也可以用下划线，忽略变量值。

```go
var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
		fmt.Printf("2**%d = %d\n", i, v)
	}
}
```

## 字典

```go
//创建
var dic = map[string]int{
  "apple":1,
  "watermelon":2,
}

m := map[int]int{
    1:1,
    2:2,
}

m := make(map[int]int)

//读取
i := m[1]
v, ok := m[1]

//遍历
for key, value := range m{
    fmt.Println(key, value)
}

//删除
delete(m, 1)
```

> map是一个链式hash表，初始化随机一个开始位置

## 结构体

```go
// type Name struct{}
type Vertex struct {
	X int
	Y int
}

v := Vertex{1,2}
fmt.Println(v.X)
// 用.来访问
v2 = Vertex{X: 1}
//列出部分值，Y:0 被隐式地赋予
v3 = Vertex{}      // X:0 Y:0，GO会给默认值
p  = &Vertex{1, 2} // 创建一个 *Vertex 类型的结构体（指针）
```

## 方法

方法就是一类带特殊的 **接收者** 参数的**函数**。

方法接收者在它自己的参数列表内，位于 `func` 关键字和方法名之间。

在此例中，`Abs` 方法拥有一个名为 `v`，类型为 `Vertex` 的接收者。

```go
type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
}
```

## 接口

它把所有具有共性的方法定义在一起，任何其他类型只要实现了这些方法就是实现了这个接口。

```go
type Shape interface {
  Area() float64
  Perimeter() float64
}
```

代码中Shape就是一个接口，声明了两个方法：面积（Area）和周长（Perimeter）。

空接口可以接受任何类型的值，但不能用来赋值。

## 断言

```go
vlaue,ok = x.(T)
```

T是接口类型，检测x类型与T是否符合

## 协程-goroutine

在协程出现之前，线程被作为调度的最小单位。协程可以理解是一种用户态，逻辑层面的线程。

协程Golang运行时调度，是充分利用了Golang多核的性能，同时执行多个方法。

```go
func main() {
  go a()
  go b()
  ...
}
```

main函数在一个goroutine中执行，然后go语句创建额外的goroutine。

## 通道-channel

- 类似unix中管道（pipe），先进先出；

- 线程安全，多个goroutine同时访问，不需要加锁；

- channel是有类型的，一个整数的channel只能存放整数。

```go

var ch0 chan int
var ch1 chan string
var ch2 chan map[string]string

type stu struct{}

var ch3 chan stu
var ch4 chan *stu
```

通道可以用于协程之间数据的传递，一般分为**有缓冲通道**和**无缓冲通道**。

> **无缓冲场景**：一直要等有别的协程通过<-chSync接手了这个参数，那么chSync<-1才会继续下去，要不然就一直阻塞着。
>
> **有缓冲场景**：chAsyn<-1则不会阻塞，因为缓冲大小是1，只有当放第二个值的时候，第一个还没被人拿走，这时候才会阻塞。

两个协程间如果有数据交流怎么办？这时候就可以用通道来传递。Golang的设计思想就是用通信代替共享内存。

## 单元测试

单元测试的两个常用指标：

1. **函数覆盖率**：被调用到的函数个数/总函数个数，通常要求100%；
2. **行覆盖率**：被调用到的行数/总行数，通常要求>60%。

> 行覆盖率（`line coverage`）：是否每一行都执行了？
>
> 函数覆盖率（`function coverage`）：是否每个函数都调用了？
>
> 分支覆盖率（`branch coverage`）：是否每个 if 代码块都执行了？
>
> 语句覆盖率（`statement coverage`）：是否每个语句都执行了？

### go test

- go的test一般以**xxx_test.go**为文件名，xxx并没有特别要求必须是要实测的文件名；
- TestMain作为初始化test；
- `Testxxx(t* testing.T)`
- `go test`即可运行单元测试；
- `go test --v fileName --test.run funcName`可以指定单测某个方法。

### go convey

go convey可以很好的支持setup和teardown，它可以在运行单个测试用例前都进行一次状态初始化，在结束后再进行销毁。这样如果有多个子用例，可以复用同一套初始化环境。

go convey还有很多已经定义好，能够直接使用的assert函数，并且还可以自定义assert函数。

