Hello world
===

## 安装



## 导包

对于导入的包，编译器会首先在`GOROOT`中寻找，随后会在项目所对应的`GOPATH`中寻找，最后才是在`全局GOPATH`中寻找，如果都无法找到，编译器将会报错。

> `import`导入的源文件的相对路径，而不是包名，包名是文件中开始的`package main`。
>
> - 在同一个文件内，只存在一种包名
>
> - 如果多个文件夹下有相同名字的package，它们其实是彼此无关的package

## 声明

### 变量的定义

```go
var a int
var b float32
var c, d float64
//变量名写在类型的前面
//可以一次性声明多个
//不初始化，默认0


e,f := 9,10
var g = "Hello world"
//:=类型自动推导
//如果初始化了，不需要在声明变量类型
```

### 匿名变量

标识符为`_`（下划线）的变量，是系统保留的匿名变量，在赋值后，会被立即释放，称之为匿名变量。其作用是变量占位符，对其变量赋值结构。通常会在批量赋值时使用。

例如，函数返回多个值，我们仅仅需要**其中部分**，则不需要的使用_来占位

```go
func main(){
    _,v,_ := getData()
    fmt.Println(v)
}

func getData() (int,int,int){
	return 2, 4, 8
}
```

### 常量

```go 
const str = "Hello world"
```

常量不能用`:=`标识。

## 判断

```go
func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
	    return v
	}
	return lim
}
```

- 条件语句不需要小括号，但是大括号还是必须的
- 判断条件之前可以写一个简单的语句，用分号隔开，作用域就在当前的if-else当中

## 循环

```go
func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}


func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
```

- 只有一种循环，同样没有小括号

## 函数

在Golang的函数定义中，所有的函数都以`func`开头，并且Golang命名推荐使用驼峰命名法。

> 注意，在Golang的函数中，如果首字母是小写，则只能在包内使用；如果首字母是大写，则可以在包外被引入使用。可以理解为，使用小写的函数，是`private`的，使用大写的函数，是`public`的。

```go
func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
```

- 返回值可以返回多个值
- `func` + 函数名 + 参数 + 返回类型

```go
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
```

默认会返回所有已经定义的变量值

## defer

`defer`语句会将函数推迟到外层函数返回之后执行。 推迟调用的函数其**参数会立即求值**，但直到外层函数返回前该函数都不会被调用。

```go
func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
```

> `defer`后面必须是函数调用，不能是其他语句。
>
> 使用场景：文件的关闭，或数据库连接的释放等，这样打开和关闭的代码写在一起，既可以使得代码更加的整洁，也可以防止出现开发者在写了长长的业务代码后，忘记关闭的情况。
>
> 底层实现：将后面的函数调用的地址压栈，后执行。

## 指针

用`&`取地址，用`*`取地址中的值，但是没有指针运算。

在打印时，用`&`特殊标记，这是一个指针变量。

## 数组

常见的数组定义是

```go
var a [10]int
```

###  切片

将一个数组按需切出自己所需的部分，很像是python的一部分。

- 每个数组的大小是固定的，通过切片的方式实现动态数组，因此更加常用。

- Golang中的切片，不是拷贝，而是定义了新的指针，指向原来数组位置，所以会修改原来的值。
- 切片可以用append增加元素。但是，如果此时底层数组容量不够，此时切片将会指向一个重新分配空间后进行拷贝的数组。

```go
a[low: high] // low到high，不包括hign位置变量
```

### make

切片可以用内建函数 make 来创建，这也是你创建动态数组的方式。

> 在此之前需要解释两个定义，len（长度）和cap（容量）。 len是数组的长度，指的是这个数组在定义的时候，所约定的长度。   cap是数组的容量，指的是底层数组的长度，也可以说是原数组在内存中的长度。 在前文中所提到的切片，如果我定义了一个str[0,0]的切片，此时的长度为0，但是容量依旧还是5。

```go
a := make([]int, 5)
// len(a) = cap(a) = 5

b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
```

> len，cap的区别

